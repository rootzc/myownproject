!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACTIVE_EXPIRE_CYCLE_FAST	src/vr_server.h	15;"	d
ACTIVE_EXPIRE_CYCLE_FAST_DURATION	src/vr_server.h	12;"	d
ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP	src/vr_server.h	11;"	d
ACTIVE_EXPIRE_CYCLE_SLOW	src/vr_server.h	14;"	d
ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC	src/vr_server.h	13;"	d
AE_ALL_EVENTS	dep/ae/ae.h	47;"	d
AE_DELETED_EVENT_ID	dep/ae/ae.h	51;"	d
AE_DONT_WAIT	dep/ae/ae.h	48;"	d
AE_ERR	dep/ae/ae.h	39;"	d
AE_FILE_EVENTS	dep/ae/ae.h	45;"	d
AE_NOMORE	dep/ae/ae.h	50;"	d
AE_NONE	dep/ae/ae.h	41;"	d
AE_NOTUSED	dep/ae/ae.h	54;"	d
AE_OK	dep/ae/ae.h	38;"	d
AE_READABLE	dep/ae/ae.h	42;"	d
AE_TIME_EVENTS	dep/ae/ae.h	46;"	d
AE_WRITABLE	dep/ae/ae.h	43;"	d
AL_START_HEAD	dep/dlist/dlist.h	62;"	d
AL_START_HEAD	src/vr_quicklist.h	132;"	d
AL_START_TAIL	dep/dlist/dlist.h	63;"	d
AL_START_TAIL	src/vr_quicklist.h	133;"	d
AOF_AUTOSYNC_BYTES	src/vr_aof.h	9;"	d
AOF_OFF	src/vr_aof.h	5;"	d
AOF_ON	src/vr_aof.h	6;"	d
AOF_RW_BUF_BLOCK_SIZE	src/vr_aof.h	25;"	d
AOF_WAIT_REWRITE	src/vr_aof.h	7;"	d
ARGUMENTLEN	dep/himemcached-0.1.0/himemcached.c	376;"	d	file:
ASSERT	dep/util/dutil.h	31;"	d
ASSERT	dep/util/dutil.h	41;"	d
ASSERT	dep/util/dutil.h	51;"	d
ASSERT	tests/vrt_util.h	52;"	d
ATOMIC_LOCK_TYPE	dep/util/dutil.h	130;"	d
ATOMIC_LOCK_TYPE	dep/util/dutil.h	140;"	d
ATOMIC_LOCK_TYPE	dep/util/dutil.h	168;"	d
AVOID_ERRNO	src/vr_lzfP.h	64;"	d
BFOVERFLOW_FAIL	src/vr_bitops.c	242;"	d	file:
BFOVERFLOW_SAT	src/vr_bitops.c	241;"	d	file:
BFOVERFLOW_WRAP	src/vr_bitops.c	240;"	d	file:
BITFIELDOP_GET	src/vr_bitops.c	356;"	d	file:
BITFIELDOP_INCRBY	src/vr_bitops.c	358;"	d	file:
BITFIELDOP_SET	src/vr_bitops.c	357;"	d	file:
BITOP_AND	src/vr_bitops.c	351;"	d	file:
BITOP_NOT	src/vr_bitops.c	354;"	d	file:
BITOP_OR	src/vr_bitops.c	352;"	d	file:
BITOP_XOR	src/vr_bitops.c	353;"	d	file:
BLOCKED_LIST	src/vr_client.h	64;"	d
BLOCKED_NONE	src/vr_client.h	63;"	d
BLOCKED_WAIT	src/vr_client.h	65;"	d
CHECK_DATA_FLAG_MASTER	tests/vrt_check_data.c	30;"	d	file:
CHECK_DATA_FLAG_NONE	tests/vrt_check_data.c	29;"	d	file:
CHECK_DATA_FLAG_SLAVE	tests/vrt_check_data.c	31;"	d	file:
CHECK_INPUT	src/vr_lzfP.h	85;"	d
CHECK_UNIT_STATE_GET_EXPIRE	tests/vrt_check_data.c	34;"	d	file:
CHECK_UNIT_STATE_GET_TYPE	tests/vrt_check_data.c	35;"	d	file:
CHECK_UNIT_STATE_GET_VALUE	tests/vrt_check_data.c	36;"	d	file:
CHECK_UNIT_STATE_NULL	tests/vrt_check_data.c	33;"	d	file:
CLIENT_ASKING	src/vr_client.h	23;"	d
CLIENT_BLOCKED	src/vr_client.h	17;"	d
CLIENT_CLOSE_AFTER_REPLY	src/vr_client.h	19;"	d
CLIENT_CLOSE_ASAP	src/vr_client.h	24;"	d
CLIENT_DIRTY_CAS	src/vr_client.h	18;"	d
CLIENT_DIRTY_EXEC	src/vr_client.h	26;"	d
CLIENT_FORCE_AOF	src/vr_client.h	28;"	d
CLIENT_FORCE_REPL	src/vr_client.h	29;"	d
CLIENT_JUMP	src/vr_client.h	43;"	d
CLIENT_LUA	src/vr_client.h	22;"	d
CLIENT_LUA_DEBUG	src/vr_client.h	41;"	d
CLIENT_LUA_DEBUG_SYNC	src/vr_client.h	42;"	d
CLIENT_MASTER	src/vr_client.h	14;"	d
CLIENT_MASTER_FORCE_REPLY	src/vr_client.h	27;"	d
CLIENT_MONITOR	src/vr_client.h	15;"	d
CLIENT_MULTI	src/vr_client.h	16;"	d
CLIENT_PENDING_WRITE	src/vr_client.h	36;"	d
CLIENT_PREVENT_AOF_PROP	src/vr_client.h	33;"	d
CLIENT_PREVENT_PROP	src/vr_client.h	35;"	d
CLIENT_PREVENT_REPL_PROP	src/vr_client.h	34;"	d
CLIENT_PRE_PSYNC	src/vr_client.h	30;"	d
CLIENT_PUBSUB	src/vr_client.h	32;"	d
CLIENT_READONLY	src/vr_client.h	31;"	d
CLIENT_REPLY_OFF	src/vr_client.h	38;"	d
CLIENT_REPLY_SKIP	src/vr_client.h	40;"	d
CLIENT_REPLY_SKIP_NEXT	src/vr_client.h	39;"	d
CLIENT_SLAVE	src/vr_client.h	13;"	d
CLIENT_TYPE_MASTER	src/vr_client.h	56;"	d
CLIENT_TYPE_NORMAL	src/vr_client.h	53;"	d
CLIENT_TYPE_OBUF_COUNT	src/vr_client.h	57;"	d
CLIENT_TYPE_PUBSUB	src/vr_client.h	55;"	d
CLIENT_TYPE_SLAVE	src/vr_client.h	54;"	d
CLIENT_UNBLOCKED	src/vr_client.h	20;"	d
CLIENT_UNIX_SOCKET	src/vr_client.h	25;"	d
CMD_ADMIN	src/vr_command.h	10;"	d
CMD_ASKING	src/vr_command.h	18;"	d
CMD_CALL_FULL	src/vr_command.h	28;"	d
CMD_CALL_NONE	src/vr_command.h	22;"	d
CMD_CALL_PROPAGATE	src/vr_command.h	27;"	d
CMD_CALL_PROPAGATE_AOF	src/vr_command.h	25;"	d
CMD_CALL_PROPAGATE_REPL	src/vr_command.h	26;"	d
CMD_CALL_SLOWLOG	src/vr_command.h	23;"	d
CMD_CALL_STATS	src/vr_command.h	24;"	d
CMD_DENYOOM	src/vr_command.h	8;"	d
CMD_FAST	src/vr_command.h	19;"	d
CMD_LOADING	src/vr_command.h	15;"	d
CMD_NOSCRIPT	src/vr_command.h	12;"	d
CMD_NOT_USED_1	src/vr_command.h	9;"	d
CMD_PUBSUB	src/vr_command.h	11;"	d
CMD_RANDOM	src/vr_command.h	13;"	d
CMD_READONLY	src/vr_command.h	7;"	d
CMD_SKIP_MONITOR	src/vr_command.h	17;"	d
CMD_SORT_FOR_SCRIPT	src/vr_command.h	14;"	d
CMD_STALE	src/vr_command.h	16;"	d
CMD_WRITE	src/vr_command.h	6;"	d
COMPRESS_MAX	src/vr_quicklist.c	73;"	d	file:
CONFF_LOCK	src/vr_conf.c	/^CONFF_LOCK(void)$/;"	f
CONFF_UNLOCK	src/vr_conf.c	/^CONFF_UNLOCK(void)$/;"	f
CONFIG_AUTHPASS_MAX_LEN	src/vr_conf.h	47;"	d
CONFIG_AUTHPASS_MAX_LEN	src/vr_server.h	7;"	d
CONFIG_BINDADDR_MAX	src/vr_conf.h	49;"	d
CONFIG_DEFAULT_ACTIVE_REHASHING	src/vr_conf.h	23;"	d
CONFIG_DEFAULT_CACHED_KEYS_COUNT	tests/vrabtest.c	32;"	d	file:
CONFIG_DEFAULT_CHECKER	tests/vrabtest.c	24;"	d	file:
CONFIG_DEFAULT_CLIENTS_PER_DISPATCH_THREAD	tests/vrabtest.c	35;"	d	file:
CONFIG_DEFAULT_DATA_DIR	src/vr_conf.h	40;"	d
CONFIG_DEFAULT_DISPATCH_THREADS_COUNT	tests/vrabtest.c	34;"	d	file:
CONFIG_DEFAULT_FIELDS_MAX_COUNT	tests/vrabtest.c	29;"	d	file:
CONFIG_DEFAULT_HIT_RATIO	tests/vrabtest.c	33;"	d	file:
CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES	src/vr_server.h	37;"	d
CONFIG_DEFAULT_HOST	src/vr_conf.h	36;"	d
CONFIG_DEFAULT_INTERNAL_DBNUM	src/vr_conf.h	26;"	d
CONFIG_DEFAULT_KEY_LENGTH_RANGE_BEGIN	tests/vrabtest.c	26;"	d	file:
CONFIG_DEFAULT_KEY_LENGTH_RANGE_END	tests/vrabtest.c	27;"	d	file:
CONFIG_DEFAULT_LOGFILE	tests/vrabtest.c	36;"	d	file:
CONFIG_DEFAULT_LOGICAL_DBNUM	src/vr_conf.h	25;"	d
CONFIG_DEFAULT_MAXMEMORY	src/vr_conf.h	28;"	d
CONFIG_DEFAULT_MAXMEMORY_POLICY	src/vr_server.h	23;"	d
CONFIG_DEFAULT_MAXMEMORY_SAMPLES	src/vr_conf.h	29;"	d
CONFIG_DEFAULT_MAX_CLIENTS	src/vr_conf.h	30;"	d
CONFIG_DEFAULT_MAX_CLIENTS	src/vr_conf.h	32;"	d
CONFIG_DEFAULT_MAX_TIME_COMPLEXITY_LIMIT	src/vr_conf.h	42;"	d
CONFIG_DEFAULT_PIDFILE	tests/vrabtest.c	23;"	d	file:
CONFIG_DEFAULT_PRODUCE_THREADS_COUNT	tests/vrabtest.c	31;"	d	file:
CONFIG_DEFAULT_REPL_BACKLOG_SIZE	src/vr_replication.h	42;"	d
CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT	src/vr_replication.h	43;"	d
CONFIG_DEFAULT_SERVER_PORT	src/vr_conf.h	38;"	d
CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN	src/vr_conf.h	44;"	d
CONFIG_DEFAULT_SLOWLOG_MAX_LEN	src/vr_conf.h	45;"	d
CONFIG_DEFAULT_STRING_MAX_LENGTH	tests/vrabtest.c	28;"	d	file:
CONFIG_DEFAULT_TEST_INTERVAL	tests/vrabtest.c	25;"	d	file:
CONFIG_DEFAULT_TEST_TARGET	tests/vrabtest.c	30;"	d	file:
CONFIG_DEFAULT_THREADS_NUM	src/vr_conf.h	34;"	d
CONFIG_MAX_LINE	src/vr_conf.c	1644;"	d	file:
CONFIG_MIN_RESERVED_FDS	src/vr_server.h	4;"	d
CONFIG_REPL_BACKLOG_MIN_SIZE	src/vr_replication.h	44;"	d
CONFIG_REPL_SYNCIO_TIMEOUT	src/vr_replication.h	37;"	d
CONFIG_RUN_ID_SIZE	src/vr_conf.h	22;"	d
CONFIG_SOPN_ADMINPASS	src/vr_conf.h	19;"	d
CONFIG_SOPN_BIND	src/vr_conf.h	11;"	d
CONFIG_SOPN_COMMANDSNAP	src/vr_conf.h	20;"	d
CONFIG_SOPN_DATABASES	src/vr_conf.h	5;"	d
CONFIG_SOPN_DIR	src/vr_conf.h	14;"	d
CONFIG_SOPN_IDPDATABASE	src/vr_conf.h	6;"	d
CONFIG_SOPN_MAXCLIENTS	src/vr_conf.h	15;"	d
CONFIG_SOPN_MAXMEMORY	src/vr_conf.h	7;"	d
CONFIG_SOPN_MAXMEMORYP	src/vr_conf.h	8;"	d
CONFIG_SOPN_MAXMEMORYS	src/vr_conf.h	9;"	d
CONFIG_SOPN_MTCLIMIT	src/vr_conf.h	10;"	d
CONFIG_SOPN_PORT	src/vr_conf.h	12;"	d
CONFIG_SOPN_REQUIREPASS	src/vr_conf.h	18;"	d
CONFIG_SOPN_SLOWLOGLST	src/vr_conf.h	16;"	d
CONFIG_SOPN_SLOWLOGML	src/vr_conf.h	17;"	d
CONFIG_SOPN_THREADS	src/vr_conf.h	13;"	d
CONF_FIELD_FLAGS_NO_MODIFY	src/vr_conf.h	64;"	d
CONF_FIELD_TYPE_ARRAYSDS	src/vr_conf.h	61;"	d
CONF_FIELD_TYPE_INT	src/vr_conf.h	58;"	d
CONF_FIELD_TYPE_LONGLONG	src/vr_conf.h	59;"	d
CONF_FIELD_TYPE_SDS	src/vr_conf.h	60;"	d
CONF_MAX_LINE	src/vr_conf.c	18;"	d	file:
CONF_ORGANIZATION_NAME_COMMAN	src/vr_conf.c	12;"	d	file:
CONF_ORGANIZATION_NAME_SERVER	src/vr_conf.c	13;"	d	file:
CONF_RLOCK	src/vr_conf.c	/^CONF_RLOCK(void)$/;"	f
CONF_TAG_DEFAULT_DISTRIBUTION	src/vr_conf.c	23;"	d	file:
CONF_TAG_DEFAULT_HASH	src/vr_conf.c	21;"	d	file:
CONF_TAG_DEFAULT_HASH_TAG	src/vr_conf.c	22;"	d	file:
CONF_TAG_DEFAULT_LISTEN	src/vr_conf.c	28;"	d	file:
CONF_TAG_DEFAULT_MAXMEMORY	src/vr_conf.c	29;"	d	file:
CONF_TAG_DEFAULT_NOREPLY	src/vr_conf.c	31;"	d	file:
CONF_TAG_DEFAULT_RDB_DISKLESS	src/vr_conf.c	32;"	d	file:
CONF_TAG_DEFAULT_REDIS_AUTH	src/vr_conf.c	24;"	d	file:
CONF_TAG_DEFAULT_REDIS_DB	src/vr_conf.c	25;"	d	file:
CONF_TAG_DEFAULT_SERVERS	src/vr_conf.c	27;"	d	file:
CONF_TAG_DEFAULT_THREADS	src/vr_conf.c	30;"	d	file:
CONF_TAG_DEFAULT_TIMEOUT	src/vr_conf.c	26;"	d	file:
CONF_TAG_DEFAULT_TYPE	src/vr_conf.c	20;"	d	file:
CONF_TOKEN_ARRAY_START	src/vr_conf.c	10;"	d	file:
CONF_TOKEN_KEY_VALUE_BETWEEN	src/vr_conf.c	9;"	d	file:
CONF_TOKEN_ORGANIZATION_END	src/vr_conf.c	8;"	d	file:
CONF_TOKEN_ORGANIZATION_START	src/vr_conf.c	7;"	d	file:
CONF_UNLOCK	src/vr_conf.c	/^CONF_UNLOCK(void)$/;"	f
CONF_UNSET_DIST	src/vr_conf.h	55;"	d
CONF_UNSET_GROUP	src/vr_conf.h	53;"	d
CONF_UNSET_HASH	src/vr_conf.h	54;"	d
CONF_UNSET_NUM	src/vr_conf.h	51;"	d
CONF_UNSET_PTR	src/vr_conf.h	52;"	d
CONF_VALUE_NO	src/vr_conf.c	16;"	d	file:
CONF_VALUE_TYPE_ARRAY	src/vr_conf.h	132;"	d
CONF_VALUE_TYPE_STRING	src/vr_conf.h	131;"	d
CONF_VALUE_TYPE_UNKNOW	src/vr_conf.h	130;"	d
CONF_VALUE_YES	src/vr_conf.c	15;"	d	file:
CONF_WLOCK	src/vr_conf.c	/^CONF_WLOCK(void)$/;"	f
CR	dep/util/dutil.h	11;"	d
CR	tests/vrt_util.h	28;"	d
CRLF	dep/util/dutil.h	12;"	d
CRLF	tests/vrt_util.h	29;"	d
CRLF_LEN	dep/util/dutil.h	13;"	d
CRLF_LEN	tests/vrt_util.h	30;"	d
CRON_DBS_PER_CALL	src/vr_server.h	9;"	d
ConfTableDictType	src/vr_conf.c	/^static dictType ConfTableDictType = {$/;"	v	file:
D	src/vr_quicklist.c	30;"	d	file:
D	src/vr_quicklist.c	32;"	d	file:
DEFINE_ACTION	dep/dhashkit/dhashkit.h	33;"	d
DEFINE_ACTION	dep/dhashkit/dhashkit.h	38;"	d
DEFINE_ACTION	dep/dhashkit/dhashkit.h	40;"	d
DEFINE_ACTION	dep/dhashkit/dhashkit.h	45;"	d
DEFINE_ACTION	src/vr_conf.c	34;"	d	file:
DEFINE_ACTION	src/vr_conf.c	39;"	d	file:
DEFINE_ACTION	src/vr_conf.c	41;"	d	file:
DEFINE_ACTION	src/vr_conf.c	46;"	d	file:
DEFINE_ACTION	src/vr_conf.c	48;"	d	file:
DEFINE_ACTION	src/vr_conf.c	53;"	d	file:
DEFINE_ACTION	src/vr_conf.h	83;"	d
DEFINE_ACTION	src/vr_conf.h	88;"	d
DICT_ERR	src/vr_dict.h	7;"	d
DICT_HT_INITIAL_SIZE	src/vr_dict.h	65;"	d
DICT_NOTUSED	src/vr_dict.h	10;"	d
DICT_OK	src/vr_dict.h	6;"	d
DICT_STATS_VECTLEN	src/vr_dict.c	970;"	d	file:
DIST_CODEC	dep/dhashkit/dhashkit.h	/^    DIST_CODEC( DEFINE_ACTION )$/;"	e	enum:dist_type
DIST_CODEC	dep/dhashkit/dhashkit.h	28;"	d
DIST_SENTINEL	dep/dhashkit/dhashkit.h	/^    DIST_SENTINEL$/;"	e	enum:dist_type
DMALLOC_LIB	dep/dmalloc/dmalloc.h	21;"	d
DMALLOC_LIB	dep/dmalloc/dmalloc.h	36;"	d
DUSE_JEMALLOC	dep/dmalloc/dmalloc.h	11;"	d
ERRMSG_MAX_LEN	tests/vrt_simple.c	17;"	d	file:
EVICTION_SAMPLES_ARRAY_SIZE	src/vr_server.c	428;"	d	file:
EVICTPOLICY_CODEC	src/vr_conf.h	/^    EVICTPOLICY_CODEC( DEFINE_ACTION )$/;"	e	enum:evictpolicy_type
EVICTPOLICY_CODEC	src/vr_conf.h	75;"	d
EVICTPOLICY_SENTINEL	src/vr_conf.h	/^    EVICTPOLICY_SENTINEL$/;"	e	enum:evictpolicy_type
EXPAND_MAX_SIZE_PER_TIME	dep/himemcached-0.1.0/himcread.c	128;"	d	file:
F	dep/dhashkit/dmd5.c	30;"	d	file:
FILL_MAX	src/vr_quicklist.c	83;"	d	file:
FNV_32_INIT	dep/dhashkit/dfnv.c	/^static uint32_t FNV_32_INIT = 2166136261UL;$/;"	v	file:
FNV_32_PRIME	dep/dhashkit/dfnv.c	/^static uint32_t FNV_32_PRIME = 16777619;$/;"	v	file:
FNV_64_INIT	dep/dhashkit/dfnv.c	/^static uint64_t FNV_64_INIT = UINT64_C(0xcbf29ce484222325);$/;"	v	file:
FNV_64_PRIME	dep/dhashkit/dfnv.c	/^static uint64_t FNV_64_PRIME = UINT64_C(0x100000001b3);$/;"	v	file:
FRST	src/vr_lzf_c.c	12;"	d	file:
G	dep/dhashkit/dmd5.c	31;"	d	file:
GET	dep/dhashkit/dmd5.c	54;"	d	file:
GET	dep/dhashkit/dmd5.c	63;"	d	file:
GNUC_VERSION	dep/util/dspecialconfig.h	14;"	d
H	dep/dhashkit/dmd5.c	32;"	d	file:
HASHTABLE_MIN_FILL	src/vr_server.h	51;"	d
HASH_CODEC	dep/dhashkit/dhashkit.h	/^    HASH_CODEC( DEFINE_ACTION )$/;"	e	enum:hash_type
HASH_CODEC	dep/dhashkit/dhashkit.h	14;"	d
HASH_SENTINEL	dep/dhashkit/dhashkit.h	/^    HASH_SENTINEL$/;"	e	enum:hash_type
HAVE_ATOMIC	dep/util/dspecialconfig.h	16;"	d
HAVE_ATOMIC	dep/util/dspecialconfig.h	20;"	d
HAVE_MALLOC_SIZE	dep/dmalloc/dmalloc.h	24;"	d
HAVE_MALLOC_SIZE	dep/dmalloc/dmalloc.h	31;"	d
HAVE_PROC_MAPS	dep/util/dspecialconfig.h	53;"	d
HAVE_PROC_SMAPS	dep/util/dspecialconfig.h	54;"	d
HAVE_PROC_SOMAXCONN	dep/util/dspecialconfig.h	55;"	d
HAVE_PROC_STAT	dep/util/dspecialconfig.h	52;"	d
HAVE_TASKINFO	dep/util/dspecialconfig.h	60;"	d
HIMC_MAJOR	dep/himemcached-0.1.0/himemcached.h	7;"	d
HIMC_MINOR	dep/himemcached-0.1.0/himemcached.h	8;"	d
HIMC_PATCH	dep/himemcached-0.1.0/himemcached.h	9;"	d
HLL_BITS	src/vr_hyperloglog.c	166;"	d	file:
HLL_DENSE	src/vr_hyperloglog.c	170;"	d	file:
HLL_DENSE_GET_REGISTER	src/vr_hyperloglog.c	306;"	d	file:
HLL_DENSE_SET_REGISTER	src/vr_hyperloglog.c	318;"	d	file:
HLL_DENSE_SIZE	src/vr_hyperloglog.c	169;"	d	file:
HLL_HDR_SIZE	src/vr_hyperloglog.c	168;"	d	file:
HLL_INVALIDATE_CACHE	src/vr_hyperloglog.c	160;"	d	file:
HLL_MAX_ENCODING	src/vr_hyperloglog.c	173;"	d	file:
HLL_P	src/vr_hyperloglog.c	163;"	d	file:
HLL_P_MASK	src/vr_hyperloglog.c	165;"	d	file:
HLL_RAW	src/vr_hyperloglog.c	172;"	d	file:
HLL_REGISTERS	src/vr_hyperloglog.c	164;"	d	file:
HLL_REGISTER_MAX	src/vr_hyperloglog.c	167;"	d	file:
HLL_SPARSE	src/vr_hyperloglog.c	171;"	d	file:
HLL_SPARSE_IS_VAL	src/vr_hyperloglog.c	336;"	d	file:
HLL_SPARSE_IS_XZERO	src/vr_hyperloglog.c	335;"	d	file:
HLL_SPARSE_IS_ZERO	src/vr_hyperloglog.c	334;"	d	file:
HLL_SPARSE_VAL_BIT	src/vr_hyperloglog.c	333;"	d	file:
HLL_SPARSE_VAL_LEN	src/vr_hyperloglog.c	340;"	d	file:
HLL_SPARSE_VAL_MAX_LEN	src/vr_hyperloglog.c	342;"	d	file:
HLL_SPARSE_VAL_MAX_VALUE	src/vr_hyperloglog.c	341;"	d	file:
HLL_SPARSE_VAL_SET	src/vr_hyperloglog.c	345;"	d	file:
HLL_SPARSE_VAL_VALUE	src/vr_hyperloglog.c	339;"	d	file:
HLL_SPARSE_XZERO_BIT	src/vr_hyperloglog.c	332;"	d	file:
HLL_SPARSE_XZERO_LEN	src/vr_hyperloglog.c	338;"	d	file:
HLL_SPARSE_XZERO_MAX_LEN	src/vr_hyperloglog.c	344;"	d	file:
HLL_SPARSE_XZERO_SET	src/vr_hyperloglog.c	351;"	d	file:
HLL_SPARSE_ZERO_LEN	src/vr_hyperloglog.c	337;"	d	file:
HLL_SPARSE_ZERO_MAX_LEN	src/vr_hyperloglog.c	343;"	d	file:
HLL_SPARSE_ZERO_SET	src/vr_hyperloglog.c	348;"	d	file:
HLL_TEST_CYCLES	src/vr_hyperloglog.c	1354;"	d	file:
HLL_VALID_CACHE	src/vr_hyperloglog.c	161;"	d	file:
HLOG	src/vr_lzfP.h	19;"	d
HSIZE	src/vr_lzf_c.c	3;"	d	file:
I	dep/dhashkit/dmd5.c	33;"	d	file:
IDX	src/vr_lzf_c.c	15;"	d	file:
IDX	src/vr_lzf_c.c	17;"	d	file:
IDX	src/vr_lzf_c.c	19;"	d	file:
INIT_HTAB	src/vr_lzfP.h	55;"	d
INT24_MAX	src/vr_ziplist.c	132;"	d	file:
INT24_MIN	src/vr_ziplist.c	133;"	d	file:
INTSET_ENC_INT16	src/vr_intset.c	9;"	d	file:
INTSET_ENC_INT32	src/vr_intset.c	10;"	d	file:
INTSET_ENC_INT64	src/vr_intset.c	11;"	d	file:
JENKINS_INITVAL	dep/dhashkit/djenkins.c	28;"	d	file:
KETAMA_CONTINUUM_ADDITION	dep/dhashkit/dketama.c	7;"	d	file:
KETAMA_MAX_HOSTLEN	dep/dhashkit/dketama.c	9;"	d	file:
KETAMA_POINTS_PER_SERVER	dep/dhashkit/dketama.c	8;"	d	file:
KeyValueDictType	src/vr_conf.c	/^static dictType KeyValueDictType = {$/;"	v	file:
LF	dep/util/dutil.h	10;"	d
LF	tests/vrt_util.h	27;"	d
LIST_HEAD	src/vr_server.h	40;"	d
LIST_TAIL	src/vr_server.h	41;"	d
LOG_ALERT	dep/util/dlog.h	16;"	d
LOG_CRIT	dep/util/dlog.h	17;"	d
LOG_DEBUG	dep/util/dlog.h	22;"	d
LOG_EMERG	dep/util/dlog.h	15;"	d
LOG_ERR	dep/util/dlog.h	18;"	d
LOG_INFO	dep/util/dlog.h	21;"	d
LOG_MAX_LEN	dep/util/dlog.h	28;"	d
LOG_MAX_LEN	tests/vrt_util.h	32;"	d
LOG_NOTICE	dep/util/dlog.h	20;"	d
LOG_PVERB	dep/util/dlog.h	26;"	d
LOG_VERB	dep/util/dlog.h	23;"	d
LOG_VVERB	dep/util/dlog.h	24;"	d
LOG_VVVERB	dep/util/dlog.h	25;"	d
LOG_WARN	dep/util/dlog.h	19;"	d
LONG_STR_SIZE	src/vr_util.h	42;"	d
LRU_BITS	src/vr_object.h	34;"	d
LRU_CLOCK	src/vr_server.h	62;"	d
LRU_CLOCK_MAX	src/vr_object.h	35;"	d
LRU_CLOCK_RESOLUTION	src/vr_object.h	36;"	d
LZF_HSLOT	src/vr_lzfP.h	/^  typedef const u8 *LZF_HSLOT;$/;"	t
LZF_HSLOT	src/vr_lzfP.h	/^  typedef unsigned int LZF_HSLOT;$/;"	t
LZF_HSLOT_BIAS	src/vr_lzfP.h	123;"	d
LZF_HSLOT_BIAS	src/vr_lzfP.h	126;"	d
LZF_STATE	src/vr_lzfP.h	/^typedef LZF_HSLOT LZF_STATE[1 << (HLOG)];$/;"	t
LZF_STATE_ARG	src/vr_lzfP.h	73;"	d
LZF_USE_OFFSETS	src/vr_lzfP.h	109;"	d
LZF_VERSION	src/vr_lzf.h	13;"	d
MAX	dep/util/dutil.h	18;"	d
MAXMEMORY_EVICTION_POOL_SIZE	src/vr_db.h	11;"	d
MAX_EVENT_BATCHSZ	dep/ae/ae_evport.c	66;"	d	file:
MAX_LENGTH_POLICY_EVICT_END	dep/dlist/dmtqueue.h	6;"	d
MAX_LENGTH_POLICY_EVICT_HEAD	dep/dlist/dmtqueue.h	5;"	d
MAX_LENGTH_POLICY_REJECT	dep/dlist/dmtqueue.h	4;"	d
MAX_LIT	src/vr_lzf_c.c	38;"	d	file:
MAX_OFF	src/vr_lzf_c.c	39;"	d	file:
MAX_REF	src/vr_lzf_c.c	40;"	d	file:
MC_BLOCK	dep/himemcached-0.1.0/himemcached.h	13;"	d
MC_CONNECTED	dep/himemcached-0.1.0/himemcached.h	17;"	d
MC_CONNECT_RETRIES	dep/himemcached-0.1.0/himemcached.h	45;"	d
MC_CONN_TCP	dep/himemcached-0.1.0/himemcached.h	/^    MC_CONN_TCP,$/;"	e	enum:mcConnectionType
MC_CONN_UNIX	dep/himemcached-0.1.0/himemcached.h	/^    MC_CONN_UNIX,$/;"	e	enum:mcConnectionType
MC_DISCONNECTING	dep/himemcached-0.1.0/himemcached.h	23;"	d
MC_ERR	dep/himemcached-0.1.0/himcread.h	7;"	d
MC_ERR_EOF	dep/himemcached-0.1.0/himcread.h	15;"	d
MC_ERR_IO	dep/himemcached-0.1.0/himcread.h	14;"	d
MC_ERR_OOM	dep/himemcached-0.1.0/himcread.h	17;"	d
MC_ERR_OTHER	dep/himemcached-0.1.0/himcread.h	18;"	d
MC_ERR_PROTOCOL	dep/himemcached-0.1.0/himcread.h	16;"	d
MC_FREEING	dep/himemcached-0.1.0/himemcached.h	27;"	d
MC_IN_CALLBACK	dep/himemcached-0.1.0/himemcached.h	30;"	d
MC_KEEPALIVE_INTERVAL	dep/himemcached-0.1.0/himemcached.h	41;"	d
MC_MONITORING	dep/himemcached-0.1.0/himemcached.h	36;"	d
MC_OK	dep/himemcached-0.1.0/himcread.h	8;"	d
MC_READER_MAX_BUF	dep/himemcached-0.1.0/himcread.h	27;"	d
MC_REPLY_ARRAY	dep/himemcached-0.1.0/himcread.h	21;"	d
MC_REPLY_ERROR	dep/himemcached-0.1.0/himcread.h	25;"	d
MC_REPLY_INTEGER	dep/himemcached-0.1.0/himcread.h	22;"	d
MC_REPLY_NIL	dep/himemcached-0.1.0/himcread.h	23;"	d
MC_REPLY_STATUS	dep/himemcached-0.1.0/himcread.h	24;"	d
MC_REPLY_STRING	dep/himemcached-0.1.0/himcread.h	20;"	d
MC_REUSEADDR	dep/himemcached-0.1.0/himemcached.h	39;"	d
MC_SUBSCRIBED	dep/himemcached-0.1.0/himemcached.h	33;"	d
MD5_CTX	dep/dhashkit/dmd5.c	/^} MD5_CTX;$/;"	t	typeref:struct:__anon2	file:
MD5_Final	dep/dhashkit/dmd5.c	/^MD5_Final(unsigned char *result, MD5_CTX *ctx)$/;"	f
MD5_Init	dep/dhashkit/dmd5.c	/^MD5_Init(MD5_CTX *ctx)$/;"	f
MD5_Update	dep/dhashkit/dmd5.c	/^MD5_Update(MD5_CTX *ctx, void *data, unsigned long size)$/;"	f
MD5_u32plus	dep/dhashkit/dmd5.c	/^typedef unsigned int MD5_u32plus;$/;"	t	file:
MGET_MSET_KEYS_COUNT	tests/vrt_simple.c	825;"	d	file:
MIN	dep/util/dutil.h	17;"	d
MIN_COMPRESS_BYTES	src/vr_quicklist.c	21;"	d	file:
MIN_COMPRESS_IMPROVE	src/vr_quicklist.c	26;"	d	file:
MODULA_CONTINUUM_ADDITION	dep/dhashkit/dmodula.c	6;"	d	file:
MODULA_POINTS_PER_SERVER	dep/dhashkit/dmodula.c	7;"	d	file:
MurmurHash64A	src/vr_hyperloglog.c	/^uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {$/;"	f
NELEMS	dep/util/dutil.h	15;"	d
NET_MAX_WRITES_PER_EVENT	src/vr_client.h	4;"	d
NEXT	src/vr_lzf_c.c	13;"	d	file:
NOTIFY_ALL	src/vr_notify.h	16;"	d
NOTIFY_EVICTED	src/vr_notify.h	15;"	d
NOTIFY_EXPIRED	src/vr_notify.h	14;"	d
NOTIFY_GENERIC	src/vr_notify.h	8;"	d
NOTIFY_HASH	src/vr_notify.h	12;"	d
NOTIFY_KEYEVENT	src/vr_notify.h	7;"	d
NOTIFY_KEYSPACE	src/vr_notify.h	6;"	d
NOTIFY_LIST	src/vr_notify.h	10;"	d
NOTIFY_SET	src/vr_notify.h	11;"	d
NOTIFY_STRING	src/vr_notify.h	9;"	d
NOTIFY_ZSET	src/vr_notify.h	13;"	d
NOT_REACHED	dep/util/dutil.h	37;"	d
NOT_REACHED	dep/util/dutil.h	47;"	d
NOT_REACHED	dep/util/dutil.h	53;"	d
OBJ_ENCODING_EMBSTR	src/vr_object.h	25;"	d
OBJ_ENCODING_EMBSTR_SIZE_LIMIT	src/vr_object.c	59;"	d	file:
OBJ_ENCODING_HT	src/vr_object.h	19;"	d
OBJ_ENCODING_INT	src/vr_object.h	18;"	d
OBJ_ENCODING_INTSET	src/vr_object.h	23;"	d
OBJ_ENCODING_LINKEDLIST	src/vr_object.h	21;"	d
OBJ_ENCODING_QUICKLIST	src/vr_object.h	26;"	d
OBJ_ENCODING_RAW	src/vr_object.h	17;"	d
OBJ_ENCODING_SKIPLIST	src/vr_object.h	24;"	d
OBJ_ENCODING_ZIPLIST	src/vr_object.h	22;"	d
OBJ_ENCODING_ZIPMAP	src/vr_object.h	20;"	d
OBJ_HASH	src/vr_object.h	12;"	d
OBJ_HASH_KEY	src/vr_object.h	28;"	d
OBJ_HASH_MAX_ZIPLIST_ENTRIES	src/vr_server.h	26;"	d
OBJ_HASH_MAX_ZIPLIST_VALUE	src/vr_server.h	27;"	d
OBJ_HASH_VALUE	src/vr_object.h	29;"	d
OBJ_LIST	src/vr_object.h	9;"	d
OBJ_LIST_COMPRESS_DEPTH	src/vr_server.h	34;"	d
OBJ_LIST_MAX_ZIPLIST_SIZE	src/vr_server.h	33;"	d
OBJ_SET	src/vr_object.h	10;"	d
OBJ_SET_EX	src/vr_t_string.c	34;"	d	file:
OBJ_SET_MAX_INTSET_ENTRIES	src/vr_server.h	28;"	d
OBJ_SET_NO_FLAGS	src/vr_t_string.c	31;"	d	file:
OBJ_SET_NX	src/vr_t_string.c	32;"	d	file:
OBJ_SET_PX	src/vr_t_string.c	35;"	d	file:
OBJ_SET_XX	src/vr_t_string.c	33;"	d	file:
OBJ_SHARED_BULKHDR_LEN	src/vr_object.h	5;"	d
OBJ_SHARED_INTEGERS	src/vr_object.h	4;"	d
OBJ_STRING	src/vr_object.h	8;"	d
OBJ_ZSET	src/vr_object.h	11;"	d
OBJ_ZSET_MAX_ZIPLIST_ENTRIES	src/vr_server.h	29;"	d
OBJ_ZSET_MAX_ZIPLIST_VALUE	src/vr_server.h	30;"	d
OPVAL_DIRTY_LL	src/vr_t_zset.c	1581;"	d	file:
OPVAL_DIRTY_ROBJ	src/vr_t_zset.c	1580;"	d	file:
OPVAL_VALID_LL	src/vr_t_zset.c	1582;"	d	file:
OrganizationDictType	src/vr_conf.c	/^static dictType OrganizationDictType = {$/;"	v	file:
PARSE_AGAIN	dep/himemcached-0.1.0/himcread.c	15;"	d	file:
PARSE_ERROR	dep/himemcached-0.1.0/himcread.c	14;"	d	file:
PARSE_OK	dep/himemcached-0.1.0/himcread.c	13;"	d	file:
PREFIX_SIZE	dep/dmalloc/dmalloc.c	55;"	d	file:
PREFIX_SIZE	dep/dmalloc/dmalloc.c	58;"	d	file:
PREFIX_SIZE	dep/dmalloc/dmalloc.c	60;"	d	file:
PRODUCE_KEY_CACHE_POOL_COUNT	tests/vrt_produce_data.c	25;"	d	file:
PROPAGATE_AOF	src/vr_command.h	32;"	d
PROPAGATE_NONE	src/vr_command.h	31;"	d
PROPAGATE_REPL	src/vr_command.h	33;"	d
PROTO_INLINE_MAX_SIZE	src/vr_client.h	9;"	d
PROTO_IOBUF_LEN	src/vr_client.h	7;"	d
PROTO_MAX_QUERYBUF_LEN	src/vr_client.h	6;"	d
PROTO_MBULK_BIG_ARG	src/vr_client.h	10;"	d
PROTO_REPLY_CHUNK_BYTES	src/vr_client.h	8;"	d
PROTO_REQ_INLINE	src/vr_client.h	48;"	d
PROTO_REQ_MULTIBULK	src/vr_client.h	49;"	d
PROTO_SHARED_SELECT_CMDS	src/vr_server.h	8;"	d
PRO_ADD	tests/vrt_produce_data.h	48;"	d
PRO_ADMIN	tests/vrt_produce_data.h	38;"	d
PRO_ASKING	tests/vrt_produce_data.h	46;"	d
PRO_DENYOOM	tests/vrt_produce_data.h	36;"	d
PRO_FAST	tests/vrt_produce_data.h	47;"	d
PRO_LOADING	tests/vrt_produce_data.h	43;"	d
PRO_NOSCRIPT	tests/vrt_produce_data.h	40;"	d
PRO_NOT_USED_1	tests/vrt_produce_data.h	37;"	d
PRO_PUBSUB	tests/vrt_produce_data.h	39;"	d
PRO_RANDOM	tests/vrt_produce_data.h	41;"	d
PRO_READONLY	tests/vrt_produce_data.h	35;"	d
PRO_SKIP_MONITOR	tests/vrt_produce_data.h	45;"	d
PRO_SORT_FOR_SCRIPT	tests/vrt_produce_data.h	42;"	d
PRO_STALE	tests/vrt_produce_data.h	44;"	d
PRO_WRITE	tests/vrt_produce_data.h	34;"	d
QUICKLIST_HEAD	src/vr_quicklist.h	70;"	d
QUICKLIST_NOCOMPRESS	src/vr_quicklist.h	78;"	d
QUICKLIST_NODE_CONTAINER_NONE	src/vr_quicklist.h	81;"	d
QUICKLIST_NODE_CONTAINER_ZIPLIST	src/vr_quicklist.h	82;"	d
QUICKLIST_NODE_ENCODING_LZF	src/vr_quicklist.h	75;"	d
QUICKLIST_NODE_ENCODING_RAW	src/vr_quicklist.h	74;"	d
QUICKLIST_TAIL	src/vr_quicklist.h	71;"	d
R0	dep/dhashkit/dsha1.c	44;"	d	file:
R1	dep/dhashkit/dsha1.c	45;"	d	file:
R2	dep/dhashkit/dsha1.c	46;"	d	file:
R3	dep/dhashkit/dsha1.c	47;"	d	file:
R4	dep/dhashkit/dsha1.c	48;"	d	file:
RANDOM_CONTINUUM_ADDITION	dep/dhashkit/drandom.c	6;"	d	file:
RANDOM_POINTS_PER_SERVER	dep/dhashkit/drandom.c	7;"	d	file:
RANDPTR_INITIAL_SIZE	tests/vrt_benchmark.c	29;"	d	file:
RDB_14BITLEN	src/vr_rdb.h	18;"	d
RDB_32BITLEN	src/vr_rdb.h	19;"	d
RDB_6BITLEN	src/vr_rdb.h	17;"	d
RDB_ENCVAL	src/vr_rdb.h	20;"	d
RDB_ENC_INT16	src/vr_rdb.h	27;"	d
RDB_ENC_INT32	src/vr_rdb.h	28;"	d
RDB_ENC_INT8	src/vr_rdb.h	26;"	d
RDB_ENC_LZF	src/vr_rdb.h	29;"	d
RDB_LENERR	src/vr_rdb.h	21;"	d
REDIS_AGGR_MAX	src/vr_t_zset.c	1861;"	d	file:
REDIS_AGGR_MIN	src/vr_t_zset.c	1860;"	d	file:
REDIS_AGGR_SUM	src/vr_t_zset.c	1859;"	d	file:
REDIS_COMPARE_BINARY	src/vr_object.c	462;"	d	file:
REDIS_COMPARE_COLL	src/vr_object.c	463;"	d	file:
REDIS_CONFIG_REWRITE_SIGNATURE	src/vr_conf.c	1645;"	d	file:
REDIS_HASH	tests/vrt_public.h	34;"	d
REDIS_LIST	tests/vrt_public.h	31;"	d
REDIS_REPLY_CHUNK_BYTES	src/vr_client.h	45;"	d
REDIS_SET	tests/vrt_public.h	32;"	d
REDIS_STATIC	src/vr_quicklist.c	10;"	d	file:
REDIS_STRING	tests/vrt_public.h	30;"	d
REDIS_ZSET	tests/vrt_public.h	33;"	d
REPLICATION_ROLE_MASTER	src/vr_replication.h	39;"	d
REPLICATION_ROLE_SLAVE	src/vr_replication.h	40;"	d
REPL_STATE_CONNECT	src/vr_replication.h	7;"	d
REPL_STATE_CONNECTED	src/vr_replication.h	21;"	d
REPL_STATE_CONNECTING	src/vr_replication.h	8;"	d
REPL_STATE_NONE	src/vr_replication.h	6;"	d
REPL_STATE_RECEIVE_AUTH	src/vr_replication.h	12;"	d
REPL_STATE_RECEIVE_CAPA	src/vr_replication.h	16;"	d
REPL_STATE_RECEIVE_PONG	src/vr_replication.h	10;"	d
REPL_STATE_RECEIVE_PORT	src/vr_replication.h	14;"	d
REPL_STATE_RECEIVE_PSYNC	src/vr_replication.h	18;"	d
REPL_STATE_SEND_AUTH	src/vr_replication.h	11;"	d
REPL_STATE_SEND_CAPA	src/vr_replication.h	15;"	d
REPL_STATE_SEND_PORT	src/vr_replication.h	13;"	d
REPL_STATE_SEND_PSYNC	src/vr_replication.h	17;"	d
REPL_STATE_TRANSFER	src/vr_replication.h	20;"	d
REQ_TYPE_ARITHMETIC	dep/himemcached-0.1.0/himemcached.c	11;"	d	file:
REQ_TYPE_CAS	dep/himemcached-0.1.0/himemcached.c	9;"	d	file:
REQ_TYPE_DELETE	dep/himemcached-0.1.0/himemcached.c	12;"	d	file:
REQ_TYPE_RETRIEVAL	dep/himemcached-0.1.0/himemcached.c	10;"	d	file:
REQ_TYPE_STORAGE	dep/himemcached-0.1.0/himemcached.c	8;"	d	file:
REQ_TYPE_UNKNOWN	dep/himemcached-0.1.0/himemcached.c	7;"	d	file:
RESERVED_FDS	src/vr_core.h	34;"	d
RSP_TYPE_CLIENT_ERROR	dep/himemcached-0.1.0/himcread.c	27;"	d	file:
RSP_TYPE_DELETED	dep/himemcached-0.1.0/himcread.c	25;"	d	file:
RSP_TYPE_END	dep/himemcached-0.1.0/himcread.c	23;"	d	file:
RSP_TYPE_ERROR	dep/himemcached-0.1.0/himcread.c	26;"	d	file:
RSP_TYPE_EXISTS	dep/himemcached-0.1.0/himcread.c	21;"	d	file:
RSP_TYPE_NOT_FOUND	dep/himemcached-0.1.0/himcread.c	22;"	d	file:
RSP_TYPE_NOT_STORED	dep/himemcached-0.1.0/himcread.c	20;"	d	file:
RSP_TYPE_NUM	dep/himemcached-0.1.0/himcread.c	18;"	d	file:
RSP_TYPE_SERVER_ERROR	dep/himemcached-0.1.0/himcread.c	28;"	d	file:
RSP_TYPE_STORED	dep/himemcached-0.1.0/himcread.c	19;"	d	file:
RSP_TYPE_UNKNOWN	dep/himemcached-0.1.0/himcread.c	17;"	d	file:
RSP_TYPE_VALUE	dep/himemcached-0.1.0/himcread.c	24;"	d	file:
SCAN_TYPE_HASH	src/vr_server.h	18;"	d
SCAN_TYPE_KEY	src/vr_server.h	17;"	d
SCAN_TYPE_SET	src/vr_server.h	19;"	d
SCAN_TYPE_ZSET	src/vr_server.h	20;"	d
SDS_HDR	dep/sds/sds.h	83;"	d
SDS_HDR_VAR	dep/sds/sds.h	82;"	d
SDS_LLSTR_SIZE	dep/himemcached-0.1.0/himcdep/sds.c	298;"	d	file:
SDS_LLSTR_SIZE	dep/sds/sds.c	429;"	d	file:
SDS_MAX_PREALLOC	dep/himemcached-0.1.0/himcdep/sds.h	34;"	d
SDS_MAX_PREALLOC	dep/sds/sds.h	36;"	d
SDS_TYPE_16	dep/sds/sds.h	77;"	d
SDS_TYPE_32	dep/sds/sds.h	78;"	d
SDS_TYPE_5	dep/sds/sds.h	75;"	d
SDS_TYPE_5_LEN	dep/sds/sds.h	84;"	d
SDS_TYPE_64	dep/sds/sds.h	79;"	d
SDS_TYPE_8	dep/sds/sds.h	76;"	d
SDS_TYPE_BITS	dep/sds/sds.h	81;"	d
SDS_TYPE_MASK	dep/sds/sds.h	80;"	d
SET	dep/dhashkit/dmd5.c	52;"	d	file:
SET	dep/dhashkit/dmd5.c	57;"	d	file:
SET_ERRNO	src/vr_lzf_d.c	4;"	d	file:
SET_ERRNO	src/vr_lzf_d.c	7;"	d	file:
SET_OP_DIFF	src/vr_t_set.c	1065;"	d	file:
SET_OP_DIFF	src/vr_t_zset.c	1882;"	d	file:
SET_OP_INTER	src/vr_t_set.c	1066;"	d	file:
SET_OP_INTER	src/vr_t_zset.c	1883;"	d	file:
SET_OP_UNION	src/vr_t_set.c	1064;"	d	file:
SET_OP_UNION	src/vr_t_zset.c	1881;"	d	file:
SHA1Final	dep/dhashkit/dsha1.c	/^void SHA1Final(unsigned char digest[20], SHA1_CTX* context)$/;"	f
SHA1HANDSOFF	dep/dhashkit/dsha1.c	22;"	d	file:
SHA1Init	dep/dhashkit/dsha1.c	/^void SHA1Init(SHA1_CTX* context)$/;"	f
SHA1Transform	dep/dhashkit/dsha1.c	/^void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])$/;"	f
SHA1Update	dep/dhashkit/dsha1.c	/^void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)$/;"	f
SHA1_CTX	dep/dhashkit/dhashkit.h	/^} SHA1_CTX;$/;"	t	typeref:struct:__anon1
SHUTDOWN_NOFLAGS	src/vr_command.h	36;"	d
SHUTDOWN_NOSAVE	src/vr_command.h	39;"	d
SHUTDOWN_SAVE	src/vr_command.h	37;"	d
SIZE_SAFETY_LIMIT	src/vr_quicklist.c	18;"	d	file:
SLAVE_CAPA_EOF	src/vr_replication.h	34;"	d
SLAVE_CAPA_NONE	src/vr_replication.h	33;"	d
SLAVE_STATE_ONLINE	src/vr_replication.h	30;"	d
SLAVE_STATE_SEND_BULK	src/vr_replication.h	29;"	d
SLAVE_STATE_WAIT_BGSAVE_END	src/vr_replication.h	28;"	d
SLAVE_STATE_WAIT_BGSAVE_START	src/vr_replication.h	27;"	d
SLOWLOG_ENTRY_MAX_ARGC	src/vr_slowlog.h	4;"	d
SLOWLOG_ENTRY_MAX_STRING	src/vr_slowlog.h	5;"	d
SPOP_MOVE_STRATEGY_MUL	src/vr_t_set.c	439;"	d	file:
SQUARE	dep/util/dutil.h	20;"	d
SRANDMEMBER_SUB_STRATEGY_MUL	src/vr_t_set.c	666;"	d	file:
STANDALONE	src/vr_lzfP.h	4;"	d
STATS_ATOMIC_FIRST	src/vr_stats.h	5;"	d
STATS_LOCK_TYPE	src/vr_stats.h	55;"	d
STATS_LOCK_TYPE	src/vr_stats.h	65;"	d
STATS_LOCK_TYPE	src/vr_stats.h	91;"	d
STATS_METRIC_COMMAND	src/vr_stats.h	10;"	d
STATS_METRIC_COUNT	src/vr_stats.h	13;"	d
STATS_METRIC_NET_INPUT	src/vr_stats.h	11;"	d
STATS_METRIC_NET_OUTPUT	src/vr_stats.h	12;"	d
STATS_METRIC_SAMPLES	src/vr_stats.h	9;"	d
STDDEV	dep/util/dutil.h	22;"	d
STEP	dep/dhashkit/dmd5.c	38;"	d	file:
STRICT_ALIGN	src/vr_lzfP.h	139;"	d
STRICT_ALIGN	src/vr_lzfP.h	140;"	d
STRICT_ALIGN	src/vr_lzfP.h	46;"	d
SU_PER_ALLOC	src/vr_worker.c	11;"	d	file:
TEST_CMD_PROTOCOL_MEMCACHE	tests/vrt_benchmark.c	27;"	d	file:
TEST_CMD_PROTOCOL_REDIS	tests/vrt_benchmark.c	26;"	d	file:
TEST_CMD_TYPE_EXPIRE	tests/vrt_public.h	27;"	d
TEST_CMD_TYPE_HASH	tests/vrt_public.h	24;"	d
TEST_CMD_TYPE_KEY	tests/vrt_public.h	26;"	d
TEST_CMD_TYPE_LIST	tests/vrt_public.h	21;"	d
TEST_CMD_TYPE_SERVER	tests/vrt_public.h	25;"	d
TEST_CMD_TYPE_SET	tests/vrt_public.h	22;"	d
TEST_CMD_TYPE_STRING	tests/vrt_public.h	20;"	d
TEST_CMD_TYPE_ZSET	tests/vrt_public.h	23;"	d
TEST_HASH_ENCODED_CAUSED_BY_ALL	tests/vrt_simple.c	905;"	d	file:
TEST_HASH_ENCODED_CAUSED_BY_FILED	tests/vrt_simple.c	903;"	d	file:
TEST_HASH_ENCODED_CAUSED_BY_VALUE	tests/vrt_simple.c	904;"	d	file:
TEST_HASH_ENCODED_HT	tests/vrt_simple.c	902;"	d	file:
TEST_HASH_ENCODED_HT_FIELD_COUNT	tests/vrt_simple.c	907;"	d	file:
TEST_HASH_ENCODED_HT_VALUE_LEN	tests/vrt_simple.c	909;"	d	file:
TEST_HASH_ENCODED_ZIPLIST	tests/vrt_simple.c	901;"	d	file:
TEST_HASH_ENCODED_ZIPLIST_FIELD_COUNT	tests/vrt_simple.c	906;"	d	file:
TEST_HASH_ENCODED_ZIPLIST_VALUE_LEN	tests/vrt_simple.c	908;"	d	file:
TEST_STATE_LOCK_TYPE	tests/vrt_public.h	46;"	d
TEST_STATE_LOCK_TYPE	tests/vrt_public.h	56;"	d
TEST_STATE_LOCK_TYPE	tests/vrt_public.h	84;"	d
TTL_MISTAKE_CAN_BE_ACCEPT	tests/vrt_check_data.c	253;"	d	file:
ULTRA_FAST	src/vr_lzfP.h	39;"	d
UNIT_MILLISECONDS	src/vr_server.h	48;"	d
UNIT_SECONDS	src/vr_server.h	47;"	d
UNUSED	dep/sds/sds.c	1122;"	d	file:
UNUSED	dep/util/dutil.h	8;"	d
VAR	dep/util/dutil.h	21;"	d
VERY_FAST	src/vr_lzfP.h	145;"	d
VERY_FAST	src/vr_lzfP.h	28;"	d
VIRE_TEST_CONFIG_DEFAULT_EXECUTE_FILE	tests/vrt_public.c	27;"	d	file:
VRABTEST_GROUP_TYPE_REDIS	tests/vrabtest.c	38;"	d	file:
VRABTEST_GROUP_TYPE_VIRE	tests/vrabtest.c	39;"	d	file:
VRT_DEBUG_LOG	tests/vrt_util.h	9;"	d
VRT_ERROR	tests/vrt_util.h	17;"	d
VRT_MAXHOSTNAMELEN	tests/vrt_util.h	25;"	d
VRT_OK	tests/vrt_util.h	16;"	d
VRT_TEST_ERR	tests/vrt_public.h	18;"	d
VRT_TEST_OK	tests/vrt_public.h	17;"	d
VRT_UINT16_MAXLEN	tests/vrt_util.h	20;"	d
VRT_UINT32_MAXLEN	tests/vrt_util.h	21;"	d
VRT_UINT64_MAXLEN	tests/vrt_util.h	22;"	d
VRT_UINT8_MAXLEN	tests/vrt_util.h	19;"	d
VRT_UINTMAX_MAXLEN	tests/vrt_util.h	23;"	d
VR_ADDR	src/vr.c	22;"	d	file:
VR_ALIGN	src/vr_util.h	49;"	d
VR_ALIGNMENT	src/vr_util.h	48;"	d
VR_ALIGN_PTR	src/vr_util.h	50;"	d
VR_CONF_PATH	src/vr.c	14;"	d	file:
VR_EAGAIN	src/vr_core.h	30;"	d
VR_ENOMEM	src/vr_core.h	31;"	d
VR_ERROR	src/vr_core.h	29;"	d
VR_HAVE_BACKTRACE	src/vr_core.h	21;"	d
VR_INET4_ADDRSTRLEN	src/vr_util.h	15;"	d
VR_INET6_ADDRSTRLEN	src/vr_util.h	16;"	d
VR_INET_ADDRSTRLEN	src/vr_util.h	18;"	d
VR_INET_PEER_ID_LEN	src/vr_util.h	22;"	d
VR_INTERVAL	src/vr.c	23;"	d	file:
VR_LITTLE_ENDIAN	src/vr_core.h	17;"	d
VR_LOG_DEFAULT	src/vr.c	16;"	d	file:
VR_LOG_MAX	src/vr.c	18;"	d	file:
VR_LOG_MIN	src/vr.c	17;"	d	file:
VR_LOG_PATH	src/vr.c	19;"	d	file:
VR_MAXHOSTNAMELEN	src/vr_util.h	24;"	d
VR_OK	src/vr_core.h	28;"	d
VR_PID_FILE	src/vr.c	25;"	d	file:
VR_PORT	src/vr.c	21;"	d	file:
VR_STATS	src/vr_core.h	11;"	d
VR_STATS	src/vr_core.h	13;"	d
VR_THREAD_NUM_DEFAULT	src/vr.c	27;"	d	file:
VR_UINT16_MAXLEN	src/vr_util.h	37;"	d
VR_UINT32_MAXLEN	src/vr_util.h	38;"	d
VR_UINT64_MAXLEN	src/vr_util.h	39;"	d
VR_UINT8_MAXLEN	src/vr_util.h	36;"	d
VR_UINTMAX_MAXLEN	src/vr_util.h	40;"	d
VR_UNIX_ADDRSTRLEN	src/vr_util.h	19;"	d
VR_USE_SPINLOCK	src/vr_core.h	25;"	d
ZADD_CH	src/vr_t_zset.c	1168;"	d	file:
ZADD_INCR	src/vr_t_zset.c	1165;"	d	file:
ZADD_NONE	src/vr_t_zset.c	1164;"	d	file:
ZADD_NX	src/vr_t_zset.c	1166;"	d	file:
ZADD_XX	src/vr_t_zset.c	1167;"	d	file:
ZIPLIST_BYTES	src/vr_ziplist.c	139;"	d	file:
ZIPLIST_END_SIZE	src/vr_ziplist.c	143;"	d	file:
ZIPLIST_ENTRY_END	src/vr_ziplist.c	146;"	d	file:
ZIPLIST_ENTRY_HEAD	src/vr_ziplist.c	144;"	d	file:
ZIPLIST_ENTRY_TAIL	src/vr_ziplist.c	145;"	d	file:
ZIPLIST_ENTRY_ZERO	src/vr_ziplist.c	163;"	d	file:
ZIPLIST_HEAD	src/vr_ziplist.h	4;"	d
ZIPLIST_HEADER_SIZE	src/vr_ziplist.c	142;"	d	file:
ZIPLIST_INCR_LENGTH	src/vr_ziplist.c	150;"	d	file:
ZIPLIST_LENGTH	src/vr_ziplist.c	141;"	d	file:
ZIPLIST_TAIL	src/vr_ziplist.h	5;"	d
ZIPLIST_TAIL_OFFSET	src/vr_ziplist.c	140;"	d	file:
ZIPMAP_BIGLEN	src/vr_zipmap.c	83;"	d	file:
ZIPMAP_END	src/vr_zipmap.c	84;"	d	file:
ZIPMAP_LEN_BYTES	src/vr_zipmap.c	93;"	d	file:
ZIPMAP_VALUE_MAX_FREE	src/vr_zipmap.c	88;"	d	file:
ZIP_BIGLEN	src/vr_ziplist.c	113;"	d	file:
ZIP_DECODE_LENGTH	src/vr_ziplist.c	233;"	d	file:
ZIP_DECODE_PREVLEN	src/vr_ziplist.c	296;"	d	file:
ZIP_DECODE_PREVLENSIZE	src/vr_ziplist.c	286;"	d	file:
ZIP_END	src/vr_ziplist.c	112;"	d	file:
ZIP_ENTRY_ENCODING	src/vr_ziplist.c	172;"	d	file:
ZIP_INT_16B	src/vr_ziplist.c	121;"	d	file:
ZIP_INT_24B	src/vr_ziplist.c	124;"	d	file:
ZIP_INT_32B	src/vr_ziplist.c	122;"	d	file:
ZIP_INT_64B	src/vr_ziplist.c	123;"	d	file:
ZIP_INT_8B	src/vr_ziplist.c	125;"	d	file:
ZIP_INT_IMM_MASK	src/vr_ziplist.c	127;"	d	file:
ZIP_INT_IMM_MAX	src/vr_ziplist.c	129;"	d	file:
ZIP_INT_IMM_MIN	src/vr_ziplist.c	128;"	d	file:
ZIP_INT_IMM_VAL	src/vr_ziplist.c	130;"	d	file:
ZIP_INT_MASK	src/vr_ziplist.c	117;"	d	file:
ZIP_IS_STR	src/vr_ziplist.c	136;"	d	file:
ZIP_STR_06B	src/vr_ziplist.c	118;"	d	file:
ZIP_STR_14B	src/vr_ziplist.c	119;"	d	file:
ZIP_STR_32B	src/vr_ziplist.c	120;"	d	file:
ZIP_STR_MASK	src/vr_ziplist.c	116;"	d	file:
ZRANGE_LEX	src/vr_t_zset.c	1456;"	d	file:
ZRANGE_RANK	src/vr_t_zset.c	1454;"	d	file:
ZRANGE_SCORE	src/vr_t_zset.c	1455;"	d	file:
ZSET_RANGE_MIN_MAX_TYPE_LEX	tests/vrt_produce_data.c	145;"	d	file:
ZSET_RANGE_MIN_MAX_TYPE_RANK	tests/vrt_produce_data.c	143;"	d	file:
ZSET_RANGE_MIN_MAX_TYPE_SCORE	tests/vrt_produce_data.c	144;"	d	file:
ZSKIPLIST_MAXLEVEL	src/vr_server.h	43;"	d
ZSKIPLIST_P	src/vr_server.h	44;"	d
_DARRAY_H_	dep/darray/darray.h	2;"	d
_DHASHKIT_H_	dep/dhashkit/dhashkit.h	2;"	d
_DLIST_H__	dep/dlist/dlist.h	2;"	d
_DLOCKQUEUE_H_	dep/dlist/dlockqueue.h	2;"	d
_DLOG_H_	dep/util/dlog.h	2;"	d
_DMALLOC_H_	dep/dmalloc/dmalloc.h	2;"	d
_DMTQUEUE_H_	dep/dlist/dmtqueue.h	2;"	d
_DSPECIALCONFIG_H_	dep/util/dspecialconfig.h	2;"	d
_DUTIL_H_	dep/util/dutil.h	2;"	d
_HIMC_READ_H_	dep/himemcached-0.1.0/himcread.h	2;"	d
_HIMEMCACHED_H_	dep/himemcached-0.1.0/himemcached.h	2;"	d
_VRABTEST_H_	tests/vrabtest.h	2;"	d
_VRT_BACKEND_H_	tests/vrt_backend.h	2;"	d
_VRT_CHECK_DATA_H_	tests/vrt_check_data.h	2;"	d
_VRT_DISPATCH_DATA_H_	tests/vrt_dispatch_data.h	2;"	d
_VRT_PRODUCE_DATA_H_	tests/vrt_produce_data.h	2;"	d
_VRT_PUBLIC_H_	tests/vrt_public.h	2;"	d
_VRT_SIMPLE_H_	tests/vrt_simple.h	2;"	d
_VRT_UTIL_H_	tests/vrt_util.h	2;"	d
_VR_AOF_H_	src/vr_aof.h	2;"	d
_VR_BACKEND_H_	src/vr_backend.h	2;"	d
_VR_BITOPS_H_	src/vr_bitops.h	2;"	d
_VR_BLOCK_H_	src/vr_block.h	2;"	d
_VR_CLIENT_H_	src/vr_client.h	2;"	d
_VR_COMMAND_H_	src/vr_command.h	2;"	d
_VR_CONF_H_	src/vr_conf.h	2;"	d
_VR_CONNECTION_H_	src/vr_connection.h	2;"	d
_VR_CORE_H_	src/vr_core.h	2;"	d
_VR_DB_H_	src/vr_db.h	2;"	d
_VR_DICT_H_	src/vr_dict.h	2;"	d
_VR_EVENTLOOP_H_	src/vr_eventloop.h	2;"	d
_VR_HYPERLOGLOG_H_	src/vr_hyperloglog.h	2;"	d
_VR_INTSET_H_	src/vr_intset.h	2;"	d
_VR_LISTEN_H_	src/vr_listen.h	2;"	d
_VR_LZFP_H_	src/vr_lzfP.h	2;"	d
_VR_LZF_H_	src/vr_lzf.h	2;"	d
_VR_MASTER_H_	src/vr_master.h	2;"	d
_VR_MULTI_H_	src/vr_multi.h	2;"	d
_VR_NOTIFY_H_	src/vr_notify.h	2;"	d
_VR_OBJECT_H_	src/vr_object.h	2;"	d
_VR_PUBSUB_H_	src/vr_pubsub.h	2;"	d
_VR_QUICKLIST_H_	src/vr_quicklist.h	2;"	d
_VR_RBTREE_	src/vr_rbtree.h	2;"	d
_VR_RDB_H_	src/vr_rdb.h	2;"	d
_VR_REPLICATION_H_	src/vr_replication.h	2;"	d
_VR_SCRIPTING_H_	src/vr_scripting.h	2;"	d
_VR_SERVER_H_	src/vr_server.h	2;"	d
_VR_SIGNAL_H_	src/vr_signal.h	2;"	d
_VR_SLOWLOG_H_	src/vr_slowlog.h	2;"	d
_VR_STATS_H_	src/vr_stats.h	2;"	d
_VR_THREAD_H_	src/vr_thread.h	2;"	d
_VR_T_HASH_H_	src/vr_t_hash.h	2;"	d
_VR_T_LIST_H_	src/vr_t_list.h	2;"	d
_VR_T_SET_H_	src/vr_t_set.h	2;"	d
_VR_T_STRING_H_	src/vr_t_string.h	2;"	d
_VR_T_ZSET_H_	src/vr_t_zset.h	2;"	d
_VR_UTIL_H_	src/vr_util.h	2;"	d
_VR_WORKER_H_	src/vr_worker.h	2;"	d
_ZIPLIST_H	src/vr_ziplist.h	2;"	d
_ZIPMAP_H	src/vr_zipmap.h	2;"	d
__AE_H__	dep/ae/ae.h	34;"	d
__SDS_H	dep/himemcached-0.1.0/himcdep/sds.h	32;"	d
__SDS_H	dep/sds/sds.h	34;"	d
__memcachedReaderSetError	dep/himemcached-0.1.0/himcread.c	/^static void __memcachedReaderSetError(mcReader *r, int type, const char *str) {$/;"	f	file:
__memcachedReaderSetErrorOOM	dep/himemcached-0.1.0/himcread.c	/^static void __memcachedReaderSetErrorOOM(mcReader *r) {$/;"	f	file:
__memcachedReaderSetErrorProtocolByte	dep/himemcached-0.1.0/himcread.c	/^static void __memcachedReaderSetErrorProtocolByte(mcReader *r, char byte) {$/;"	f	file:
__memcachedSetError	dep/himemcached-0.1.0/himemcached.c	/^void __memcachedSetError(mcContext *c, int type, const char *str) {$/;"	f
__quicklistCompress	src/vr_quicklist.c	/^REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,$/;"	f
__quicklistCompressNode	src/vr_quicklist.c	/^REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {$/;"	f
__quicklistDecompressNode	src/vr_quicklist.c	/^REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {$/;"	f
__quicklistDelNode	src/vr_quicklist.c	/^REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,$/;"	f
__quicklistInsertNode	src/vr_quicklist.c	/^REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,$/;"	f
__str	src/vr_util.h	13;"	d
__xstr	src/vr_util.h	12;"	d
__ziplistCascadeUpdate	src/vr_ziplist.c	/^static unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {$/;"	f	file:
__ziplistDelete	src/vr_ziplist.c	/^static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {$/;"	f	file:
__ziplistInsert	src/vr_ziplist.c	/^static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f	file:
_addReplyObjectToList	src/vr_client.c	/^void _addReplyObjectToList(client *c, robj *o) {$/;"	f
_addReplySdsToList	src/vr_client.c	/^void _addReplySdsToList(client *c, sds s) {$/;"	f
_addReplyStringToList	src/vr_client.c	/^void _addReplyStringToList(client *c, const char *s, size_t len) {$/;"	f
_addReplyToBuffer	src/vr_client.c	/^int _addReplyToBuffer(client *c, const char *s, size_t len) {$/;"	f
_benchmark_client	tests/vrt_benchmark.c	/^typedef struct _benchmark_client {$/;"	s	file:
_buf	src/vr_t_zset.h	/^    unsigned char _buf[32]; \/* Private buffer. *\/$/;"	m	struct:__anon14
_conn_get	src/vr_connection.c	/^_conn_get(conn_base *cb)$/;"	f	file:
_dalloc	dep/dmalloc/dmalloc.c	/^_dalloc(size_t size, const char *name, int line)$/;"	f
_dcalloc	dep/dmalloc/dmalloc.c	/^_dcalloc(size_t nmemb, size_t size, const char *name, int line)$/;"	f
_dfree	dep/dmalloc/dmalloc.c	/^_dfree(void *ptr, const char *name, int line)$/;"	f
_dictClear	src/vr_dict.c	/^int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {$/;"	f
_dictExpandIfNeeded	src/vr_dict.c	/^static int _dictExpandIfNeeded(dict *d)$/;"	f	file:
_dictGetStatsHt	src/vr_dict.c	/^size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {$/;"	f
_dictInit	src/vr_dict.c	/^int _dictInit(dict *d, dictType *type,$/;"	f
_dictKeyIndex	src/vr_dict.c	/^static int _dictKeyIndex(dict *d, const void *key)$/;"	f	file:
_dictNextPower	src/vr_dict.c	/^static unsigned long _dictNextPower(unsigned long size)$/;"	f	file:
_dictRehashStep	src/vr_dict.c	/^static void _dictRehashStep(dict *d) {$/;"	f	file:
_dictReset	src/vr_dict.c	/^static void _dictReset(dictht *ht)$/;"	f	file:
_drealloc	dep/dmalloc/dmalloc.c	/^_drealloc(void *ptr, size_t size, const char *name, int line)$/;"	f
_dscnprintf	dep/util/dutil.c	/^_dscnprintf(char *buf, size_t size, const char *fmt, ...)$/;"	f
_dvscnprintf	dep/util/dutil.c	/^_dvscnprintf(char *buf, size_t size, const char *fmt, va_list args)$/;"	f
_dzalloc	dep/dmalloc/dmalloc.c	/^_dzalloc(size_t size, const char *name, int line)$/;"	f
_intsetGet	src/vr_intset.c	/^static int64_t _intsetGet(intset *is, int pos) {$/;"	f	file:
_intsetGetEncoded	src/vr_intset.c	/^static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {$/;"	f	file:
_intsetSet	src/vr_intset.c	/^static void _intsetSet(intset *is, int pos, int64_t value) {$/;"	f	file:
_intsetValueEncoding	src/vr_intset.c	/^static uint8_t _intsetValueEncoding(int64_t v) {$/;"	f	file:
_iterset	src/vr_t_zset.h	/^        union _iterset {$/;"	u	union:__anon8::__anon9
_iterzset	src/vr_t_zset.h	/^        union _iterzset {$/;"	u	union:__anon8::__anon9
_log	dep/util/dlog.c	/^_log(const char *file, int line, int level, int panic, const char *fmt, ...)$/;"	f
_log_hexdump	dep/util/dlog.c	/^_log_hexdump(const char *file, int line, char *data, int datalen,$/;"	f
_log_safe	dep/util/dlog.c	/^_log_safe(const char *fmt, ...)$/;"	f
_log_stderr	dep/util/dlog.c	/^_log_stderr(const char *fmt, ...)$/;"	f
_log_stderr_safe	dep/util/dlog.c	/^_log_stderr_safe(const char *fmt, ...)$/;"	f
_log_stdout	dep/util/dlog.c	/^_log_stdout(const char *fmt, ...)$/;"	f
_quicklistInsert	src/vr_quicklist.c	/^REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,$/;"	f
_quicklistInsertNodeAfter	src/vr_quicklist.c	/^REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,$/;"	f
_quicklistInsertNodeBefore	src/vr_quicklist.c	/^REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,$/;"	f
_quicklistMergeNodes	src/vr_quicklist.c	/^REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,$/;"	f
_quicklistNodeAllowInsert	src/vr_quicklist.c	/^REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,$/;"	f
_quicklistNodeAllowMerge	src/vr_quicklist.c	/^REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,$/;"	f
_quicklistNodeSizeMeetsOptimizationRequirement	src/vr_quicklist.c	/^_quicklistNodeSizeMeetsOptimizationRequirement(const size_t sz,$/;"	f
_quicklistSaver	src/vr_quicklist.c	/^REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) {$/;"	f
_quicklistSplitNode	src/vr_quicklist.c	/^REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,$/;"	f
_quicklistZiplistMerge	src/vr_quicklist.c	/^REDIS_STATIC quicklistNode *_quicklistZiplistMerge(quicklist *quicklist,$/;"	f
_rfds	dep/ae/ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_safe_check_longlong	dep/util/dutil.c	/^_safe_check_longlong(const char *fmt, int *have_longlong)$/;"	f	file:
_safe_itoa	dep/util/dutil.c	/^_safe_itoa(int base, int64_t val, char *buf)$/;"	f	file:
_safe_snprintf	dep/util/dutil.c	/^_safe_snprintf(char *to, size_t n, const char *fmt, ...)$/;"	f
_safe_utoa	dep/util/dutil.c	/^_safe_utoa(int _base, uint64_t val, char *buf)$/;"	f	file:
_safe_vsnprintf	dep/util/dutil.c	/^_safe_vsnprintf(char *to, size_t size, const char *format, va_list ap)$/;"	f
_test_log_error	tests/vrt_util.c	/^_test_log_error(const char *file, int line, const char *fmt, ...)$/;"	f
_test_log_out	tests/vrt_util.c	/^_test_log_out(const char *fmt, ...)$/;"	f
_vr_atoi	src/vr_util.c	/^_vr_atoi(char *line, size_t n)$/;"	f
_vr_recvn	src/vr_util.c	/^_vr_recvn(int sd, void *vptr, size_t n)$/;"	f
_vr_sendn	src/vr_util.c	/^_vr_sendn(int sd, const void *vptr, size_t n)$/;"	f
_vr_strchr	src/vr_util.h	/^_vr_strchr(uint8_t *p, uint8_t *last, uint8_t c)$/;"	f
_vr_strrchr	src/vr_util.h	/^_vr_strrchr(uint8_t *p, uint8_t *start, uint8_t c)$/;"	f
_wfds	dep/ae/ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
a	dep/dhashkit/dmd5.c	/^    MD5_u32plus a, b, c, d;$/;"	m	struct:__anon2	file:
abgs	tests/vrt_backend.h	/^    darray *abgs; \/* type is abtest_group *\/$/;"	m	struct:backend_thread
abgs	tests/vrt_check_data.c	/^    darray *abgs;   \/* Type is abtest_group *\/$/;"	m	struct:check_data_thread	file:
abgs	tests/vrt_dispatch_data.h	/^    darray *abgs; \/* type is abtest_group *\/$/;"	m	struct:dispatch_data_thread
abtest_group	tests/vrabtest.h	/^typedef struct abtest_group {$/;"	s
abtest_group	tests/vrabtest.h	/^} abtest_group;$/;"	t	typeref:struct:abtest_group
abtest_group_deinit	tests/vrabtest.c	/^static void abtest_group_deinit(abtest_group *abg)$/;"	f	file:
abtest_group_init	tests/vrabtest.c	/^static int abtest_group_init(abtest_group *abg, char *group_string)$/;"	f	file:
abtest_groups_create	tests/vrabtest.c	/^darray *abtest_groups_create(char *groups_string)$/;"	f
abtest_groups_destroy	tests/vrabtest.c	/^void abtest_groups_destroy(darray *abgs)$/;"	f
abtest_server	tests/vrabtest.h	/^typedef struct abtest_server {$/;"	s
abtest_server	tests/vrabtest.h	/^} abtest_server;$/;"	t	typeref:struct:abtest_server
abtest_server_deinit	tests/vrabtest.c	/^static void abtest_server_deinit(abtest_server *abs)$/;"	f	file:
abtest_server_init	tests/vrabtest.c	/^static int abtest_server_init(abtest_server *abs, char *address)$/;"	f	file:
abtest_servers	tests/vrabtest.h	/^    darray abtest_servers;    \/* type: abtest_server *\/$/;"	m	struct:abtest_group
activeExpireCycle	src/vr_db.c	/^void activeExpireCycle(vr_backend *backend, int type) {$/;"	f
activeExpireCycleTryExpire	src/vr_db.c	/^int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {$/;"	f
activerehashing	src/vr_server.h	/^    int activerehashing;        \/* Incremental rehash in serverCron() *\/$/;"	m	struct:vr_server
actx	tests/vrabtest.h	/^    struct redisAsyncContext *actx;    $/;"	m	struct:conn_context	typeref:struct:conn_context::redisAsyncContext
addDeferredMultiBulkLength	src/vr_client.c	/^void *addDeferredMultiBulkLength(client *c) {$/;"	f
addHashFieldToReply	src/vr_t_hash.c	/^static void addHashFieldToReply(client *c, robj *o, robj *field) {$/;"	f	file:
addHashIteratorCursorToReply	src/vr_t_hash.c	/^static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {$/;"	f	file:
addReply	src/vr_client.c	/^void addReply(client *c, robj *obj) {$/;"	f
addReplyBulk	src/vr_client.c	/^void addReplyBulk(client *c, robj *obj) {$/;"	f
addReplyBulkCBuffer	src/vr_client.c	/^void addReplyBulkCBuffer(client *c, const void *p, size_t len) {$/;"	f
addReplyBulkCString	src/vr_client.c	/^void addReplyBulkCString(client *c, const char *s) {$/;"	f
addReplyBulkLen	src/vr_client.c	/^void addReplyBulkLen(client *c, robj *obj) {$/;"	f
addReplyBulkLongLong	src/vr_client.c	/^void addReplyBulkLongLong(client *c, long long ll) {$/;"	f
addReplyBulkSds	src/vr_client.c	/^void addReplyBulkSds(client *c, sds s)  {$/;"	f
addReplyCommand	src/vr_command.c	/^static void addReplyCommand(client *c, struct redisCommand *cmd) {$/;"	f	file:
addReplyCommandFlag	src/vr_command.c	/^static int addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {$/;"	f	file:
addReplyConfOption	src/vr_conf.c	/^static void addReplyConfOption(client *c,conf_option *cop)$/;"	f	file:
addReplyDouble	src/vr_client.c	/^void addReplyDouble(client *c, double d) {$/;"	f
addReplyError	src/vr_client.c	/^void addReplyError(client *c, const char *err) {$/;"	f
addReplyErrorFormat	src/vr_client.c	/^void addReplyErrorFormat(client *c, const char *fmt, ...) {$/;"	f
addReplyErrorLength	src/vr_client.c	/^void addReplyErrorLength(client *c, const char *s, size_t len) {$/;"	f
addReplyHumanLongDouble	src/vr_client.c	/^void addReplyHumanLongDouble(client *c, long double d) {$/;"	f
addReplyLongLong	src/vr_client.c	/^void addReplyLongLong(client *c, long long ll) {$/;"	f
addReplyLongLongWithPrefix	src/vr_client.c	/^void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {$/;"	f
addReplyMultiBulkLen	src/vr_client.c	/^void addReplyMultiBulkLen(client *c, long length) {$/;"	f
addReplySds	src/vr_client.c	/^void addReplySds(client *c, sds s) {$/;"	f
addReplyStatus	src/vr_client.c	/^void addReplyStatus(client *c, const char *status) {$/;"	f
addReplyStatusFormat	src/vr_client.c	/^void addReplyStatusFormat(client *c, const char *fmt, ...) {$/;"	f
addReplyStatusLength	src/vr_client.c	/^void addReplyStatusLength(client *c, const char *s, size_t len) {$/;"	f
addReplyString	src/vr_client.c	/^void addReplyString(client *c, const char *s, size_t len) {$/;"	f
add_to_needed_cmd_type_producer	tests/vrt_produce_data.c	/^static int add_to_needed_cmd_type_producer(data_producer *dp)$/;"	f	file:
addr	src/vr_client.c	/^    sds addr;$/;"	m	struct:clientkilldata	file:
addr	src/vr_util.h	/^    } addr;$/;"	m	struct:sockinfo	typeref:union:sockinfo::__anon5
addrlen	src/vr_util.h	/^    socklen_t addrlen;             \/* socket address length *\/$/;"	m	struct:sockinfo
adjustOpenFilesLimit	src/vr_server.c	/^int adjustOpenFilesLimit(int maxclients) {$/;"	f
adminCommand	src/vr_server.c	/^void adminCommand(client *c) {$/;"	f
adminpass	src/vr_conf.h	/^    sds           adminpass;            \/* Pass for ADMIN command, or NULL *\/$/;"	m	struct:conf_server
adminpass	src/vr_conf.h	/^    sds adminpass;$/;"	m	struct:conf_cache
aeAddMillisecondsToNow	dep/ae/ae.c	/^static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {$/;"	f	file:
aeApiAddEvent	dep/ae/ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	dep/ae/ae_evport.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	dep/ae/ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	dep/ae/ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAssociate	dep/ae/ae_evport.c	/^static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {$/;"	f	file:
aeApiCreate	dep/ae/ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	dep/ae/ae_evport.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	dep/ae/ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	dep/ae/ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiDelEvent	dep/ae/ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	file:
aeApiDelEvent	dep/ae/ae_evport.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	dep/ae/ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	dep/ae/ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiFree	dep/ae/ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	dep/ae/ae_evport.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	dep/ae/ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	dep/ae/ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiLookupPending	dep/ae/ae_evport.c	/^static int aeApiLookupPending(aeApiState *state, int fd) {$/;"	f	file:
aeApiName	dep/ae/ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	dep/ae/ae_evport.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	dep/ae/ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	dep/ae/ae_select.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiPoll	dep/ae/ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	dep/ae/ae_evport.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	dep/ae/ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	dep/ae/ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiResize	dep/ae/ae_epoll.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	dep/ae/ae_evport.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	dep/ae/ae_kqueue.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiResize	dep/ae/ae_select.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:
aeApiState	dep/ae/ae_epoll.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	dep/ae/ae_epoll.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	dep/ae/ae_evport.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	dep/ae/ae_evport.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	dep/ae/ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	dep/ae/ae_kqueue.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	dep/ae/ae_select.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	dep/ae/ae_select.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeBeforeSleepProc	dep/ae/ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop, void *private_data);$/;"	t
aeCreateEventLoop	dep/ae/ae.c	/^aeEventLoop *aeCreateEventLoop(int setsize) {$/;"	f
aeCreateFileEvent	dep/ae/ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f
aeCreateTimeEvent	dep/ae/ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f
aeDeleteEventLoop	dep/ae/ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f
aeDeleteFileEvent	dep/ae/ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f
aeDeleteTimeEvent	dep/ae/ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f
aeEventFinalizerProc	dep/ae/ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t
aeEventLoop	dep/ae/ae.h	/^typedef struct aeEventLoop {$/;"	s
aeEventLoop	dep/ae/ae.h	/^} aeEventLoop;$/;"	t	typeref:struct:aeEventLoop
aeFileEvent	dep/ae/ae.h	/^typedef struct aeFileEvent {$/;"	s
aeFileEvent	dep/ae/ae.h	/^} aeFileEvent;$/;"	t	typeref:struct:aeFileEvent
aeFileProc	dep/ae/ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t
aeFiredEvent	dep/ae/ae.h	/^typedef struct aeFiredEvent {$/;"	s
aeFiredEvent	dep/ae/ae.h	/^} aeFiredEvent;$/;"	t	typeref:struct:aeFiredEvent
aeGetApiName	dep/ae/ae.c	/^char *aeGetApiName(void) {$/;"	f
aeGetFileEvents	dep/ae/ae.c	/^int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {$/;"	f
aeGetSetSize	dep/ae/ae.c	/^int aeGetSetSize(aeEventLoop *eventLoop) {$/;"	f
aeGetTime	dep/ae/ae.c	/^static void aeGetTime(long *seconds, long *milliseconds)$/;"	f	file:
aeMain	dep/ae/ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f
aeProcessEvents	dep/ae/ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f
aeResizeSetSize	dep/ae/ae.c	/^int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {$/;"	f
aeSearchNearestTimer	dep/ae/ae.c	/^static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)$/;"	f	file:
aeSetBeforeSleepProc	dep/ae/ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep, void *private_data) {$/;"	f
aeStop	dep/ae/ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f
aeTimeEvent	dep/ae/ae.h	/^typedef struct aeTimeEvent {$/;"	s
aeTimeEvent	dep/ae/ae.h	/^} aeTimeEvent;$/;"	t	typeref:struct:aeTimeEvent
aeTimeProc	dep/ae/ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t
aeWait	dep/ae/ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f
all_backend_threads_paused	tests/vrt_check_data.c	/^int all_backend_threads_paused(void)$/;"	f
all_check_data_threads_finished	tests/vrt_check_data.c	/^static int all_check_data_threads_finished(void)$/;"	f	file:
all_dispatch_threads_paused	tests/vrt_check_data.c	/^int all_dispatch_threads_paused(void)$/;"	f
all_produce_threads_paused	tests/vrt_check_data.c	/^int all_produce_threads_paused(void)$/;"	f
all_threads_paused	tests/vrt_check_data.c	/^int all_threads_paused(void)$/;"	f
alloc	dep/sds/sds.h	/^    uint16_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr16
alloc	dep/sds/sds.h	/^    uint32_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr32
alloc	dep/sds/sds.h	/^    uint64_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr64
alloc	dep/sds/sds.h	/^    uint8_t alloc; \/* excluding the header and null terminator *\/$/;"	m	struct:sdshdr8
alloc_len	dep/himemcached-0.1.0/himcread.h	/^    size_t alloc_len; \/* Temporary reply array alloc length *\/$/;"	m	struct:mcReader
alsoPropagate	src/vr_command.c	/^void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f
also_propagate	src/vr_server.h	/^    redisOpArray also_propagate;    \/* Additional command to propagate. *\/$/;"	m	struct:vr_server
aofChildWriteDiffData	src/vr_aof.c	/^void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
aofRewriteBufferAppend	src/vr_aof.c	/^void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {$/;"	f
aofRewriteBufferSize	src/vr_aof.c	/^unsigned long aofRewriteBufferSize(void) {$/;"	f
aof_buf	src/vr_server.h	/^    sds aof_buf;      \/* AOF buffer, written before entering the event loop *\/$/;"	m	struct:vr_server
aof_child_diff	src/vr_server.h	/^    sds aof_child_diff;             \/* AOF diff accumulator child side. *\/$/;"	m	struct:vr_server
aof_child_pid	src/vr_server.h	/^    pid_t aof_child_pid;            \/* PID if rewriting process *\/$/;"	m	struct:vr_server
aof_current_size	src/vr_server.h	/^    off_t aof_current_size;         \/* AOF current size. *\/$/;"	m	struct:vr_server
aof_delayed_fsync	src/vr_server.h	/^    unsigned long aof_delayed_fsync;  \/* delayed AOF fsync() counter *\/$/;"	m	struct:vr_server
aof_fd	src/vr_server.h	/^    int aof_fd;       \/* File descriptor of currently selected AOF file *\/$/;"	m	struct:vr_server
aof_filename	src/vr_server.h	/^    char *aof_filename;             \/* Name of the AOF file *\/$/;"	m	struct:vr_server
aof_flush_postponed_start	src/vr_server.h	/^    time_t aof_flush_postponed_start; \/* UNIX time of postponed AOF flush *\/$/;"	m	struct:vr_server
aof_fsync	src/vr_server.h	/^    int aof_fsync;                  \/* Kind of fsync() policy *\/$/;"	m	struct:vr_server
aof_last_fsync	src/vr_server.h	/^    time_t aof_last_fsync;            \/* UNIX time of last fsync() *\/$/;"	m	struct:vr_server
aof_last_write_errno	src/vr_server.h	/^    int aof_last_write_errno;       \/* Valid if aof_last_write_status is ERR *\/$/;"	m	struct:vr_server
aof_last_write_status	src/vr_server.h	/^    int aof_last_write_status;      \/* VR_OK or VR_ERROR *\/$/;"	m	struct:vr_server
aof_lastbgrewrite_status	src/vr_server.h	/^    int aof_lastbgrewrite_status;   \/* VR_OK or VR_ERROR *\/$/;"	m	struct:vr_server
aof_load_truncated	src/vr_server.h	/^    int aof_load_truncated;         \/* Don't stop on unexpected AOF EOF. *\/$/;"	m	struct:vr_server
aof_no_fsync_on_rewrite	src/vr_server.h	/^    int aof_no_fsync_on_rewrite;    \/* Don't fsync if a rewrite is in prog. *\/$/;"	m	struct:vr_server
aof_pipe_read_ack_from_child	src/vr_server.h	/^    int aof_pipe_read_ack_from_child;$/;"	m	struct:vr_server
aof_pipe_read_ack_from_parent	src/vr_server.h	/^    int aof_pipe_read_ack_from_parent;$/;"	m	struct:vr_server
aof_pipe_read_data_from_parent	src/vr_server.h	/^    int aof_pipe_read_data_from_parent;$/;"	m	struct:vr_server
aof_pipe_write_ack_to_child	src/vr_server.h	/^    int aof_pipe_write_ack_to_child;$/;"	m	struct:vr_server
aof_pipe_write_ack_to_parent	src/vr_server.h	/^    int aof_pipe_write_ack_to_parent;$/;"	m	struct:vr_server
aof_pipe_write_data_to_child	src/vr_server.h	/^    int aof_pipe_write_data_to_child;$/;"	m	struct:vr_server
aof_rewrite_base_size	src/vr_server.h	/^    off_t aof_rewrite_base_size;    \/* AOF size on latest startup or rewrite. *\/$/;"	m	struct:vr_server
aof_rewrite_buf_blocks	src/vr_server.h	/^    dlist *aof_rewrite_buf_blocks;   \/* Hold changes during an AOF rewrite. *\/$/;"	m	struct:vr_server
aof_rewrite_incremental_fsync	src/vr_server.h	/^    int aof_rewrite_incremental_fsync;\/* fsync incrementally while rewriting? *\/$/;"	m	struct:vr_server
aof_rewrite_min_size	src/vr_server.h	/^    off_t aof_rewrite_min_size;     \/* the AOF file is at least N bytes. *\/$/;"	m	struct:vr_server
aof_rewrite_perc	src/vr_server.h	/^    int aof_rewrite_perc;           \/* Rewrite AOF if % growth is > M and... *\/$/;"	m	struct:vr_server
aof_rewrite_scheduled	src/vr_server.h	/^    int aof_rewrite_scheduled;      \/* Rewrite once BGSAVE terminates. *\/$/;"	m	struct:vr_server
aof_rewrite_time_last	src/vr_server.h	/^    time_t aof_rewrite_time_last;   \/* Time used by last AOF rewrite run. *\/$/;"	m	struct:vr_server
aof_rewrite_time_start	src/vr_server.h	/^    time_t aof_rewrite_time_start;  \/* Current AOF rewrite start time. *\/$/;"	m	struct:vr_server
aof_selected_db	src/vr_server.h	/^    int aof_selected_db; \/* Currently selected DB in AOF *\/$/;"	m	struct:vr_server
aof_state	src/vr_server.h	/^    int aof_state;                  \/* AOF_(ON|OFF|WAIT_REWRITE) *\/$/;"	m	struct:vr_server
aof_stop_sending_diff	src/vr_server.h	/^    int aof_stop_sending_diff;     \/* If true stop sending accumulated diffs$/;"	m	struct:vr_server
aofrwblock	src/vr_aof.h	/^typedef struct aofrwblock {$/;"	s
aofrwblock	src/vr_aof.h	/^} aofrwblock;$/;"	t	typeref:struct:aofrwblock
apidata	dep/ae/ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop
appendCommand	src/vr_t_string.c	/^void appendCommand(client *c) {$/;"	f
append_cmd_nck	tests/vrt_produce_data.c	/^static int append_cmd_nck(redisReply *reply)$/;"	f	file:
append_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *append_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
arch_bits	src/vr_server.h	/^    int arch_bits;              \/* 32 or 64 depending on sizeof(long) *\/$/;"	m	struct:vr_server
argc	src/vr_client.h	/^    int argc;               \/* Num of arguments of current command. *\/$/;"	m	struct:client
argc	src/vr_command.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
argc	src/vr_multi.h	/^    int argc;$/;"	m	struct:multiCmd
argc	src/vr_slowlog.h	/^    int argc;$/;"	m	struct:slowlogEntry
argc	tests/vrt_produce_data.h	/^    int argc;       \/* Num of arguments of current command. *\/$/;"	m	struct:data_unit
argv	src/vr_client.h	/^    robj **argv;            \/* Arguments of current command. *\/$/;"	m	struct:client
argv	src/vr_command.h	/^    robj **argv;$/;"	m	struct:redisOp
argv	src/vr_multi.h	/^    robj **argv;$/;"	m	struct:multiCmd
argv	src/vr_slowlog.h	/^    robj **argv;$/;"	m	struct:slowlogEntry
argv	tests/vrt_produce_data.h	/^    sds *argv;    \/* Arguments of current command. *\/$/;"	m	struct:data_unit
arity	src/vr_command.h	/^    int arity;$/;"	m	struct:redisCommand
arity	tests/vrt_produce_data.h	/^    int arity;$/;"	m	struct:data_producer
asyncCloseClientOnOutputBufferLimitReached	src/vr_client.c	/^void asyncCloseClientOnOutputBufferLimitReached(client *c) {$/;"	f
atomic_add	dep/util/dutil.h	123;"	d
atomic_add	dep/util/dutil.h	133;"	d
atomic_add	dep/util/dutil.h	144;"	d
atomic_get	dep/util/dutil.h	126;"	d
atomic_get	dep/util/dutil.h	136;"	d
atomic_get	dep/util/dutil.h	162;"	d
atomic_locker	dep/util/dutil.c	/^pthread_mutex_t atomic_locker = PTHREAD_MUTEX_INITIALIZER;$/;"	v
atomic_set	dep/util/dutil.h	125;"	d
atomic_set	dep/util/dutil.h	135;"	d
atomic_set	dep/util/dutil.h	156;"	d
atomic_sub	dep/util/dutil.h	124;"	d
atomic_sub	dep/util/dutil.h	134;"	d
atomic_sub	dep/util/dutil.h	150;"	d
attempted_compress	src/vr_quicklist.h	/^    unsigned int attempted_compress : 1; \/* node can't compress; too small *\/$/;"	m	struct:quicklistNode
auth	tests/vrt_benchmark.c	/^    char *auth;$/;"	m	struct:config	file:
authCommand	src/vr_server.c	/^void authCommand(client *c) {$/;"	f
authenticated	src/vr_client.h	/^    int authenticated;      \/* When requirepass(1) or adminpass(2) is non-NULL. *\/$/;"	m	struct:client
avg_ttl	src/vr_db.h	/^    long long avg_ttl;          \/* Average TTL, just for stats *\/$/;"	m	struct:redisDb
avg_ttl_all	src/vr_server.c	/^    long long avg_ttl_all;$/;"	m	struct:keys_statistics	file:
b	dep/dhashkit/dmd5.c	/^    MD5_u32plus a, b, c, d;$/;"	m	struct:__anon2	file:
backend_conn_context_deinit	tests/vrt_backend.c	/^static void backend_conn_context_deinit(conn_context *cc)$/;"	f	file:
backend_conn_context_init	tests/vrt_backend.c	/^static int backend_conn_context_init(conn_context *cc, char *host, int port)$/;"	f	file:
backend_cron	src/vr_backend.c	/^backend_cron(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f	file:
backend_server_idx_t	tests/vrabtest.h	/^typedef unsigned int (*backend_server_idx_t)(struct abtest_group*, char *, size_t);$/;"	t
backend_server_t	tests/vrabtest.h	/^typedef abtest_server *(*backend_server_t)(struct abtest_group*, char *, size_t);$/;"	t
backend_thread	tests/vrt_backend.h	/^typedef struct backend_thread {$/;"	s
backend_thread	tests/vrt_backend.h	/^} backend_thread;$/;"	t	typeref:struct:backend_thread
backend_thread_cron	tests/vrt_backend.c	/^static int backend_thread_cron(aeEventLoop *eventLoop, long long id, void *clientData)$/;"	f	file:
backend_thread_deinit	tests/vrt_backend.c	/^static void backend_thread_deinit(backend_thread *bt)$/;"	f	file:
backend_thread_init	tests/vrt_backend.c	/^static int backend_thread_init(backend_thread *bt, char *test_target_groups)$/;"	f	file:
backend_thread_run	src/vr_backend.c	/^backend_thread_run(void *args)$/;"	f	file:
backend_threads	tests/vrt_backend.c	/^static darray *backend_threads = NULL;$/;"	v	file:
backend_threads_count	tests/vrt_backend.c	/^int backend_threads_count;$/;"	v
backend_threads_pause_finished_count	tests/vrt_backend.c	/^int backend_threads_pause_finished_count;$/;"	v
backends	src/vr_backend.c	/^struct darray backends;$/;"	v	typeref:struct:darray
backends_deinit	src/vr_backend.c	/^backends_deinit(void)$/;"	f
backends_init	src/vr_backend.c	/^backends_init(uint32_t backend_count)$/;"	f
backends_run	src/vr_backend.c	/^backends_run(void)$/;"	f
backends_wait	src/vr_backend.c	/^backends_wait(void)$/;"	f
backward	src/vr_server.h	/^    struct zskiplistNode *backward;$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode
beforesleep	dep/ae/ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop
begin_check_data	tests/vrt_check_data.c	/^static int begin_check_data(void)$/;"	f	file:
benchmark	tests/vrt_benchmark.c	/^static void benchmark(char *title, char *cmd, int len) {$/;"	f	file:
benchmark_client	tests/vrt_benchmark.c	/^} *benchmark_client;$/;"	t	typeref:struct:_benchmark_client	file:
benchmark_thread	tests/vrt_benchmark.c	/^typedef struct benchmark_thread {$/;"	s	file:
benchmark_thread	tests/vrt_benchmark.c	/^} benchmark_thread;$/;"	t	typeref:struct:benchmark_thread	file:
benchmark_thread_deinit	tests/vrt_benchmark.c	/^static void benchmark_thread_deinit(benchmark_thread *bt)$/;"	f	file:
benchmark_thread_init	tests/vrt_benchmark.c	/^static int benchmark_thread_init(benchmark_thread *bt, int requests, int numclients, char *cmd, size_t len)$/;"	f	file:
benchmark_thread_run	tests/vrt_benchmark.c	/^static void *benchmark_thread_run(void *args)$/;"	f	file:
bgsaveerr	src/vr_server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
binds	src/vr_conf.h	/^    struct darray  binds;                \/* Type: sds *\/$/;"	m	struct:conf_server	typeref:struct:conf_server::darray
bitcountCommand	src/vr_bitops.c	/^void bitcountCommand(client *c) {$/;"	f
bitcount_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *bitcount_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
bitfieldCommand	src/vr_bitops.c	/^void bitfieldCommand(client *c) {$/;"	f
bitfieldOp	src/vr_bitops.c	/^struct bitfieldOp {$/;"	s	file:
bitopCommand	src/vr_bitops.c	/^void bitopCommand(client *c) {$/;"	f
bitposCommand	src/vr_bitops.c	/^void bitposCommand(client *c) {$/;"	f
bitpos_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *bitpos_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
bits	src/vr_bitops.c	/^    int bits;           \/* Integer bitfield bits width. *\/$/;"	m	struct:bitfieldOp	file:
blk	dep/dhashkit/dsha1.c	40;"	d	file:
blk0	dep/dhashkit/dsha1.c	35;"	d	file:
blk0	dep/dhashkit/dsha1.c	38;"	d	file:
block	dep/dhashkit/dmd5.c	/^    MD5_u32plus block[16];$/;"	m	struct:__anon2	file:
blockClient	src/vr_block.c	/^void blockClient(client *c, int btype) {$/;"	f
blockForKeys	src/vr_t_list.c	/^void blockForKeys(client *c, robj **keys, int numkeys, mstime_t timeout, robj *target) {$/;"	f
blockingPopGenericCommand	src/vr_t_list.c	/^void blockingPopGenericCommand(client *c, int where) {$/;"	f
blockingState	src/vr_block.h	/^typedef struct blockingState {$/;"	s
blockingState	src/vr_block.h	/^} blockingState;$/;"	t	typeref:struct:blockingState
blocking_keys	src/vr_db.h	/^    dict *blocking_keys;        \/* Keys with clients waiting for data (BLPOP) *\/$/;"	m	struct:redisDb
blpopCommand	src/vr_t_list.c	/^void blpopCommand(client *c) {$/;"	f
body	dep/dhashkit/dmd5.c	/^body(MD5_CTX *ctx, void *data, unsigned long size)$/;"	f	file:
bpop	src/vr_client.h	/^    blockingState bpop;     \/* blocking state *\/$/;"	m	struct:client
bpop_blocked_clients	src/vr_eventloop.h	/^    unsigned int bpop_blocked_clients; \/* Number of clients blocked by lists *\/$/;"	m	struct:vr_eventloop
brpopCommand	src/vr_t_list.c	/^void brpopCommand(client *c) {$/;"	f
brpoplpushCommand	src/vr_t_list.c	/^void brpoplpushCommand(client *c) {$/;"	f
bsdata	dep/ae/ae.h	/^    void *bsdata; \/* This is used for beforesleep private data *\/$/;"	m	struct:aeEventLoop
bt	tests/vrt_benchmark.c	/^    benchmark_thread *bt;$/;"	m	struct:_benchmark_client	file:
bts	tests/vrt_benchmark.c	/^static darray *bts; \/* Benchmark threads *\/$/;"	v	file:
btype	src/vr_client.h	/^    int btype;              \/* Type of blocking op if CLIENT_BLOCKED. *\/$/;"	m	struct:client
buf	dep/himemcached-0.1.0/himcdep/sds.h	/^    char buf[];$/;"	m	struct:sdshdr
buf	dep/himemcached-0.1.0/himcread.h	/^    char *buf; \/* Read buffer *\/$/;"	m	struct:mcReader
buf	dep/sds/sds.h	/^    char buf[];$/;"	m	struct:sdshdr16
buf	dep/sds/sds.h	/^    char buf[];$/;"	m	struct:sdshdr32
buf	dep/sds/sds.h	/^    char buf[];$/;"	m	struct:sdshdr5
buf	dep/sds/sds.h	/^    char buf[];$/;"	m	struct:sdshdr64
buf	dep/sds/sds.h	/^    char buf[];$/;"	m	struct:sdshdr8
buf	src/vr_aof.h	/^    char buf[AOF_RW_BUF_BLOCK_SIZE];$/;"	m	struct:aofrwblock
buf	src/vr_client.h	/^    char buf[PROTO_REPLY_CHUNK_BYTES];$/;"	m	struct:client
buffer	dep/dhashkit/dhashkit.h	/^    unsigned char buffer[64];$/;"	m	struct:__anon1
buffer	dep/dhashkit/dmd5.c	/^    unsigned char buffer[64];$/;"	m	struct:__anon2	file:
bufpos	src/vr_client.h	/^    int bufpos;$/;"	m	struct:client
bulkhdr	src/vr_server.h	/^    *bulkhdr[OBJ_SHARED_BULKHDR_LEN],  \/* "$<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct
bulklen	src/vr_client.h	/^    long bulklen;           \/* Length of bulk argument in multi bulk request. *\/$/;"	m	struct:client
busykeyerr	src/vr_server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
bytesToHuman	src/vr_util.c	/^void bytesToHuman(char *s, unsigned long long n) {$/;"	f
c	dep/dhashkit/dmd5.c	/^    MD5_u32plus a, b, c, d;$/;"	m	struct:__anon2	file:
cache	src/vr_client.h	/^    void *cache;            \/* Cache data for client to jump between workers. *\/$/;"	m	struct:client
cache_version	src/vr_conf.h	/^    unsigned long long cache_version;$/;"	m	struct:conf_cache
cached_keys_count	tests/vrt_public.h	/^    long long cached_keys_count;$/;"	m	struct:key_cache_array
cached_keys_per_produce_thread	tests/vrabtest.c	/^    long long cached_keys_per_produce_thread;$/;"	m	struct:config	file:
cached_master	src/vr_replication.h	/^    client *cached_master; \/* Cached master to be reused for PSYNC. *\/$/;"	m	struct:vr_replication
call	src/vr_command.c	/^void call(client *c, int flags) {$/;"	f
callback_data	tests/vrt_dispatch_data.c	/^struct callback_data {$/;"	s	file:
calls	src/vr_command.h	/^    long long calls;$/;"	m	struct:commandStats
card	src/vr_hyperloglog.c	/^    uint8_t card[8];    \/* Cached cardinality, little endian. *\/$/;"	m	struct:hllhdr	file:
catAppendOnlyExpireAtCommand	src/vr_aof.c	/^sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {$/;"	f
catAppendOnlyGenericCommand	src/vr_aof.c	/^sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {$/;"	f
catClientInfoString	src/vr_client.c	/^sds catClientInfoString(sds s, client *client) {$/;"	f
cb	src/vr_connection.h	/^    conn_base           *cb;             \/* connect base *\/$/;"	m	struct:conn
cb	src/vr_eventloop.h	/^    conn_base *cb;$/;"	m	struct:vr_eventloop
cbsul	src/vr_master.h	/^    dlist *cbsul;    \/* Connect back swap unit list *\/$/;"	m	struct:vr_master
cbsul_pop	src/vr_master.c	/^cbsul_pop(void)$/;"	f	file:
cbsul_push	src/vr_master.c	/^cbsul_push(struct connswapunit *su)$/;"	f	file:
cbsullock	src/vr_master.h	/^    pthread_mutex_t cbsullock;   \/* swap unit list locker *\/$/;"	m	struct:vr_master
cc	src/vr_eventloop.h	/^    conf_cache cc; \/* Cache the hot config option to improve vire speed. *\/$/;"	m	struct:vr_eventloop
cdt	tests/vrt_check_data.c	/^    check_data_thread *cdt;$/;"	m	struct:check_unit	file:
cdts	tests/vrt_check_data.c	/^static darray *cdts = NULL;$/;"	v	file:
changes	src/vr_rdb.h	/^    int changes;$/;"	m	struct:saveparam
checkClientOutputBufferLimits	src/vr_client.c	/^int checkClientOutputBufferLimits(client *c) {$/;"	f
checkCmdValidAndGetTotalLen	dep/himemcached-0.1.0/himemcached.c	/^static int checkCmdValidAndGetTotalLen(int cmdtype, int argtype, int argc, char **argv, size_t *argvlen)$/;"	f	file:
checkIfExpired	src/vr_db.c	/^int checkIfExpired(redisDb *db, robj *key) {$/;"	f
checkSignedBitfieldOverflow	src/vr_bitops.c	/^int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {$/;"	f
checkStringLength	src/vr_t_string.c	/^static int checkStringLength(client *c, long long size) {$/;"	f	file:
checkType	src/vr_object.c	/^int checkType(client *c, robj *o, int type) {$/;"	f
checkUnsignedBitfieldOverflow	src/vr_bitops.c	/^int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {$/;"	f
check_begin_time	tests/vrt_check_data.c	/^    long long check_begin_time; \/* Unit is second *\/$/;"	m	struct:check_data_thread	file:
check_begin_time	tests/vrt_check_data.c	/^    long long check_begin_time; \/* Unit is second *\/$/;"	m	struct:data_checker	file:
check_conn_context_deinit	tests/vrt_check_data.c	/^static void check_conn_context_deinit(conn_context *cc)$/;"	f	file:
check_conn_context_init	tests/vrt_check_data.c	/^static int check_conn_context_init(conn_context *cc, char *host, int port)$/;"	f	file:
check_data_callback	tests/vrt_check_data.c	/^static void check_data_callback(redisAsyncContext *c, void *r, void *privdata) {$/;"	f	file:
check_data_thread	tests/vrt_check_data.c	/^typedef struct check_data_thread {$/;"	s	file:
check_data_thread	tests/vrt_check_data.c	/^} check_data_thread;$/;"	t	typeref:struct:check_data_thread	file:
check_data_thread_cron	tests/vrt_check_data.c	/^static int check_data_thread_cron(aeEventLoop *eventLoop, long long id, void *clientData)$/;"	f	file:
check_data_thread_deinit	tests/vrt_check_data.c	/^static void check_data_thread_deinit(check_data_thread *cdt)$/;"	f	file:
check_data_thread_init	tests/vrt_check_data.c	/^static int check_data_thread_init(check_data_thread *cdt, char *test_target_groups)$/;"	f	file:
check_data_thread_run	tests/vrt_check_data.c	/^static void *check_data_thread_run(void *args)$/;"	f	file:
check_data_threads_count	tests/vrt_check_data.c	/^static int check_data_threads_count = 8;$/;"	v	file:
check_data_threads_finished_count	tests/vrt_check_data.c	/^static int check_data_threads_finished_count = 0;$/;"	v	file:
check_memory_enough	tests/vrt_backend.c	/^static void check_memory_enough(backend_thread *bt)$/;"	f	file:
check_replys_if_same	tests/vrt_check_data.c	/^static int check_replys_if_same(check_unit *cunit)$/;"	f	file:
check_replys_if_same	tests/vrt_dispatch_data.c	/^static int check_replys_if_same(reply_unit *ru)$/;"	f	file:
check_two_replys_if_same	tests/vrt_public.c	/^int check_two_replys_if_same(redisReply *reply1, redisReply *reply2)$/;"	f
check_unit	tests/vrt_check_data.c	/^typedef struct check_unit {$/;"	s	file:
check_unit	tests/vrt_check_data.c	/^} check_unit;$/;"	t	typeref:struct:check_unit	file:
check_unit_create	tests/vrt_check_data.c	/^static check_unit *check_unit_create(void)$/;"	f	file:
check_unit_destroy	tests/vrt_check_data.c	/^static void check_unit_destroy(check_unit *cunit)$/;"	f	file:
check_units	tests/vrt_check_data.c	/^    dlist *check_units;$/;"	m	struct:check_data_thread	file:
checker	tests/vrabtest.c	/^    char *checker;$/;"	m	struct:config	file:
checker	tests/vrt_check_data.c	/^    sds checker;$/;"	m	struct:data_checker	file:
checking_data	tests/vrt_check_data.c	/^static int checking_data;$/;"	v	file:
checking_data_or_not	tests/vrt_check_data.c	/^static int checking_data_or_not(void)$/;"	f	file:
chrtos	dep/himemcached-0.1.0/himcread.c	/^static size_t chrtos(char *buf, size_t size, char byte) $/;"	f	file:
ckeys	tests/vrt_public.h	/^    sds *ckeys;    \/* Cached keys that may exist in the target redis\/vire servers. *\/$/;"	m	struct:key_cache_array
ckeys_write_idx	tests/vrt_public.h	/^    long long ckeys_write_idx;$/;"	m	struct:key_cache_array
client	src/vr_client.h	/^typedef struct client {$/;"	s
client	src/vr_client.h	/^} client;$/;"	t	typeref:struct:client
client	src/vr_pubsub.h	/^    client *client;$/;"	m	struct:pubsubPattern
clientBufferLimitsConfig	src/vr_client.h	/^typedef struct clientBufferLimitsConfig {$/;"	s
clientBufferLimitsConfig	src/vr_client.h	/^} clientBufferLimitsConfig;$/;"	t	typeref:struct:clientBufferLimitsConfig
clientCommand	src/vr_client.c	/^void clientCommand(client *c) {$/;"	f
clientData	dep/ae/ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent
clientData	dep/ae/ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent
clientDone	tests/vrt_benchmark.c	/^static void clientDone(benchmark_client c) {$/;"	f	file:
clientHasPendingReplies	src/vr_client.c	/^int clientHasPendingReplies(client *c) {$/;"	f
clientSubscriptionsCount	src/vr_pubsub.c	/^int clientSubscriptionsCount(client *c) {$/;"	f
client_accept	src/vr_master.c	/^client_accept(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
client_max_querybuf_len	src/vr_server.h	/^    size_t client_max_querybuf_len; \/* Limit for client query buffer length *\/$/;"	m	struct:vr_server
client_obuf_limits	src/vr_server.h	/^    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];$/;"	m	struct:vr_server
clientkilldata	src/vr_client.c	/^struct clientkilldata {$/;"	s	file:
clients	src/vr_eventloop.h	/^    dlist *clients;              \/* List of active clients *\/$/;"	m	struct:vr_eventloop
clients	src/vr_server.h	/^    dlist *clients;$/;"	m	struct:vr_server
clients	tests/vrt_benchmark.c	/^    dlist *clients;$/;"	m	struct:benchmark_thread	file:
clientsArePaused	src/vr_client.c	/^int clientsArePaused(vr_eventloop *vel) {$/;"	f
clients_pause_end_time	src/vr_eventloop.h	/^    long long clients_pause_end_time; \/* Time when we undo clients_paused *\/$/;"	m	struct:vr_eventloop
clients_paused	src/vr_eventloop.h	/^    int clients_paused;         \/* True if clients are currently paused *\/$/;"	m	struct:vr_eventloop
clients_pending_write	src/vr_eventloop.h	/^    dlist *clients_pending_write;\/* There is to write or install handler. *\/$/;"	m	struct:vr_eventloop
clients_per_dispatch_thread	tests/vrabtest.c	/^    int clients_per_dispatch_thread;$/;"	m	struct:config	file:
clients_to_close	src/vr_eventloop.h	/^    dlist *clients_to_close;     \/* Clients to close asynchronously *\/$/;"	m	struct:vr_eventloop
clients_waiting_acks	src/vr_eventloop.h	/^    dlist *clients_waiting_acks;     \/* Clients waiting in WAIT command. *\/$/;"	m	struct:vr_eventloop
close_this_client	src/vr_client.c	/^    int close_this_client;$/;"	m	struct:clientkilldata	file:
cmd	src/vr_client.h	/^    struct redisCommand *cmd, *lastcmd;  \/* Last command executed. *\/$/;"	m	struct:client	typeref:struct:client::redisCommand
cmd	src/vr_command.h	/^    struct redisCommand *cmd;$/;"	m	struct:redisOp	typeref:struct:redisOp::redisCommand
cmd	src/vr_multi.h	/^    struct redisCommand *cmd;$/;"	m	struct:multiCmd	typeref:struct:multiCmd::redisCommand
cmd_blacklist	tests/vrabtest.c	/^    darray *cmd_blacklist;$/;"	m	struct:config	file:
cmd_type	tests/vrabtest.c	/^    int cmd_type;$/;"	m	struct:config	file:
cmd_type	tests/vrt_produce_data.c	/^static int cmd_type;$/;"	v	file:
cmd_type	tests/vrt_produce_data.h	/^    int cmd_type;$/;"	m	struct:data_producer
cmd_whitelist	tests/vrabtest.c	/^    darray *cmd_whitelist;$/;"	m	struct:config	file:
cnegone	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
collateStringObjects	src/vr_object.c	/^int collateStringObjects(robj *a, robj *b) {$/;"	f
colon	src/vr_server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct
color	src/vr_rbtree.h	/^    uint8_t       color;     \/* red | black *\/$/;"	m	struct:rbnode
commandCommand	src/vr_command.c	/^void commandCommand(client *c) {$/;"	f
commandStats	src/vr_command.h	/^typedef struct commandStats {$/;"	s
commandStats	src/vr_command.h	/^}commandStats;$/;"	t	typeref:struct:commandStats
commandStatsTableCreate	src/vr_command.c	/^commandStatsTableCreate(void)$/;"	f
commandStatsTableDestroy	src/vr_command.c	/^commandStatsTableDestroy(struct darray *cstatstable)$/;"	f
commandTableDictType	src/vr_command.c	/^dictType commandTableDictType = {$/;"	v
commands	src/vr_multi.h	/^    multiCmd *commands;     \/* Array of MULTI commands *\/$/;"	m	struct:multiState
commands	src/vr_server.h	/^    dict *commands;             \/* Command table *\/$/;"	m	struct:vr_server
commands_need_adminpass	src/vr_conf.h	/^    struct darray  commands_need_adminpass;$/;"	m	struct:conf_server	typeref:struct:conf_server::darray
compareLatency	tests/vrt_benchmark.c	/^static int compareLatency(const void *a, const void *b) {$/;"	f	file:
compareStringObjects	src/vr_object.c	/^int compareStringObjects(robj *a, robj *b) {$/;"	f
compareStringObjectsForLexRange	src/vr_t_zset.c	/^int compareStringObjectsForLexRange(robj *a, robj *b) {$/;"	f
compareStringObjectsWithFlags	src/vr_object.c	/^int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {$/;"	f
compress	src/vr_quicklist.h	/^    unsigned int compress : 16; \/* depth of end nodes not to compress;0=off *\/$/;"	m	struct:quicklist
compressed	src/vr_quicklist.h	/^    char compressed[];$/;"	m	struct:quicklistLZF
cone	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
conf	src/vr_conf.c	/^vr_conf *conf = NULL;$/;"	v
conf_cache	src/vr_conf.h	/^typedef struct conf_cache {$/;"	s
conf_cache	src/vr_conf.h	/^}conf_cache;$/;"	t	typeref:struct:conf_cache
conf_cache_deinit	src/vr_conf.c	/^conf_cache_deinit(conf_cache *cc)$/;"	f
conf_cache_init	src/vr_conf.c	/^conf_cache_init(conf_cache *cc)$/;"	f
conf_cache_update	src/vr_conf.c	/^conf_cache_update(conf_cache *cc)$/;"	f
conf_create	src/vr_conf.c	/^conf_create(char *filename)$/;"	f
conf_deinit	src/vr_conf.c	/^static void conf_deinit(vr_conf *cf)$/;"	f	file:
conf_destroy	src/vr_conf.c	/^conf_destroy(vr_conf *cf)$/;"	f
conf_dump	src/vr_conf.c	/^conf_dump(vr_conf *cf)$/;"	f	file:
conf_file	tests/vrt_public.h	/^    sds conf_file;$/;"	m	struct:vire_instance
conf_filename	src/vr_core.h	/^    char            *conf_filename;              \/* configuration filename *\/$/;"	m	struct:instance
conf_get_array_sds	src/vr_conf.c	/^conf_get_array_sds(void *obj, conf_option *opt, void *data)$/;"	f
conf_get_int	src/vr_conf.c	/^conf_get_int(void *obj, conf_option *opt, void *data)$/;"	f
conf_get_longlong	src/vr_conf.c	/^conf_get_longlong(void *obj, conf_option *opt, void *data)$/;"	f
conf_get_sds	src/vr_conf.c	/^conf_get_sds(void *obj, conf_option *opt, void *data)$/;"	f
conf_init	src/vr_conf.c	/^static int conf_init(vr_conf *cf)$/;"	f	file:
conf_key_value_insert	src/vr_conf.c	/^conf_key_value_insert(dict *org, sds key, conf_value *cv)$/;"	f	file:
conf_open	src/vr_conf.c	/^conf_open(char *filename)$/;"	f	file:
conf_option	src/vr_conf.h	/^typedef struct conf_option {$/;"	s
conf_option	src/vr_conf.h	/^}conf_option;$/;"	t	typeref:struct:conf_option
conf_organization_dump	src/vr_conf.c	/^conf_organization_dump(sds name, dict *org, int log_level)$/;"	f	file:
conf_organizations_dump	src/vr_conf.c	/^conf_organizations_dump(vr_conf *cf)$/;"	f	file:
conf_parse	src/vr_conf.c	/^conf_parse(vr_conf *cf)$/;"	f	file:
conf_parse_conf_server	src/vr_conf.c	/^conf_parse_conf_server(conf_server *cs, dict *org)$/;"	f	file:
conf_post_validate	src/vr_conf.c	/^conf_post_validate(vr_conf *cf)$/;"	f	file:
conf_pre_load_from_string	src/vr_conf.c	/^conf_pre_load_from_string(vr_conf *cf, char *config)$/;"	f	file:
conf_pre_validate	src/vr_conf.c	/^conf_pre_validate(vr_conf *cf)$/;"	f	file:
conf_server	src/vr_conf.h	/^typedef struct conf_server {$/;"	s
conf_server	src/vr_conf.h	/^} conf_server;$/;"	t	typeref:struct:conf_server
conf_server_deinit	src/vr_conf.c	/^static void conf_server_deinit(conf_server *cs)$/;"	f	file:
conf_server_dump	src/vr_conf.c	/^conf_server_dump(conf_server *cs, int log_level)$/;"	f	file:
conf_server_get	src/vr_conf.c	/^conf_server_get(const char *option_name, void *value)$/;"	f
conf_server_init	src/vr_conf.c	/^static int conf_server_init(conf_server *cs)$/;"	f	file:
conf_server_options	src/vr_conf.c	/^static conf_option conf_server_options[] = {$/;"	v	file:
conf_server_set	src/vr_conf.c	/^conf_server_set(const char *option_name, conf_value *value)$/;"	f
conf_server_set_default	src/vr_conf.c	/^static int conf_server_set_default(conf_server *cs)$/;"	f	file:
conf_set_array_sds	src/vr_conf.c	/^conf_set_array_sds(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_commands_need_adminpass	src/vr_conf.c	/^conf_set_commands_need_adminpass(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_default	src/vr_conf.c	/^static int conf_set_default(vr_conf *cf)$/;"	f	file:
conf_set_int	src/vr_conf.c	/^conf_set_int(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_int_non_zero	src/vr_conf.c	/^conf_set_int_non_zero(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_longlong	src/vr_conf.c	/^conf_set_longlong(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_maxmemory	src/vr_conf.c	/^conf_set_maxmemory(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_maxmemory_policy	src/vr_conf.c	/^conf_set_maxmemory_policy(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_password	src/vr_conf.c	/^conf_set_password(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_sds	src/vr_conf.c	/^conf_set_sds(void *obj, conf_option *opt, void *data)$/;"	f
conf_set_yesorno	src/vr_conf.c	/^conf_set_yesorno(void *obj, conf_option *opt, void *data)$/;"	f
conf_value	src/vr_conf.h	/^typedef struct conf_value{$/;"	s
conf_value	src/vr_conf.h	/^}conf_value;$/;"	t	typeref:struct:conf_value
conf_value_create	src/vr_conf.c	/^conf_value *conf_value_create(int type)$/;"	f
conf_value_destroy	src/vr_conf.c	/^void conf_value_destroy(conf_value *cv)$/;"	f
conf_value_dump	src/vr_conf.c	/^conf_value_dump(conf_value *cv, int log_level)$/;"	f	file:
conf_version_get	src/vr_conf.c	/^conf_version_get(void)$/;"	f
config	tests/vrabtest.c	/^static struct config config;$/;"	v	typeref:struct:config	file:
config	tests/vrabtest.c	/^struct config {$/;"	s	file:
config	tests/vrt_benchmark.c	/^static struct config {$/;"	s	file:
config	tests/vrt_benchmark.c	/^} config;$/;"	v	typeref:struct:config	file:
config	tests/vrtest.c	/^static struct config config;$/;"	v	typeref:struct:config	file:
config	tests/vrtest.c	/^struct config {$/;"	s	file:
configCommand	src/vr_conf.c	/^void configCommand(client *c) {$/;"	f
configEnumGetStrFun	src/vr_conf.c	/^typedef const char *(*configEnumGetStrFun)(int type);$/;"	t	file:
configGetCommand	src/vr_conf.c	/^static void configGetCommand(client *c) {$/;"	f	file:
configSetCommand	src/vr_conf.c	/^static void configSetCommand(client *c) {$/;"	f	file:
configfile	src/vr_server.h	/^    char *configfile;           \/* Absolute config file path, or NULL *\/$/;"	m	struct:vr_server
conn	src/vr_client.h	/^    struct conn *conn;$/;"	m	struct:client	typeref:struct:client::conn
conn	src/vr_connection.h	/^struct conn {$/;"	s
conn_base	src/vr_connection.h	/^typedef struct conn_base {$/;"	s
conn_base	src/vr_connection.h	/^}conn_base;$/;"	t	typeref:struct:conn_base
conn_context	tests/vrabtest.h	/^typedef struct conn_context {$/;"	s
conn_context	tests/vrabtest.h	/^} conn_context;$/;"	t	typeref:struct:conn_context
conn_contexts	tests/vrabtest.h	/^    darray *conn_contexts;  \/* connection context *\/$/;"	m	struct:abtest_server
conn_deinit	src/vr_connection.c	/^conn_deinit(conn_base *cb)$/;"	f
conn_free	src/vr_connection.c	/^conn_free(struct conn *conn)$/;"	f	file:
conn_get	src/vr_connection.c	/^conn_get(conn_base *cb)$/;"	f
conn_init	src/vr_connection.c	/^conn_init(conn_base *cb)$/;"	f
conn_put	src/vr_connection.c	/^conn_put(struct conn *conn)$/;"	f
conn_recv	src/vr_connection.c	/^conn_recv(struct conn *conn, void *buf, size_t size)$/;"	f
conn_send	src/vr_connection.c	/^conn_send(struct conn *conn, void *buf, size_t nsend)$/;"	f
conn_sendv	src/vr_connection.c	/^conn_sendv(struct conn *conn, struct darray *sendv, size_t nsend)$/;"	f
connect_callback	tests/vrt_backend.c	/^static void connect_callback(const redisAsyncContext *c, int status) {$/;"	f	file:
connect_callback	tests/vrt_check_data.c	/^static void connect_callback(const redisAsyncContext *c, int status) {$/;"	f	file:
connect_callback	tests/vrt_dispatch_data.c	/^static void connect_callback(const redisAsyncContext *c, int status) {$/;"	f	file:
connected	src/vr_connection.h	/^    unsigned            connected:1;     \/* connected? *\/$/;"	m	struct:conn
connecting	src/vr_connection.h	/^    unsigned            connecting:1;    \/* connecting? *\/$/;"	m	struct:conn
connection_type	dep/himemcached-0.1.0/himemcached.h	/^    enum mcConnectionType connection_type;$/;"	m	struct:mcContext	typeref:enum:mcContext::mcConnectionType
connswapunit	src/vr_worker.h	/^struct connswapunit {$/;"	s
constant	src/vr_object.h	/^    unsigned constant:1;$/;"	m	struct:vr_object
container	src/vr_quicklist.h	/^    unsigned int container : 2;  \/* NONE==1 or ZIPLIST==2 *\/$/;"	m	struct:quicklistNode
contents	src/vr_intset.h	/^    int8_t contents[];$/;"	m	struct:intset
continuum	dep/dhashkit/dhashkit.h	/^struct continuum {$/;"	s
copyClientOutputBuffer	src/vr_client.c	/^void copyClientOutputBuffer(client *dst, client *src) {$/;"	f
count	dep/dhashkit/dhashkit.h	/^    uint32_t count[2];    $/;"	m	struct:__anon1
count	src/vr_multi.h	/^    int count;              \/* Total number of MULTI commands *\/$/;"	m	struct:multiState
count	src/vr_quicklist.h	/^    unsigned int count : 16;     \/* count of items in ziplist *\/$/;"	m	struct:quicklistNode
count	src/vr_quicklist.h	/^    unsigned long count;        \/* total count of all entries in all ziplists *\/$/;"	m	struct:quicklist
count_wait_for_reply	tests/vrt_dispatch_data.h	/^    int count_wait_for_reply;$/;"	m	struct:dispatch_data_thread
crc16tab	dep/dhashkit/dcrc16.c	/^static const uint16_t crc16tab[256] = {$/;"	v	file:
crc32tab	dep/dhashkit/dcrc32.c	/^static const uint32_t crc32tab[256] = {$/;"	v	file:
createArray	dep/himemcached-0.1.0/himcread.h	/^    void *(*createArray)(size_t, void **);$/;"	m	struct:mcReplyObjectFunctions
createArrayObject	dep/himemcached-0.1.0/himemcached.c	/^static void *createArrayObject(size_t elements, void **element) {$/;"	f	file:
createClient	src/vr_client.c	/^client *createClient(vr_eventloop *vel, struct conn *conn) {$/;"	f
createClient	tests/vrt_benchmark.c	/^static benchmark_client createClient(char *cmd, size_t len, benchmark_client from, benchmark_thread *thread) {$/;"	f	file:
createEmbeddedStringObject	src/vr_object.c	/^robj *createEmbeddedStringObject(const char *ptr, size_t len) {$/;"	f
createHLLObject	src/vr_hyperloglog.c	/^robj *createHLLObject(void) {$/;"	f
createHashObject	src/vr_object.c	/^robj *createHashObject(void) {$/;"	f
createIntList	src/vr_ziplist.c	/^static unsigned char *createIntList() {$/;"	f	file:
createInteger	dep/himemcached-0.1.0/himcread.h	/^    void *(*createInteger)(long long);$/;"	m	struct:mcReplyObjectFunctions
createIntegerObject	dep/himemcached-0.1.0/himemcached.c	/^static void *createIntegerObject(long long value) {$/;"	f	file:
createIntsetObject	src/vr_object.c	/^robj *createIntsetObject(void) {$/;"	f
createList	src/vr_ziplist.c	/^static unsigned char *createList() {$/;"	f	file:
createMissingClients	tests/vrt_benchmark.c	/^static void createMissingClients(benchmark_client c) {$/;"	f	file:
createNil	dep/himemcached-0.1.0/himcread.h	/^    void *(*createNil)(void);$/;"	m	struct:mcReplyObjectFunctions
createNilObject	dep/himemcached-0.1.0/himemcached.c	/^static void *createNilObject(void) {$/;"	f	file:
createObject	src/vr_object.c	/^robj *createObject(int type, void *ptr) {$/;"	f
createQuicklistObject	src/vr_object.c	/^robj *createQuicklistObject(void) {$/;"	f
createRawStringObject	src/vr_object.c	/^robj *createRawStringObject(const char *ptr, size_t len) {$/;"	f
createReplyObject	dep/himemcached-0.1.0/himemcached.c	/^static mcReply *createReplyObject(int type) {$/;"	f	file:
createSetObject	src/vr_object.c	/^robj *createSetObject(void) {$/;"	f
createSharedObjects	src/vr_server.c	/^static void createSharedObjects(void) {$/;"	f	file:
createString	dep/himemcached-0.1.0/himcread.h	/^    void *(*createString)(int, char*, size_t, char*, size_t, int, long long);$/;"	m	struct:mcReplyObjectFunctions
createStringObject	dep/himemcached-0.1.0/himemcached.c	/^static void *createStringObject(int type, char *key, size_t keylen, char *str, size_t len, int flags, long long version) {$/;"	f	file:
createStringObject	src/vr_object.c	/^robj *createStringObject(const char *ptr, size_t len) {$/;"	f
createStringObjectFromLongDouble	src/vr_object.c	/^robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {$/;"	f
createStringObjectFromLongLong	src/vr_object.c	/^robj *createStringObjectFromLongLong(long long value) {$/;"	f
createZiplistObject	src/vr_object.c	/^robj *createZiplistObject(void) {$/;"	f
createZsetObject	src/vr_object.c	/^robj *createZsetObject(void) {$/;"	f
createZsetZiplistObject	src/vr_object.c	/^robj *createZsetZiplistObject(void) {$/;"	f
create_check_data_threads	tests/vrt_check_data.c	/^static int create_check_data_threads(void)$/;"	f	file:
create_dir	tests/vrt_util.c	/^int create_dir(char *path)$/;"	f
create_work_dir	tests/vrt_public.c	/^int create_work_dir(void)$/;"	f
crlf	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
cronloops	src/vr_eventloop.h	/^    int cronloops;              \/* Number of times the cron function run *\/$/;"	m	struct:vr_eventloop
cronloops	tests/vrt_backend.h	/^    int cronloops;          \/* Number of times the cron function run *\/$/;"	m	struct:backend_thread
cronloops	tests/vrt_benchmark.c	/^    int cronloops;          \/* Number of times the cron function run *\/$/;"	m	struct:benchmark_thread	file:
cronloops	tests/vrt_check_data.c	/^    int cronloops;          \/* Number of times the cron function run *\/$/;"	m	struct:data_checker	file:
cronloops	tests/vrt_check_data.c	/^    int cronloops;  \/* Number of times the cron function run *\/$/;"	m	struct:check_data_thread	file:
cronloops	tests/vrt_dispatch_data.h	/^    int cronloops;          \/* Number of times the cron function run *\/$/;"	m	struct:dispatch_data_thread
cserver	src/vr_conf.c	/^conf_server *cserver = NULL;$/;"	v
cserver	src/vr_conf.h	/^    conf_server   cserver;$/;"	m	struct:vr_conf
cstable	src/vr_eventloop.h	/^    struct darray *cstable; \/* type: commandStats *\/$/;"	m	struct:vr_eventloop	typeref:struct:vr_eventloop::darray
csui_free	src/vr_worker.c	/^csui_free(struct connswapunit *item) {$/;"	f
csui_freelist	src/vr_worker.c	/^static struct connswapunit *csui_freelist;$/;"	v	typeref:struct:connswapunit	file:
csui_freelist_lock	src/vr_worker.c	/^static pthread_mutex_t csui_freelist_lock;$/;"	v	file:
csui_new	src/vr_worker.c	/^csui_new(void) {$/;"	f
csul	src/vr_worker.h	/^    dlist *csul;    \/* Connect swap unit list *\/$/;"	m	struct:vr_worker
csul_pop	src/vr_worker.c	/^csul_pop(vr_worker *worker)$/;"	f
csul_push	src/vr_worker.c	/^csul_push(vr_worker *worker, struct connswapunit *su)$/;"	f
csullock	src/vr_worker.h	/^    pthread_mutex_t csullock;   \/* swap unit list locker *\/$/;"	m	struct:vr_worker
csv	tests/vrt_benchmark.c	/^    int csv;$/;"	m	struct:config	file:
ctable	src/vr_conf.h	/^    dict          *ctable;$/;"	m	struct:conf_server
ctime	src/vr_client.h	/^    time_t ctime;           \/* Client creation time. *\/$/;"	m	struct:client
ctx	tests/vrabtest.h	/^    struct redisContext *ctx;$/;"	m	struct:conn_context	typeref:struct:conn_context::redisContext
ctx	tests/vrt_public.h	/^    redisContext *ctx;$/;"	m	struct:vire_instance
curidx	src/vr_client.h	/^    int curidx;             \/* The worker idx that this client current belong to. *\/$/;"	m	struct:client
curr_clients_mutex	src/vr_client.h	/^pthread_mutex_t curr_clients_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
current	src/vr_quicklist.h	/^    quicklistNode *current;$/;"	m	struct:quicklistIter
current_client	src/vr_eventloop.h	/^    struct client *current_client;     \/* Current client, only used on crash report *\/$/;"	m	struct:vr_eventloop	typeref:struct:vr_eventloop::client
current_clients	src/vr_client.c	/^current_clients(void)$/;"	f
current_db	src/vr_backend.h	/^    unsigned int current_db;    \/* Last DB tested. *\/$/;"	m	struct:vr_backend
current_db	src/vr_worker.h	/^    unsigned int current_db;    \/* Last DB tested. *\/$/;"	m	struct:vr_worker
cursor	tests/vrt_backend.c	/^    long long cursor;   \/* scan cursor *\/$/;"	m	struct:task_data	file:
cursor	tests/vrt_check_data.c	/^    long long cursor;   \/* scan cursor *\/$/;"	m	struct:check_data_thread	file:
czero	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
d	dep/dhashkit/dmd5.c	/^    MD5_u32plus a, b, c, d;$/;"	m	struct:__anon2	file:
d	src/vr_dict.h	/^        double d;$/;"	m	union:dictEntry::__anon15
d	src/vr_dict.h	/^    dict *d;$/;"	m	struct:dictIterator
d2string	src/vr_util.c	/^int d2string(char *buf, size_t len, double value) {$/;"	f
d2string	tests/vrt_util.c	/^int d2string(char *buf, size_t len, double value) {$/;"	f
daemonize	src/vr.c	/^static int daemonize;$/;"	v	file:
daemonize	tests/vrabtest.c	/^static int daemonize;$/;"	v	file:
dalloc	dep/dmalloc/dmalloc.h	39;"	d
dalloc_get_fragmentation_ratio	dep/dmalloc/dmalloc.c	/^float dalloc_get_fragmentation_ratio(size_t rss) {$/;"	f
dalloc_get_memory_size	dep/dmalloc/dmalloc.c	/^size_t dalloc_get_memory_size(void) {$/;"	f
dalloc_get_rss	dep/dmalloc/dmalloc.c	/^size_t dalloc_get_rss(void) {$/;"	f
dalloc_used_memory	dep/dmalloc/dmalloc.c	/^dalloc_used_memory(void)$/;"	f
darray	dep/darray/darray.h	/^typedef struct darray {$/;"	s
darray	dep/darray/darray.h	/^} darray;$/;"	t	typeref:struct:darray
darray_compare_t	dep/darray/darray.h	/^typedef int (*darray_compare_t)(const void *, const void *);$/;"	t
darray_create	dep/darray/darray.c	/^darray_create(unsigned long long n, size_t size)$/;"	f
darray_deinit	dep/darray/darray.c	/^darray_deinit(darray *a)$/;"	f
darray_destroy	dep/darray/darray.c	/^darray_destroy(darray *a)$/;"	f
darray_each	dep/darray/darray.c	/^darray_each(darray *a, darray_each_t func, void *data)$/;"	f
darray_each_t	dep/darray/darray.h	/^typedef int (*darray_each_t)(void *, void *);$/;"	t
darray_get	dep/darray/darray.c	/^darray_get(darray *a, unsigned long long idx)$/;"	f
darray_idx	dep/darray/darray.c	/^darray_idx(darray *a, void *elem)$/;"	f
darray_init	dep/darray/darray.c	/^darray_init(darray *a, unsigned long long n, size_t size)$/;"	f
darray_n	dep/darray/darray.h	/^darray_n(const darray *a)$/;"	f
darray_null	dep/darray/darray.h	/^darray_null(darray *a)$/;"	f
darray_pop	dep/darray/darray.c	/^darray_pop(darray *a)$/;"	f
darray_push	dep/darray/darray.c	/^darray_push(darray *a)$/;"	f
darray_set	dep/darray/darray.h	/^darray_set(darray *a, void *elem, size_t size, unsigned long long nalloc)$/;"	f
darray_sort	dep/darray/darray.c	/^darray_sort(darray *a, darray_compare_t compare)$/;"	f
darray_swap	dep/darray/darray.c	/^darray_swap(darray *a, darray *b)$/;"	f
darray_top	dep/darray/darray.c	/^darray_top(darray *a)$/;"	f
dassert	dep/util/dutil.c	/^dassert(const char *cond, const char *file, int line, int panic)$/;"	f
data	src/vr_rbtree.h	/^    void          *data;     \/* opaque data *\/$/;"	m	struct:rbnode
data	src/vr_thread.h	/^    void *data;$/;"	m	struct:vr_thread
data	src/vr_worker.h	/^    void *data;$/;"	m	struct:connswapunit
data	tests/vrabtest.h	/^    void *data;$/;"	m	struct:abtest_server
data	tests/vrt_produce_data.h	/^    void *data;$/;"	m	struct:data_unit
data_checker	tests/vrt_check_data.c	/^typedef struct data_checker {$/;"	s	file:
data_checker	tests/vrt_check_data.c	/^} data_checker;$/;"	t	typeref:struct:data_checker	file:
data_checker_cron	tests/vrt_check_data.c	/^static int data_checker_cron(aeEventLoop *eventLoop, long long id, void *clientData)$/;"	f	file:
data_dispatch	tests/vrt_dispatch_data.c	/^int data_dispatch(data_unit *du)$/;"	f
data_producer	tests/vrt_produce_data.h	/^typedef struct data_producer {$/;"	s
data_producer	tests/vrt_produce_data.h	/^} data_producer;$/;"	t	typeref:struct:data_producer
data_unit	tests/vrt_produce_data.h	/^typedef struct data_unit {$/;"	s
data_unit	tests/vrt_produce_data.h	/^} data_unit;$/;"	t	typeref:struct:data_unit
data_unit_get	tests/vrt_produce_data.c	/^data_unit *data_unit_get(void)$/;"	f
data_unit_put	tests/vrt_produce_data.c	/^void data_unit_put(data_unit *du)$/;"	f
databases	src/vr_conf.h	/^    int           databases;$/;"	m	struct:conf_server
databasesCron	src/vr_db.c	/^void databasesCron(vr_backend *backend) {$/;"	f
datas	tests/vrt_dispatch_data.h	/^    struct dmtqueue *datas;  \/* Value is data_unit, used receive data $/;"	m	struct:dispatch_data_thread	typeref:struct:dispatch_data_thread::dmtqueue
datasize	tests/vrt_benchmark.c	/^    int datasize;$/;"	m	struct:config	file:
db	src/vr_client.h	/^    redisDb *db;            \/* Pointer to currently dispatch DB. *\/$/;"	m	struct:client
db	src/vr_multi.c	/^    redisDb *db;$/;"	m	struct:watchedKey	file:
db	src/vr_server.h	/^    redisDb *db;$/;"	m	struct:readyList
dbAdd	src/vr_db.c	/^void dbAdd(redisDb *db, robj *key, robj *val) {$/;"	f
dbDelete	src/vr_db.c	/^int dbDelete(redisDb *db, robj *key) {$/;"	f
dbDictType	src/vr_db.c	/^dictType dbDictType = {$/;"	v
dbExists	src/vr_db.c	/^int dbExists(redisDb *db, robj *key) {$/;"	f
dbOverwrite	src/vr_db.c	/^void dbOverwrite(redisDb *db, robj *key, robj *val) {$/;"	f
dbRandomKey	src/vr_db.c	/^robj *dbRandomKey(redisDb *db) {$/;"	f
dbUnshareStringValue	src/vr_db.c	/^robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {    $/;"	f
dbid	src/vr_command.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
dbinum	src/vr_server.h	/^    int dbinum;                 \/* Number of internal DBs for per logical DB *\/$/;"	m	struct:vr_server
dblnum	src/vr_server.h	/^    int dblnum;                 \/* Logical number of configured DBs *\/$/;"	m	struct:vr_server
dbnum	src/vr_server.h	/^    int dbnum;                  \/* Total number of DBs *\/$/;"	m	struct:vr_server
dbnum	tests/vrt_benchmark.c	/^    int dbnum;$/;"	m	struct:config	file:
dbnumstr	tests/vrt_benchmark.c	/^    sds dbnumstr;$/;"	m	struct:config	file:
dbs	src/vr_server.h	/^    struct darray dbs;           \/* database array, type: redisDB *\/$/;"	m	struct:vr_server	typeref:struct:vr_server::darray
dbsizeCommand	src/vr_db.c	/^void dbsizeCommand(client *c) {$/;"	f
dc	tests/vrt_check_data.c	/^static data_checker dc;$/;"	v	file:
dcalloc	dep/dmalloc/dmalloc.h	45;"	d
ddt	tests/vrt_dispatch_data.c	/^    dispatch_data_thread *ddt;$/;"	m	struct:callback_data	file:
de	src/vr_server.h	/^    dictEntry *de;$/;"	m	struct:__anon19
de	src/vr_t_zset.h	/^                dictEntry *de;$/;"	m	struct:__anon8::__anon9::_iterset::__anon11
debug	src/vr_ziplist.c	1080;"	d	file:
decrCommand	src/vr_t_string.c	/^void decrCommand(client *c) {$/;"	f
decrRefCount	src/vr_object.c	/^void decrRefCount(robj *o) {$/;"	f
decrRefCountVoid	src/vr_object.c	/^void decrRefCountVoid(void *o) {$/;"	f
decr_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *decr_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
decrbyCommand	src/vr_t_string.c	/^void decrbyCommand(client *c) {$/;"	f
decrby_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *decrby_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
defaultFunctions	dep/himemcached-0.1.0/himemcached.c	/^static mcReplyObjectFunctions defaultFunctions = {$/;"	v	file:
del	src/vr_server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
delCommand	src/vr_db.c	/^void delCommand(client *c) {$/;"	f
delCommand	src/vr_server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:vr_server	typeref:struct:vr_server::redisCommand
del_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *del_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
delete_data_producer	tests/vrt_produce_data.c	/^data_producer *delete_data_producer = NULL;$/;"	v
deleting	tests/vrt_backend.c	/^    int deleting;   \/* backend thread is deleting keys *\/$/;"	m	struct:task_data	file:
deleting	tests/vrt_backend.h	/^    int deleting;$/;"	m	struct:backend_thread
destroy	dep/dlist/dmtqueue.h	/^    void (*destroy)(void *q);$/;"	m	struct:dmtqueue
destroy_check_data_threads	tests/vrt_check_data.c	/^static void destroy_check_data_threads(void)$/;"	f	file:
destroy_dir	tests/vrt_util.c	/^int destroy_dir(char *path)$/;"	f
destroy_work_dir	tests/vrt_public.c	/^int destroy_work_dir(void)$/;"	f
dfree	dep/dmalloc/dmalloc.h	51;"	d
di	src/vr_server.h	/^    dictIterator *di;$/;"	m	struct:__anon18
di	src/vr_server.h	/^    dictIterator *di;$/;"	m	struct:__anon19
di	src/vr_t_zset.h	/^                dictIterator *di;$/;"	m	struct:__anon8::__anon9::_iterset::__anon11
dict	src/vr_db.h	/^    dict *dict;                 \/* The keyspace for this DB *\/$/;"	m	struct:redisDb
dict	src/vr_dict.h	/^typedef struct dict {$/;"	s
dict	src/vr_dict.h	/^} dict;$/;"	t	typeref:struct:dict
dict	src/vr_server.h	/^    dict *dict;$/;"	m	struct:zset
dict	src/vr_t_zset.h	/^                dict *dict;$/;"	m	struct:__anon8::__anon9::_iterset::__anon11
dictAdd	src/vr_dict.c	/^int dictAdd(dict *d, void *key, void *val)$/;"	f
dictAddRaw	src/vr_dict.c	/^dictEntry *dictAddRaw(dict *d, void *key)$/;"	f
dictCompareKeys	src/vr_dict.h	99;"	d
dictConfValueDestructor	src/vr_conf.c	/^static void dictConfValueDestructor(void *privdata, void *val)$/;"	f	file:
dictCreate	src/vr_dict.c	/^dict *dictCreate(dictType *type,$/;"	f
dictDelete	src/vr_dict.c	/^int dictDelete(dict *ht, const void *key) {$/;"	f
dictDeleteNoFree	src/vr_dict.c	/^int dictDeleteNoFree(dict *ht, const void *key) {$/;"	f
dictDestructor	src/vr_conf.c	/^static void dictDestructor(void *privdata, void *val)$/;"	f	file:
dictDisableResize	src/vr_dict.c	/^void dictDisableResize(void) {$/;"	f
dictEmpty	src/vr_dict.c	/^void dictEmpty(dict *d, void(callback)(void*)) {$/;"	f
dictEnableResize	src/vr_dict.c	/^void dictEnableResize(void) {$/;"	f
dictEncObjHash	src/vr_server.c	/^dictEncObjHash(const void *key) {$/;"	f
dictEncObjKeyCompare	src/vr_server.c	/^dictEncObjKeyCompare(void *privdata, const void *key1,$/;"	f
dictEntry	src/vr_dict.h	/^typedef struct dictEntry {$/;"	s
dictEntry	src/vr_dict.h	/^} dictEntry;$/;"	t	typeref:struct:dictEntry
dictExpand	src/vr_dict.c	/^int dictExpand(dict *d, unsigned long size)$/;"	f
dictFetchValue	src/vr_dict.c	/^void *dictFetchValue(dict *d, const void *key) {$/;"	f
dictFind	src/vr_dict.c	/^dictEntry *dictFind(dict *d, const void *key)$/;"	f
dictFingerprint	src/vr_dict.c	/^long long dictFingerprint(dict *d) {$/;"	f
dictFreeKey	src/vr_dict.h	88;"	d
dictFreeVal	src/vr_dict.h	68;"	d
dictGenCaseHashFunction	src/vr_dict.c	/^unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) {$/;"	f
dictGenHashFunction	src/vr_dict.c	/^unsigned int dictGenHashFunction(const void *key, int len) {$/;"	f
dictGenericDelete	src/vr_dict.c	/^static int dictGenericDelete(dict *d, const void *key, int nofree)$/;"	f	file:
dictGetDoubleVal	src/vr_dict.h	109;"	d
dictGetHashFunctionSeed	src/vr_dict.c	/^uint32_t dictGetHashFunctionSeed(void) {$/;"	f
dictGetIterator	src/vr_dict.c	/^dictIterator *dictGetIterator(dict *d)$/;"	f
dictGetKey	src/vr_dict.h	105;"	d
dictGetRandomKey	src/vr_dict.c	/^dictEntry *dictGetRandomKey(dict *d)$/;"	f
dictGetSafeIterator	src/vr_dict.c	/^dictIterator *dictGetSafeIterator(dict *d) {$/;"	f
dictGetSignedIntegerVal	src/vr_dict.h	107;"	d
dictGetSomeKeys	src/vr_dict.c	/^unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {$/;"	f
dictGetStats	src/vr_dict.c	/^void dictGetStats(char *buf, size_t bufsize, dict *d) {$/;"	f
dictGetUnsignedIntegerVal	src/vr_dict.h	108;"	d
dictGetVal	src/vr_dict.h	106;"	d
dictHashKey	src/vr_dict.h	104;"	d
dictIntHashFunction	src/vr_dict.c	/^unsigned int dictIntHashFunction(unsigned int key)$/;"	f
dictIsRehashing	src/vr_dict.h	112;"	d
dictIterator	src/vr_dict.h	/^typedef struct dictIterator {$/;"	s
dictIterator	src/vr_dict.h	/^} dictIterator;$/;"	t	typeref:struct:dictIterator
dictListDestructor	src/vr_server.c	/^dictListDestructor(void *privdata, void *val)$/;"	f
dictNext	src/vr_dict.c	/^dictEntry *dictNext(dictIterator *iter)$/;"	f
dictObjHash	src/vr_server.c	/^dictObjHash(const void *key) {$/;"	f
dictObjKeyCompare	src/vr_server.c	/^dictObjKeyCompare(void *privdata, const void *key1,$/;"	f
dictObjectDestructor	src/vr_server.c	/^dictObjectDestructor(void *privdata, void *val)$/;"	f
dictRehash	src/vr_dict.c	/^int dictRehash(dict *d, int n) {$/;"	f
dictRehashMilliseconds	src/vr_dict.c	/^int dictRehashMilliseconds(dict *d, int ms) {$/;"	f
dictRelease	src/vr_dict.c	/^void dictRelease(dict *d)$/;"	f
dictReleaseIterator	src/vr_dict.c	/^void dictReleaseIterator(dictIterator *iter)$/;"	f
dictReplace	src/vr_dict.c	/^int dictReplace(dict *d, void *key, void *val)$/;"	f
dictReplaceRaw	src/vr_dict.c	/^dictEntry *dictReplaceRaw(dict *d, void *key) {$/;"	f
dictResize	src/vr_dict.c	/^int dictResize(dict *d)$/;"	f
dictScan	src/vr_dict.c	/^unsigned long dictScan(dict *d,$/;"	f
dictScanFunction	src/vr_dict.h	/^typedef void (dictScanFunction)(void *privdata, const dictEntry *de);$/;"	t
dictSdsCaseHash	src/vr_server.c	/^dictSdsCaseHash(const void *key) {$/;"	f
dictSdsDestructor	src/vr_server.c	/^dictSdsDestructor(void *privdata, void *val)$/;"	f
dictSdsHash	src/vr_server.c	/^dictSdsHash(const void *key) {$/;"	f
dictSdsKeyCaseCompare	src/vr_server.c	/^dictSdsKeyCaseCompare(void *privdata, const void *key1,$/;"	f
dictSdsKeyCompare	src/vr_server.c	/^dictSdsKeyCompare(void *privdata, const void *key1,$/;"	f
dictSdsKeyDupFromStr	src/vr_server.c	/^dictSdsKeyDupFromStr(void *privdata, const void *key)$/;"	f
dictSetDoubleVal	src/vr_dict.h	85;"	d
dictSetHashFunctionSeed	src/vr_dict.c	/^void dictSetHashFunctionSeed(uint32_t seed) {$/;"	f
dictSetKey	src/vr_dict.h	92;"	d
dictSetSignedIntegerVal	src/vr_dict.h	79;"	d
dictSetUnsignedIntegerVal	src/vr_dict.h	82;"	d
dictSetVal	src/vr_dict.h	72;"	d
dictSize	src/vr_dict.h	111;"	d
dictSlots	src/vr_dict.h	110;"	d
dictStrCaseHash	src/vr_server.c	/^dictStrCaseHash(const void *key) {$/;"	f
dictStrHash	src/vr_server.c	/^dictStrHash(const void *key) {$/;"	f
dictStrKeyCaseCompare	src/vr_server.c	/^dictStrKeyCaseCompare(void *privdata, const void *key1,$/;"	f
dictStrKeyCompare	src/vr_server.c	/^dictStrKeyCompare(void *privdata, const void *key1,$/;"	f
dictType	src/vr_dict.h	/^typedef struct dictType {$/;"	s
dictType	src/vr_dict.h	/^} dictType;$/;"	t	typeref:struct:dictType
dict_can_resize	src/vr_dict.c	/^static int dict_can_resize = 1;$/;"	v	file:
dict_force_resize_ratio	src/vr_dict.c	/^static unsigned int dict_force_resize_ratio = 5;$/;"	v	file:
dict_hash_function_seed	src/vr_dict.c	/^static uint32_t dict_hash_function_seed = 5381;$/;"	v	file:
dictht	src/vr_dict.h	/^typedef struct dictht {$/;"	s
dictht	src/vr_dict.h	/^} dictht;$/;"	t	typeref:struct:dictht
dictid	src/vr_client.h	/^    int dictid;             \/* ID of the currently SELECTed DB. *\/$/;"	m	struct:client
digits10	src/vr_util.c	/^uint32_t digits10(uint64_t v) {$/;"	f
digits10	tests/vrt_util.c	/^uint32_t digits10(uint64_t v) {$/;"	f
dir	src/vr_conf.h	/^    sds           dir;$/;"	m	struct:conf_server
dir	tests/vrt_public.h	/^    sds dir;$/;"	m	struct:vire_instance
direction	dep/dlist/dlist.h	/^    int direction;$/;"	m	struct:dlistIter
direction	src/vr_quicklist.h	/^    int direction;$/;"	m	struct:quicklistIter
direction	src/vr_server.h	/^    unsigned char direction; \/* Iteration direction *\/$/;"	m	struct:__anon16
dirty	src/vr_eventloop.h	/^    long long dirty;            \/* Changes to DB from the last save *\/$/;"	m	struct:vr_eventloop
dirty	src/vr_server.h	/^    long long dirty;                \/* Changes to DB from the last save *\/$/;"	m	struct:vr_server
dirty_before_bgsave	src/vr_server.h	/^    long long dirty_before_bgsave;  \/* Used to restore dirty on failed BGSAVE *\/$/;"	m	struct:vr_server
discardCommand	src/vr_multi.c	/^void discardCommand(client *c) {$/;"	f
discardTransaction	src/vr_multi.c	/^void discardTransaction(client *c) {$/;"	f
disconnectSlaves	src/vr_client.c	/^void disconnectSlaves(void) {$/;"	f
disconnect_callback	tests/vrt_backend.c	/^static void disconnect_callback(const redisAsyncContext *c, int status) {$/;"	f	file:
disconnect_callback	tests/vrt_check_data.c	/^static void disconnect_callback(const redisAsyncContext *c, int status) {$/;"	f	file:
disconnect_callback	tests/vrt_dispatch_data.c	/^static void disconnect_callback(const redisAsyncContext *c, int status) {$/;"	f	file:
dispatch_conn_context_deinit	tests/vrt_dispatch_data.c	/^static void dispatch_conn_context_deinit(conn_context *cc)$/;"	f	file:
dispatch_conn_context_init	tests/vrt_dispatch_data.c	/^static int dispatch_conn_context_init(conn_context *cc, char *host, int port)$/;"	f	file:
dispatch_conn_exist	src/vr_master.c	/^dispatch_conn_exist(client *c, int tid)$/;"	f
dispatch_conn_new	src/vr_worker.c	/^dispatch_conn_new(vr_listen *vlisten, int sd)$/;"	f
dispatch_data_thread	tests/vrt_dispatch_data.h	/^typedef struct dispatch_data_thread {$/;"	s
dispatch_data_thread	tests/vrt_dispatch_data.h	/^} dispatch_data_thread;$/;"	t	typeref:struct:dispatch_data_thread
dispatch_data_thread_cron	tests/vrt_dispatch_data.c	/^static int dispatch_data_thread_cron(aeEventLoop *eventLoop, long long id, void *clientData)$/;"	f	file:
dispatch_data_thread_deinit	tests/vrt_dispatch_data.c	/^static void dispatch_data_thread_deinit(dispatch_data_thread *ddt)$/;"	f	file:
dispatch_data_thread_init	tests/vrt_dispatch_data.c	/^static int dispatch_data_thread_init(dispatch_data_thread *ddt, char *test_target_groups, int connections)$/;"	f	file:
dispatch_data_threads	tests/vrabtest.c	/^    int dispatch_data_threads;$/;"	m	struct:config	file:
dispatch_data_threads	tests/vrt_dispatch_data.c	/^static darray *dispatch_data_threads = NULL;$/;"	v	file:
dispatch_data_threads_count	tests/vrt_dispatch_data.c	/^int dispatch_data_threads_count;$/;"	v
dispatch_thread_send_data	tests/vrt_dispatch_data.c	/^static int dispatch_thread_send_data(dispatch_data_thread *ddt)$/;"	f	file:
dispatch_threads_pause_finished_count	tests/vrt_dispatch_data.c	/^int dispatch_threads_pause_finished_count;$/;"	v
dist_strings	src/vr_conf.c	/^static char* dist_strings[] = {$/;"	v	file:
dist_type	dep/dhashkit/dhashkit.h	/^typedef enum dist_type {$/;"	g
dist_type_t	dep/dhashkit/dhashkit.h	/^} dist_type_t;$/;"	t	typeref:enum:dist_type
dlist	dep/dlist/dlist.h	/^typedef struct dlist {$/;"	s
dlist	dep/dlist/dlist.h	/^} dlist;$/;"	t	typeref:struct:dlist
dlistAddNodeHead	dep/dlist/dlist.c	/^dlist *dlistAddNodeHead(dlist *list, void *value)$/;"	f
dlistAddNodeTail	dep/dlist/dlist.c	/^dlist *dlistAddNodeTail(dlist *list, void *value)$/;"	f
dlistCreate	dep/dlist/dlist.c	/^dlist *dlistCreate(void)$/;"	f
dlistDelNode	dep/dlist/dlist.c	/^void dlistDelNode(dlist *list, dlistNode *node)$/;"	f
dlistDup	dep/dlist/dlist.c	/^dlist *dlistDup(dlist *orig)$/;"	f
dlistFirst	dep/dlist/dlist.h	28;"	d
dlistGetDupMethod	dep/dlist/dlist.h	38;"	d
dlistGetFree	dep/dlist/dlist.h	39;"	d
dlistGetIterator	dep/dlist/dlist.c	/^dlistIter *dlistGetIterator(dlist *list, int direction)$/;"	f
dlistGetMatchMethod	dep/dlist/dlist.h	40;"	d
dlistIndex	dep/dlist/dlist.c	/^dlistNode *dlistIndex(dlist *list, long index) {$/;"	f
dlistInsertNode	dep/dlist/dlist.c	/^dlist *dlistInsertNode(dlist *list, dlistNode *old_node, void *value, int after) {$/;"	f
dlistIter	dep/dlist/dlist.h	/^typedef struct dlistIter {$/;"	s
dlistIter	dep/dlist/dlist.h	/^} dlistIter;$/;"	t	typeref:struct:dlistIter
dlistLast	dep/dlist/dlist.h	29;"	d
dlistLength	dep/dlist/dlist.h	27;"	d
dlistNext	dep/dlist/dlist.c	/^dlistNode *dlistNext(dlistIter *iter)$/;"	f
dlistNextNode	dep/dlist/dlist.h	31;"	d
dlistNode	dep/dlist/dlist.h	/^typedef struct dlistNode {$/;"	s
dlistNode	dep/dlist/dlist.h	/^} dlistNode;$/;"	t	typeref:struct:dlistNode
dlistNodeValue	dep/dlist/dlist.h	32;"	d
dlistPop	dep/dlist/dlist.c	/^void *dlistPop(dlist *list) {$/;"	f
dlistPrevNode	dep/dlist/dlist.h	30;"	d
dlistPush	dep/dlist/dlist.c	/^dlist *dlistPush(dlist *list, void *value) {$/;"	f
dlistRelease	dep/dlist/dlist.c	/^void dlistRelease(dlist *list)$/;"	f
dlistReleaseIterator	dep/dlist/dlist.c	/^void dlistReleaseIterator(dlistIter *iter) {$/;"	f
dlistRewind	dep/dlist/dlist.c	/^void dlistRewind(dlist *list, dlistIter *li) {$/;"	f
dlistRewindTail	dep/dlist/dlist.c	/^void dlistRewindTail(dlist *list, dlistIter *li) {$/;"	f
dlistRotate	dep/dlist/dlist.c	/^void dlistRotate(dlist *list) {$/;"	f
dlistSearchKey	dep/dlist/dlist.c	/^dlistNode *dlistSearchKey(dlist *list, void *key)$/;"	f
dlistSetDupMethod	dep/dlist/dlist.h	34;"	d
dlistSetFreeMethod	dep/dlist/dlist.h	35;"	d
dlistSetMatchMethod	dep/dlist/dlist.h	36;"	d
dlockqueue	dep/dlist/dlockqueue.h	/^typedef struct dlockqueue{$/;"	s
dlockqueue	dep/dlist/dlockqueue.h	/^} dlockqueue;$/;"	t	typeref:struct:dlockqueue
dlockqueue_create	dep/dlist/dlockqueue.c	/^dlockqueue *dlockqueue_create(void)$/;"	f
dlockqueue_destroy	dep/dlist/dlockqueue.c	/^void dlockqueue_destroy(void *q)$/;"	f
dlockqueue_freefunc	dep/dlist/dmtqueue.h	/^typedef void (*dlockqueue_freefunc)(void *);$/;"	t
dlockqueue_length	dep/dlist/dlockqueue.c	/^long long dlockqueue_length(void *q)$/;"	f
dlockqueue_pop	dep/dlist/dlockqueue.c	/^void *dlockqueue_pop(void *q)$/;"	f
dlockqueue_push	dep/dlist/dlockqueue.c	/^long long dlockqueue_push(void *q, void *value)$/;"	f
dmalloc_size	dep/dmalloc/dmalloc.c	/^size_t dmalloc_size(void *ptr) {$/;"	f
dmalloc_size	dep/dmalloc/dmalloc.h	25;"	d
dmalloc_size	dep/dmalloc/dmalloc.h	32;"	d
dmsec_now	dep/util/dutil.c	/^dmsec_now(void)$/;"	f
dmtqueue	dep/dlist/dmtqueue.h	/^typedef struct dmtqueue{$/;"	s
dmtqueue	dep/dlist/dmtqueue.h	/^} dmtqueue;$/;"	t	typeref:struct:dmtqueue
dmtqueueSetMaxlength	dep/dlist/dmtqueue.h	17;"	d
dmtqueueSetMaxlengthPolicy	dep/dlist/dmtqueue.h	18;"	d
dmtqueue_create	dep/dlist/dmtqueue.c	/^dmtqueue *dmtqueue_create(void)$/;"	f
dmtqueue_destroy	dep/dlist/dmtqueue.c	/^void dmtqueue_destroy(dmtqueue *q)$/;"	f
dmtqueue_empty	dep/dlist/dmtqueue.c	/^int dmtqueue_empty(dmtqueue *q)$/;"	f
dmtqueue_init	dep/dlist/dmtqueue.h	/^typedef int (*dmtqueue_init)(dmtqueue *);$/;"	t
dmtqueue_init_with_lockqueue	dep/dlist/dmtqueue.c	/^int dmtqueue_init_with_lockqueue(dmtqueue *q, dlockqueue_freefunc freefunc)$/;"	f
dmtqueue_length	dep/dlist/dmtqueue.c	/^long long dmtqueue_length(dmtqueue *q)$/;"	f
dmtqueue_pop	dep/dlist/dmtqueue.c	/^void *dmtqueue_pop(dmtqueue *q)$/;"	f
dmtqueue_push	dep/dlist/dmtqueue.c	/^long long dmtqueue_push(dmtqueue *q, void *value)$/;"	f
done	src/vr_connection.h	/^    unsigned            done:1;          \/* done? aka close? *\/$/;"	m	struct:conn
dp	tests/vrt_produce_data.h	/^    data_producer *dp;$/;"	m	struct:data_unit
drealloc	dep/dmalloc/dmalloc.h	48;"	d
dsafe_snprintf	dep/util/dutil.h	81;"	d
dsafe_vsnprintf	dep/util/dutil.h	84;"	d
dscnprintf	dep/util/dutil.h	104;"	d
dsec_now	dep/util/dutil.c	/^dsec_now(void)$/;"	f
dsnprintf	dep/util/dutil.h	101;"	d
dstacktrace	dep/util/dutil.c	/^dstacktrace(int skip_count)$/;"	f
dstacktrace_fd	dep/util/dutil.c	/^dstacktrace_fd(int fd)$/;"	f
dstrftime	dep/util/dutil.h	113;"	d
du	tests/vrt_dispatch_data.c	/^    data_unit *du;$/;"	m	struct:reply_unit	file:
dup	dep/dlist/dlist.h	/^    void *(*dup)(void *ptr);$/;"	m	struct:dlist
dupClientReplyValue	src/vr_client.c	/^void *dupClientReplyValue(void *o) {$/;"	f
dupLastObjectIfNeeded	src/vr_client.c	/^robj *dupLastObjectIfNeeded(dlist *reply) {$/;"	f
dupStringObject	src/vr_object.c	/^robj *dupStringObject(robj *o) {$/;"	f
dupStringObjectUnconstant	src/vr_object.c	/^robj *dupStringObjectUnconstant(robj *o) {$/;"	f
duration	src/vr_slowlog.h	/^    long long duration; \/* Time spent by the query, in nanoseconds. *\/$/;"	m	struct:slowlogEntry
dusec_now	dep/util/dutil.c	/^dusec_now(void)$/;"	f
dvscnprintf	dep/util/dutil.h	110;"	d
dvsnprintf	dep/util/dutil.h	107;"	d
dzalloc	dep/dmalloc/dmalloc.h	42;"	d
echoCommand	src/vr_server.c	/^void echoCommand(client *c) {$/;"	f
el	src/vr_eventloop.h	/^    aeEventLoop *el;$/;"	m	struct:vr_eventloop
el	src/vr_server.h	/^    aeEventLoop *el;$/;"	m	struct:vr_server
el	tests/vrt_backend.h	/^    struct aeEventLoop *el;$/;"	m	struct:backend_thread	typeref:struct:backend_thread::aeEventLoop
el	tests/vrt_benchmark.c	/^    struct aeEventLoop *el;$/;"	m	struct:benchmark_thread	typeref:struct:benchmark_thread::aeEventLoop	file:
el	tests/vrt_check_data.c	/^    aeEventLoop *el;$/;"	m	struct:check_data_thread	file:
el	tests/vrt_check_data.c	/^    aeEventLoop *el;$/;"	m	struct:data_checker	file:
el	tests/vrt_dispatch_data.h	/^    struct aeEventLoop *el;$/;"	m	struct:dispatch_data_thread	typeref:struct:dispatch_data_thread::aeEventLoop
ele	src/vr_t_zset.h	/^    robj *ele;$/;"	m	struct:__anon14
elem	dep/darray/darray.h	/^    void                 *elem;  \/* element *\/$/;"	m	struct:darray
element	dep/himemcached-0.1.0/himcread.h	/^    void **element; \/* Temporary reply array *\/$/;"	m	struct:mcReader
element	dep/himemcached-0.1.0/himemcached.h	/^    struct mcReply **element; \/* elements vector for MC_REPLY_ARRAY *\/$/;"	m	struct:mcReply	typeref:struct:mcReply::mcReply
elementArrayAdd	dep/himemcached-0.1.0/himcread.c	/^static int elementArrayAdd(mcReader *r, void *reply)$/;"	f	file:
elementArrayCreate	dep/himemcached-0.1.0/himcread.c	/^static int elementArrayCreate(mcReader *r)$/;"	f	file:
elementArrayDestroy	dep/himemcached-0.1.0/himcread.c	/^static void elementArrayDestroy(mcReader *r)$/;"	f	file:
elementArrayExpand	dep/himemcached-0.1.0/himcread.c	/^static int elementArrayExpand(mcReader *r) $/;"	f	file:
element_cmp_multi_step	tests/vrt_public.c	/^static int element_cmp_multi_step(const void *ele1,const void *ele2)$/;"	f	file:
elements	dep/himemcached-0.1.0/himcread.h	/^    size_t elements; \/* Temporary reply array length *\/$/;"	m	struct:mcReader
elements	dep/himemcached-0.1.0/himemcached.h	/^    size_t elements; \/* number of elements, for MC_REPLY_ARRAY *\/$/;"	m	struct:mcReply
elen	src/vr_t_zset.h	/^    unsigned int elen;$/;"	m	struct:__anon14
ell	src/vr_t_zset.h	/^    long long ell;$/;"	m	struct:__anon14
emptyDb	src/vr_db.c	/^long long emptyDb(void(callback)(void*)) {$/;"	f
emptybulk	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
emptymultibulk	src/vr_server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
emptyscan	src/vr_server.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct
encoding	src/vr_hyperloglog.c	/^    uint8_t encoding;   \/* HLL_DENSE or HLL_SPARSE. *\/$/;"	m	struct:hllhdr	file:
encoding	src/vr_intset.h	/^    uint32_t encoding;$/;"	m	struct:intset
encoding	src/vr_object.h	/^    unsigned encoding:4;$/;"	m	struct:vr_object
encoding	src/vr_quicklist.h	/^    unsigned int encoding : 2;   \/* RAW==1 or LZF==2 *\/$/;"	m	struct:quicklistNode
encoding	src/vr_server.h	/^    int encoding;$/;"	m	struct:__anon18
encoding	src/vr_server.h	/^    int encoding;$/;"	m	struct:__anon19
encoding	src/vr_server.h	/^    unsigned char encoding;$/;"	m	struct:__anon16
encoding	src/vr_t_zset.h	/^    int encoding;$/;"	m	struct:__anon8
encoding	src/vr_ziplist.c	/^    unsigned char encoding;$/;"	m	struct:zlentry	file:
end_check_data	tests/vrt_check_data.c	/^static void end_check_data(void)$/;"	f	file:
entry	src/vr_dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
entry	src/vr_server.h	/^    quicklistEntry entry; \/* Entry in quicklist *\/$/;"	m	struct:__anon17
eof	src/vr_connection.h	/^    unsigned            eof:1;           \/* eof? aka passive close? *\/$/;"	m	struct:conn
epfd	dep/ae/ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:
eptr	src/vr_t_zset.h	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon8::__anon9::_iterzset::__anon12
equalStringObjects	src/vr_object.c	/^int equalStringObjects(robj *a, robj *b) {$/;"	f
err	dep/himemcached-0.1.0/himcread.h	/^    int err; \/* Error flags, 0 when there is no error *\/$/;"	m	struct:mcReader
err	dep/himemcached-0.1.0/himemcached.h	/^    int err; \/* Error flags, 0 when there is no error *\/$/;"	m	struct:mcContext
err	src/vr_connection.h	/^    err_t               err;             \/* connection errno *\/$/;"	m	struct:conn
err	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
err_t	src/vr_core.h	/^typedef int err_t;      \/* error type *\/$/;"	t
errmsg	tests/vrt_simple.c	/^static char errmsg[ERRMSG_MAX_LEN];$/;"	v	file:
errstr	dep/himemcached-0.1.0/himcread.h	/^    char errstr[128]; \/* String representation of error when applicable *\/$/;"	m	struct:mcReader
errstr	dep/himemcached-0.1.0/himemcached.h	/^    char errstr[128]; \/* String representation of error when applicable *\/$/;"	m	struct:mcContext
estimateObjectIdleTime	src/vr_object.c	/^unsigned long long estimateObjectIdleTime(robj *o) {$/;"	f
estr	src/vr_t_zset.h	/^    unsigned char *estr;$/;"	m	struct:__anon14
evalGetKeys	src/vr_db.c	/^int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f
events	dep/ae/ae.h	/^    aeFileEvent *events; \/* Registered events *\/$/;"	m	struct:aeEventLoop
events	dep/ae/ae_epoll.c	/^    struct epoll_event *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:
events	dep/ae/ae_kqueue.c	/^    struct kevent *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:
evictedkeys	src/vr_stats.h	/^    long long evictedkeys;     \/* Number of evicted keys (maxmemory) *\/$/;"	m	struct:vr_stats
evictionPoolAlloc	src/vr_db.c	/^static struct evictionPoolEntry *evictionPoolAlloc(void) {$/;"	f	file:
evictionPoolEntry	src/vr_db.h	/^struct evictionPoolEntry {$/;"	s
evictionPoolPopulate	src/vr_server.c	/^void evictionPoolPopulate(dict *sampledict, dict *keydict, $/;"	f
eviction_pool	src/vr_db.h	/^    struct evictionPoolEntry *eviction_pool;    \/* Eviction pool of keys *\/$/;"	m	struct:redisDb	typeref:struct:redisDb::evictionPoolEntry
evictpolicy_strings	src/vr_conf.c	/^static char* evictpolicy_strings[] = {$/;"	v	file:
evictpolicy_type	src/vr_conf.h	/^typedef enum evictpolicy_type {$/;"	g
evictpolicy_type_t	src/vr_conf.h	/^} evictpolicy_type_t;$/;"	t	typeref:enum:evictpolicy_type
evport_debug	dep/ae/ae_evport.c	/^static int evport_debug = 0;$/;"	v	file:
execCommand	src/vr_multi.c	/^void execCommand(client *c) {$/;"	f
execCommand	src/vr_server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	struct:vr_server	typeref:struct:vr_server::
execaborterr	src/vr_server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noadminerr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
executable	src/vr_server.h	/^    char *executable;           \/* Absolute executable file path. *\/$/;"	m	struct:vr_server
execute_file	tests/vrt_public.c	/^static char *execute_file = VIRE_TEST_CONFIG_DEFAULT_EXECUTE_FILE;$/;"	v	file:
existsCommand	src/vr_db.c	/^void existsCommand(client *c) {$/;"	f
exists_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *exists_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
expect	src/vr_lzf_c.c	43;"	d	file:
expect	src/vr_lzf_c.c	46;"	d	file:
expect_false	src/vr_lzf_c.c	50;"	d	file:
expect_true	src/vr_lzf_c.c	51;"	d	file:
expireCommand	src/vr_db.c	/^void expireCommand(client *c) {$/;"	f
expireGenericCommand	src/vr_db.c	/^void expireGenericCommand(client *c, long long basetime, int unit) {$/;"	f
expireIfNeeded	src/vr_db.c	/^int expireIfNeeded(redisDb *db, robj *key) {$/;"	f
expire_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *expire_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
expire_enabled	tests/vrabtest.c	/^int expire_enabled;$/;"	v
expireatCommand	src/vr_db.c	/^void expireatCommand(client *c) {$/;"	f
expireat_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *expireat_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
expiredkeys	src/vr_stats.h	/^    long long expiredkeys;     \/* Number of expired keys *\/$/;"	m	struct:vr_stats
expires	src/vr_db.h	/^    dict *expires;              \/* Timeout of keys with a timeout set *\/$/;"	m	struct:redisDb
extra	src/vr_quicklist.h	/^    unsigned int extra : 10; \/* more bits to steal for future usage *\/$/;"	m	struct:quicklistNode
family	src/vr_util.h	/^    int       family;              \/* socket address family *\/$/;"	m	struct:sockinfo
fcmp	tests/vrt_public.c	/^    int (*fcmp)(const void *,const void *);$/;"	m	struct:sort_unit	file:
fd	dep/ae/ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent
fd	dep/himemcached-0.1.0/himemcached.h	/^    int fd;$/;"	m	struct:mcContext
fd	dep/util/dlog.h	/^    int  fd;     \/* log file descriptor *\/$/;"	m	struct:logger
feedAppendOnlyFile	src/vr_aof.c	/^void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {$/;"	f
feedReplicationBacklog	src/vr_replication.c	/^void feedReplicationBacklog(void *ptr, size_t len) {$/;"	f
feedReplicationBacklogWithObject	src/vr_replication.c	/^void feedReplicationBacklogWithObject(robj *o) {$/;"	f
fetchInternalDbById	src/vr_db.c	/^int fetchInternalDbById(client *c, int idx) {$/;"	f
fetchInternalDbByKey	src/vr_db.c	/^int fetchInternalDbByKey(client *c, robj *key) {$/;"	f
field	tests/vrt_simple.c	/^    char *field;$/;"	m	struct:test_hash_member	file:
field_length_max	tests/vrt_produce_data.c	/^static unsigned int field_length_max;$/;"	v	file:
fields	tests/vrt_public.c	/^    void **fields;$/;"	m	struct:sort_unit	file:
fields_max_count	tests/vrabtest.c	/^    int fields_max_count;$/;"	m	struct:config	file:
fill	src/vr_quicklist.h	/^    int fill : 16;              \/* fill factor for individual nodes *\/$/;"	m	struct:quicklist
final	dep/dhashkit/djenkins.c	17;"	d	file:
finalizerProc	dep/ae/ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent
fingerprint	src/vr_dict.h	/^    long long fingerprint;$/;"	m	struct:dictIterator
fired	dep/ae/ae.h	/^    aeFiredEvent *fired; \/* Fired events *\/$/;"	m	struct:aeEventLoop
firstkey	src/vr_command.h	/^    int firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	struct:redisCommand
firstkey	tests/vrt_produce_data.h	/^    int firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	struct:data_producer
flagTransaction	src/vr_multi.c	/^void flagTransaction(client *c) {$/;"	f
flags	dep/himemcached-0.1.0/himemcached.h	/^    int flags;$/;"	m	struct:mcContext
flags	dep/himemcached-0.1.0/himemcached.h	/^    int flags;$/;"	m	struct:mcReply
flags	dep/sds/sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr16
flags	dep/sds/sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr32
flags	dep/sds/sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr64
flags	dep/sds/sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	struct:sdshdr8
flags	dep/sds/sds.h	/^    unsigned char flags; \/* 3 lsb of type, and 5 msb of string length *\/$/;"	m	struct:sdshdr5
flags	src/vr_client.h	/^    int flags;              \/* Client flags: CLIENT_* macros. *\/$/;"	m	struct:client
flags	src/vr_command.h	/^    int flags;    \/* The actual flags, obtained from the 'sflags' field. *\/$/;"	m	struct:redisCommand
flags	src/vr_conf.h	/^    int     flags;      \/* option flags *\/$/;"	m	struct:conf_option
flags	src/vr_signal.h	/^    int  flags;$/;"	m	struct:signal
flags	src/vr_t_zset.h	/^    int flags;$/;"	m	struct:__anon14
flags	tests/vrt_check_data.c	/^    int flags;$/;"	m	struct:data_checker	file:
flags	tests/vrt_produce_data.h	/^    int flags;    \/* The actual flags, obtained from the 'sflags' field. *\/$/;"	m	struct:data_producer
flock	src/vr_conf.h	/^    pthread_mutex_t flock;           \/* config file lock *\/$/;"	m	struct:vr_conf
flushSlavesOutputBuffers	src/vr_client.c	/^void flushSlavesOutputBuffers(void) {$/;"	f
flushallCommand	src/vr_db.c	/^void flushallCommand(client *c) {$/;"	f
flushdbCommand	src/vr_db.c	/^void flushdbCommand(client *c) {$/;"	f
fn	dep/himemcached-0.1.0/himcread.h	/^    mcReplyObjectFunctions *fn;$/;"	m	struct:mcReader
fname	src/vr_conf.h	/^    sds           fname;             \/* file name , absolute path *\/$/;"	m	struct:vr_conf
forceCommandPropagation	src/vr_command.c	/^void forceCommandPropagation(client *c, int flags) {$/;"	f
forward	src/vr_server.h	/^        struct zskiplistNode *forward;$/;"	m	struct:zskiplistNode::zskiplistLevel	typeref:struct:zskiplistNode::zskiplistLevel::zskiplistNode
fptr	src/vr_server.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon19
free	dep/dlist/dlist.h	/^    void (*free)(void *ptr);$/;"	m	struct:dlist
free	dep/himemcached-0.1.0/himcdep/sds.h	/^    int free;$/;"	m	struct:sdshdr
free	src/vr_aof.h	/^    unsigned long used, free;$/;"	m	struct:aofrwblock
freeAllClients	tests/vrt_benchmark.c	/^static void freeAllClients(dlist *clients) {$/;"	f	file:
freeClient	src/vr_client.c	/^void freeClient(client *c) {$/;"	f
freeClient	tests/vrt_benchmark.c	/^static void freeClient(benchmark_client c) {$/;"	f	file:
freeClientArgv	src/vr_client.c	/^static void freeClientArgv(client *c) {$/;"	f	file:
freeClientAsync	src/vr_client.c	/^void freeClientAsync(client *c) {$/;"	f
freeClientMultiState	src/vr_multi.c	/^void freeClientMultiState(client *c) {$/;"	f
freeClientReplyValue	src/vr_client.c	/^void freeClientReplyValue(void *o) {$/;"	f
freeClientsInAsyncFreeQueue	src/vr_client.c	/^void freeClientsInAsyncFreeQueue(vr_eventloop *vel) {$/;"	f
freeHashObject	src/vr_object.c	/^void freeHashObject(robj *o) {$/;"	f
freeListObject	src/vr_object.c	/^void freeListObject(robj *o) {$/;"	f
freeMcReplyObject	dep/himemcached-0.1.0/himemcached.c	/^void freeMcReplyObject(void *reply) {$/;"	f
freeMemoryIfNeeded	src/vr_server.c	/^int freeMemoryIfNeeded(vr_eventloop *vel) {$/;"	f
freeObject	dep/himemcached-0.1.0/himcread.h	/^    void (*freeObject)(void*);$/;"	m	struct:mcReplyObjectFunctions
freeObject	src/vr_object.c	/^void freeObject(robj *o) {$/;"	f
freeObjectVoid	src/vr_object.c	/^void freeObjectVoid(void *o) {$/;"	f
freeSetObject	src/vr_object.c	/^void freeSetObject(robj *o) {$/;"	f
freeStringObject	src/vr_object.c	/^void freeStringObject(robj *o) {$/;"	f
freeZsetObject	src/vr_object.c	/^void freeZsetObject(robj *o) {$/;"	f
free_connq	src/vr_connection.h	/^    dlist *free_connq;           \/* free conn q *\/$/;"	m	struct:conn_base
fun_run	src/vr_thread.h	/^    vr_thread_func_t fun_run;$/;"	m	struct:vr_thread
genClientPeerId	src/vr_client.c	/^void genClientPeerId(client *client, char *peerid,$/;"	f
genVireInfoString	src/vr_server.c	/^sds genVireInfoString(vr_eventloop *vel, char *section) {$/;"	f
genericHgetallCommand	src/vr_t_hash.c	/^void genericHgetallCommand(client *c, int flags) {$/;"	f
genericMemcachedCommand	dep/himemcached-0.1.0/himemcached.c	/^static int genericMemcachedCommand(int cmdtype, char *cmd, int argtype, int argc, char **argv, size_t *argvlen)$/;"	f	file:
genericZrangebylexCommand	src/vr_t_zset.c	/^void genericZrangebylexCommand(client *c, int reverse) {$/;"	f
genericZrangebyscoreCommand	src/vr_t_zset.c	/^void genericZrangebyscoreCommand(client *c, int reverse) {$/;"	f
get	src/vr_conf.h	/^    int     (*get)(void *cf, struct conf_option *opt, void *data);$/;"	m	struct:conf_option
get16bits	dep/dhashkit/dhsieh.c	3;"	d	file:
get16bits	dep/dhashkit/dhsieh.c	5;"	d	file:
get16bits	dep/dhashkit/dhsieh.c	9;"	d	file:
getAbsolutePath	src/vr_util.c	/^sds getAbsolutePath(char *filename) {$/;"	f
getAbsolutePath	tests/vrt_util.c	/^sds getAbsolutePath(char *filename) {$/;"	f
getAllClientsInfoString	src/vr_client.c	/^sds getAllClientsInfoString(vr_eventloop *vel) {$/;"	f
getBitOffsetFromArgument	src/vr_bitops.c	/^int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int bits) {$/;"	f
getBitfieldTypeFromArgument	src/vr_bitops.c	/^int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {$/;"	f
getClientOutputBufferMemoryUsage	src/vr_client.c	/^unsigned long getClientOutputBufferMemoryUsage(client *c) {$/;"	f
getClientPeerId	src/vr_client.c	/^char *getClientPeerId(client *c) {$/;"	f
getClientType	src/vr_client.c	/^int getClientType(client *c) {$/;"	f
getClientTypeByName	src/vr_client.c	/^int getClientTypeByName(char *name) {$/;"	f
getClientTypeName	src/vr_client.c	/^char *getClientTypeName(int class) {$/;"	f
getClientsMaxBuffers	src/vr_client.c	/^void getClientsMaxBuffers(vr_eventloop *vel, unsigned long *longest_output_list,$/;"	f
getCommand	src/vr_t_string.c	/^void getCommand(client *c) {$/;"	f
getDecodedObject	src/vr_object.c	/^robj *getDecodedObject(robj *o) {$/;"	f
getDoubleFromObject	src/vr_object.c	/^int getDoubleFromObject(robj *o, double *target) {$/;"	f
getDoubleFromObjectOrReply	src/vr_object.c	/^int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {$/;"	f
getExpire	src/vr_db.c	/^long long getExpire(redisDb *db, robj *key) {$/;"	f
getGenericCommand	src/vr_t_string.c	/^int getGenericCommand(client *c) {$/;"	f
getInstantaneousMetric	src/vr_stats.c	/^long long getInstantaneousMetric(vr_stats *stats, int metric) {$/;"	f
getKeysFreeResult	src/vr_db.c	/^void getKeysFreeResult(int *result) {$/;"	f
getKeysFromCommand	src/vr_db.c	/^int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f
getKeysUsingCommandTable	src/vr_db.c	/^int *getKeysUsingCommandTable(struct redisCommand *cmd,robj **argv, int argc, int *numkeys) {$/;"	f
getLRUClock	src/vr_server.c	/^unsigned int getLRUClock(void) {$/;"	f
getLongDoubleFromObject	src/vr_object.c	/^int getLongDoubleFromObject(robj *o, long double *target) {$/;"	f
getLongDoubleFromObjectOrReply	src/vr_object.c	/^int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg) {$/;"	f
getLongFromObjectOrReply	src/vr_object.c	/^int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {$/;"	f
getLongLongFromObject	src/vr_object.c	/^int getLongLongFromObject(robj *o, long long *target) {$/;"	f
getLongLongFromObjectOrReply	src/vr_object.c	/^int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg) {$/;"	f
getReplyFromReader	dep/himemcached-0.1.0/himcread.c	/^static void *getReplyFromReader(mcReader *r)$/;"	f	file:
getRequestTypeFromString	dep/himemcached-0.1.0/himemcached.c	/^static int getRequestTypeFromString(char *str, size_t len)$/;"	f	file:
getSignedBitfield	src/vr_bitops.c	/^int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {$/;"	f
getStringObjectSdsUsedMemory	src/vr_object.c	/^size_t getStringObjectSdsUsedMemory(robj *o) {$/;"	f
getTimeoutFromObjectOrReply	src/vr_block.c	/^int getTimeoutFromObjectOrReply(client *c, robj *object, long long *timeout, int unit) {$/;"	f
getUnsignedBitfield	src/vr_bitops.c	/^uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {$/;"	f
get_backend_server	tests/vrabtest.c	/^abtest_server *get_backend_server(abtest_group *abg, char *key, size_t keylen)$/;"	f
get_backend_server	tests/vrabtest.h	/^    backend_server_t        get_backend_server;$/;"	m	struct:abtest_group
get_backend_server_idx	tests/vrabtest.c	/^unsigned int get_backend_server_idx(abtest_group *abg, char *key, size_t keylen)$/;"	f
get_backend_server_idx	tests/vrabtest.h	/^    backend_server_idx_t    get_backend_server_idx;$/;"	m	struct:abtest_group
get_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *get_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
get_evictpolicy_strings	src/vr_conf.c	/^get_evictpolicy_strings(int evictpolicy_type)$/;"	f
get_host_port_from_address_string	tests/vrt_util.c	/^sds get_host_port_from_address_string(char *address, int *port)$/;"	f
get_kcp_idx	tests/vrt_produce_data.c	/^static unsigned int get_kcp_idx(int type)$/;"	f	file:
get_key_type_string	tests/vrt_public.c	/^get_key_type_string(int keytype)$/;"	f
get_keys_from_data_producer	tests/vrt_produce_data.c	/^int *get_keys_from_data_producer(data_producer *dp, sds *argv, int argc, int *numkeys) {$/;"	f
get_keys_using_data_producer_table	tests/vrt_produce_data.c	/^static int *get_keys_using_data_producer_table(data_producer *dp,sds *argv, int argc, int *numkeys) {$/;"	f	file:
get_longlong_from_info_reply	tests/vrt_public.c	/^long long get_longlong_from_info_reply(redisReply *reply, char *name)$/;"	f
get_next_port	tests/vrt_public.c	/^static int get_next_port(void)$/;"	f	file:
get_one_key_from_data_unit	tests/vrt_produce_data.c	/^sds get_one_key_from_data_unit(data_unit *du)$/;"	f
get_pid_from_reply	tests/vrt_util.c	/^int get_pid_from_reply(redisContext *redisctx, char *host, int port)$/;"	f
get_random_cached_key	tests/vrt_produce_data.c	/^static sds get_random_cached_key(produce_scheme *ps, data_producer *dp)$/;"	f	file:
get_random_char	tests/vrt_produce_data.c	/^static char get_random_char(void)$/;"	f	file:
get_random_field_len	tests/vrt_produce_data.c	/^static unsigned int get_random_field_len(void)$/;"	f	file:
get_random_float_str	tests/vrt_produce_data.c	/^static sds get_random_float_str(void)$/;"	f	file:
get_random_hex_chars	src/vr_util.c	/^get_random_hex_chars(char *p, unsigned int len) {$/;"	f
get_random_int	tests/vrt_produce_data.c	/^static int get_random_int(void)$/;"	f	file:
get_random_key	tests/vrt_produce_data.c	/^static sds get_random_key(void)$/;"	f	file:
get_random_key_with_hit_ratio	tests/vrt_produce_data.c	/^static sds get_random_key_with_hit_ratio(produce_scheme *ps, data_producer *dp)$/;"	f	file:
get_random_string	tests/vrt_produce_data.c	/^static sds get_random_string(void)$/;"	f	file:
get_random_unsigned_int	tests/vrt_produce_data.c	/^static unsigned int get_random_unsigned_int(void)$/;"	f	file:
get_random_zset_range_min_max_str	tests/vrt_produce_data.c	/^static sds *get_random_zset_range_min_max_str(int range_type)$/;"	f	file:
get_range_from_string	tests/vrt_util.c	/^long long *get_range_from_string(char *str, size_t len, int *count)$/;"	f
get_total_reply_err_count_per_cycle	tests/vrt_dispatch_data.c	/^long long get_total_reply_err_count_per_cycle(void)$/;"	f
get_total_tested_commands_count_per_cycle	tests/vrt_dispatch_data.c	/^long long get_total_tested_commands_count_per_cycle(void)$/;"	f
getbitCommand	src/vr_bitops.c	/^void getbitCommand(client *c) {$/;"	f
getbit_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *getbit_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
getkeys_proc	src/vr_command.h	/^    redisGetKeysProc *getkeys_proc;$/;"	m	struct:redisCommand
getkeys_proc	tests/vrt_produce_data.h	/^    redis_get_keys_proc *getkeys_proc;$/;"	m	struct:data_producer
getrangeCommand	src/vr_t_string.c	/^void getrangeCommand(client *c) {$/;"	f
getrange_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *getrange_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
getsetCommand	src/vr_t_string.c	/^void getsetCommand(client *c) {$/;"	f
getset_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *getset_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
handleClientsBlockedOnLists	src/vr_t_list.c	/^void handleClientsBlockedOnLists(void) {$/;"	f
handleClientsWithPendingWrites	src/vr_client.c	/^int handleClientsWithPendingWrites(vr_eventloop *vel) {$/;"	f
handler	src/vr_signal.h	/^    void (*handler)(int signo);$/;"	m	struct:signal
hard_limit_bytes	src/vr_client.h	/^    unsigned long long hard_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig
has_tail	src/vr_conf.c	/^    int has_tail;         \/* True if we already added directives that were$/;"	m	struct:rewriteConfigState	file:
hashDictType	src/vr_server.c	/^dictType hashDictType = {$/;"	v
hashFunction	src/vr_dict.h	/^    unsigned int (*hashFunction)(const void *key);$/;"	m	struct:dictType
hashTypeConvert	src/vr_t_hash.c	/^void hashTypeConvert(robj *o, int enc) {$/;"	f
hashTypeConvertZiplist	src/vr_t_hash.c	/^void hashTypeConvertZiplist(robj *o, int enc) {$/;"	f
hashTypeCurrentFromHashTable	src/vr_t_hash.c	/^void hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what, robj **dst) {$/;"	f
hashTypeCurrentFromZiplist	src/vr_t_hash.c	/^void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,$/;"	f
hashTypeCurrentObject	src/vr_t_hash.c	/^robj *hashTypeCurrentObject(hashTypeIterator *hi, int what) {$/;"	f
hashTypeDelete	src/vr_t_hash.c	/^int hashTypeDelete(robj *o, robj *field) {$/;"	f
hashTypeExists	src/vr_t_hash.c	/^int hashTypeExists(robj *o, robj *field) {$/;"	f
hashTypeGetFromHashTable	src/vr_t_hash.c	/^int hashTypeGetFromHashTable(robj *o, robj *field, robj **value) {$/;"	f
hashTypeGetFromZiplist	src/vr_t_hash.c	/^int hashTypeGetFromZiplist(robj *o, robj *field,$/;"	f
hashTypeGetObject	src/vr_t_hash.c	/^robj *hashTypeGetObject(robj *o, robj *field) {$/;"	f
hashTypeGetValueLength	src/vr_t_hash.c	/^size_t hashTypeGetValueLength(robj *o, robj *field) {$/;"	f
hashTypeInitIterator	src/vr_t_hash.c	/^hashTypeIterator *hashTypeInitIterator(robj *subject) {$/;"	f
hashTypeIterator	src/vr_server.h	/^} hashTypeIterator;$/;"	t	typeref:struct:__anon19
hashTypeLength	src/vr_t_hash.c	/^unsigned long hashTypeLength(robj *o) {$/;"	f
hashTypeLookupWriteOrCreate	src/vr_t_hash.c	/^robj *hashTypeLookupWriteOrCreate(client *c, robj *key, int *expired) {$/;"	f
hashTypeNext	src/vr_t_hash.c	/^int hashTypeNext(hashTypeIterator *hi) {$/;"	f
hashTypeReleaseIterator	src/vr_t_hash.c	/^void hashTypeReleaseIterator(hashTypeIterator *hi) {$/;"	f
hashTypeSet	src/vr_t_hash.c	/^int hashTypeSet(robj *o, robj *field, robj *value) {$/;"	f
hashTypeTryConversion	src/vr_t_hash.c	/^void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {$/;"	f
hashTypeTryObjectEncoding	src/vr_t_hash.c	/^void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2) {$/;"	f
hash_crc16	dep/dhashkit/dcrc16.c	/^hash_crc16(const char *key, size_t key_length)$/;"	f
hash_crc32	dep/dhashkit/dcrc32.c	/^hash_crc32(const char *key, size_t key_length)$/;"	f
hash_crc32a	dep/dhashkit/dcrc32.c	/^hash_crc32a(const char *key, size_t key_length)$/;"	f
hash_fnv1_32	dep/dhashkit/dfnv.c	/^hash_fnv1_32(const char *key, size_t key_length)$/;"	f
hash_fnv1_64	dep/dhashkit/dfnv.c	/^hash_fnv1_64(const char *key, size_t key_length)$/;"	f
hash_fnv1a_32	dep/dhashkit/dfnv.c	/^hash_fnv1a_32(const char *key, size_t key_length)$/;"	f
hash_fnv1a_64	dep/dhashkit/dfnv.c	/^hash_fnv1a_64(const char *key, size_t key_length)$/;"	f
hash_hsieh	dep/dhashkit/dhsieh.c	/^hash_hsieh(const char *key, size_t key_length)$/;"	f
hash_jenkins	dep/dhashkit/djenkins.c	/^hash_jenkins(const char *key, size_t length)$/;"	f
hash_max_ziplist_entries	src/vr_server.h	/^    size_t hash_max_ziplist_entries;$/;"	m	struct:vr_server
hash_max_ziplist_value	src/vr_server.h	/^    size_t hash_max_ziplist_value;$/;"	m	struct:vr_server
hash_md5	dep/dhashkit/dmd5.c	/^hash_md5(const char *key, size_t key_length)$/;"	f
hash_murmur	dep/dhashkit/dmurmur.c	/^hash_murmur(const char *key, size_t length)$/;"	f
hash_one_at_a_time	dep/dhashkit/done_at_a_time.c	/^hash_one_at_a_time(const char *key, size_t key_length)$/;"	f
hash_strings	src/vr_conf.c	/^static char* hash_strings[] = {$/;"	v	file:
hash_type	dep/dhashkit/dhashkit.h	/^typedef enum hash_type {$/;"	g
hash_type_t	dep/dhashkit/dhashkit.h	/^} hash_type_t;$/;"	t	typeref:enum:hash_type
hashmask	dep/dhashkit/djenkins.c	4;"	d	file:
hashsize	dep/dhashkit/djenkins.c	3;"	d	file:
hashvalue	tests/vrt_produce_data.h	/^    unsigned int hashvalue;$/;"	m	struct:data_unit
hdelCommand	src/vr_t_hash.c	/^void hdelCommand(client *c) {$/;"	f
hdel_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hdel_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
head	dep/dlist/dlist.h	/^    dlistNode *head;$/;"	m	struct:dlist
head	src/vr_quicklist.h	/^    quicklistNode *head;$/;"	m	struct:quicklist
header	src/vr_server.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::zskiplistNode
headersize	src/vr_ziplist.c	/^    unsigned int headersize;$/;"	m	struct:zlentry	file:
hex_digit_to_int	dep/himemcached-0.1.0/himcdep/sds.c	/^int hex_digit_to_int(char c) {$/;"	f
hex_digit_to_int	dep/sds/sds.c	/^int hex_digit_to_int(char c) {$/;"	f
hexistsCommand	src/vr_t_hash.c	/^void hexistsCommand(client *c) {$/;"	f
hexists_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hexists_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hgetCommand	src/vr_t_hash.c	/^void hgetCommand(client *c) {$/;"	f
hget_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hget_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hgetallCommand	src/vr_t_hash.c	/^void hgetallCommand(client *c) {$/;"	f
hgetall_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hgetall_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hi	dep/dhashkit/dmd5.c	/^    MD5_u32plus lo, hi;$/;"	m	struct:__anon2	file:
hincrbyCommand	src/vr_t_hash.c	/^void hincrbyCommand(client *c) {$/;"	f
hincrby_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hincrby_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hincrbyfloatCommand	src/vr_t_hash.c	/^void hincrbyfloatCommand(client *c) {$/;"	f
hincrbyfloat_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hincrbyfloat_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hit_ratio	tests/vrabtest.c	/^    int hit_ratio;$/;"	m	struct:config	file:
hit_ratio	tests/vrt_produce_data.h	/^    int hit_ratio;   \/* Hit ratio for the read commands. [0%,100%] *\/$/;"	m	struct:produce_scheme
hit_ratio_array	tests/vrt_produce_data.h	/^    int *hit_ratio_array;    \/* Stored 0 or 1 for every element, 1 means used key in the cached keys array. *\/$/;"	m	struct:produce_scheme
hit_ratio_array_len	tests/vrt_produce_data.h	/^    int hit_ratio_array_len; \/* 100 usually *\/$/;"	m	struct:produce_scheme
hit_ratio_idx	tests/vrt_produce_data.h	/^    int hit_ratio_idx;   \/* [0,hit_ratio_array_len-1] *\/$/;"	m	struct:produce_scheme
hkeysCommand	src/vr_t_hash.c	/^void hkeysCommand(client *c) {$/;"	f
hkeys_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hkeys_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hlenCommand	src/vr_t_hash.c	/^void hlenCommand(client *c) {$/;"	f
hlen_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hlen_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hllAdd	src/vr_hyperloglog.c	/^int hllAdd(robj *o, unsigned char *ele, size_t elesize) {$/;"	f
hllCount	src/vr_hyperloglog.c	/^static uint64_t hllCount(struct hllhdr *hdr, int *invalid) {$/;"	f	file:
hllDenseAdd	src/vr_hyperloglog.c	/^int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {$/;"	f
hllDenseSum	src/vr_hyperloglog.c	/^double hllDenseSum(uint8_t *registers, double *PE, int *ezp) {$/;"	f
hllMerge	src/vr_hyperloglog.c	/^int hllMerge(uint8_t *max, robj *hll) {$/;"	f
hllPatLen	src/vr_hyperloglog.c	/^int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {$/;"	f
hllRawSum	src/vr_hyperloglog.c	/^double hllRawSum(uint8_t *registers, double *PE, int *ezp) {$/;"	f
hllSparseAdd	src/vr_hyperloglog.c	/^int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {$/;"	f
hllSparseSum	src/vr_hyperloglog.c	/^double hllSparseSum(uint8_t *sparse, int sparselen, double *PE, int *ezp, int *invalid) {$/;"	f
hllSparseToDense	src/vr_hyperloglog.c	/^int hllSparseToDense(robj *o) {$/;"	f
hll_sparse_max_bytes	src/vr_server.h	/^    size_t hll_sparse_max_bytes;$/;"	m	struct:vr_server
hllhdr	src/vr_hyperloglog.c	/^struct hllhdr {$/;"	s	file:
hmgetCommand	src/vr_t_hash.c	/^void hmgetCommand(client *c) {$/;"	f
hmget_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hmget_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hmsetCommand	src/vr_t_hash.c	/^void hmsetCommand(client *c) {$/;"	f
hmset_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hmset_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
host	dep/himemcached-0.1.0/himemcached.h	/^        char *host;$/;"	m	struct:mcContext::__anon3
host	tests/vrabtest.h	/^    sds host;$/;"	m	struct:abtest_server
host	tests/vrt_public.h	/^    sds host;$/;"	m	struct:vire_instance
hostip	tests/vrt_benchmark.c	/^    const char *hostip;$/;"	m	struct:config	file:
hostname	src/vr_core.h	/^    char            hostname[VR_MAXHOSTNAMELEN]; \/* hostname *\/$/;"	m	struct:instance
hostport	tests/vrt_benchmark.c	/^    int hostport;$/;"	m	struct:config	file:
hostsocket	tests/vrt_benchmark.c	/^    const char *hostsocket;$/;"	m	struct:config	file:
hscanCommand	src/vr_t_hash.c	/^void hscanCommand(client *c) {$/;"	f
hsetCommand	src/vr_t_hash.c	/^void hsetCommand(client *c) {$/;"	f
hset_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hset_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hsetnxCommand	src/vr_t_hash.c	/^void hsetnxCommand(client *c) {$/;"	f
hsetnx_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hsetnx_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hstrlenCommand	src/vr_t_hash.c	/^void hstrlenCommand(client *c) {$/;"	f
hstrlen_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hstrlen_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
ht	src/vr_dict.h	/^    dictht ht[2];$/;"	m	struct:dict
ht	src/vr_t_zset.h	/^            } ht;$/;"	m	union:__anon8::__anon9::_iterset	typeref:struct:__anon8::__anon9::_iterset::__anon11
htNeedsResize	src/vr_server.c	/^int htNeedsResize(dict *dict) {$/;"	f
hvalsCommand	src/vr_t_hash.c	/^void hvalsCommand(client *c) {$/;"	f
hvals_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *hvals_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
hz	src/vr_eventloop.h	/^    int hz;                     \/* cron() calls frequency in hertz *\/$/;"	m	struct:vr_eventloop
hz	src/vr_server.h	/^    int hz;                     \/* serverCron() calls frequency in hertz *\/$/;"	m	struct:vr_server
hz	tests/vrt_backend.h	/^    int hz;$/;"	m	struct:backend_thread
hz	tests/vrt_benchmark.c	/^    int hz;$/;"	m	struct:benchmark_thread	file:
hz	tests/vrt_check_data.c	/^    int hz;$/;"	m	struct:check_data_thread	file:
hz	tests/vrt_check_data.c	/^    int hz;$/;"	m	struct:data_checker	file:
hz	tests/vrt_dispatch_data.h	/^    int hz;$/;"	m	struct:dispatch_data_thread
i64	src/vr_bitops.c	/^    int64_t i64;        \/* Increment amount (INCRBY) or SET value *\/$/;"	m	struct:bitfieldOp	file:
id	dep/ae/ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent
id	src/vr_backend.h	/^    int id;$/;"	m	struct:vr_backend
id	src/vr_client.c	/^    uint64_t id;$/;"	m	struct:clientkilldata	file:
id	src/vr_client.h	/^    uint64_t id;            \/* Client incremental unique ID. *\/$/;"	m	struct:client
id	src/vr_db.h	/^    int id;                     \/* Database ID *\/$/;"	m	struct:redisDb
id	src/vr_slowlog.h	/^    long long id;       \/* Unique entry identifier. *\/$/;"	m	struct:slowlogEntry
id	src/vr_thread.h	/^    int id;$/;"	m	struct:vr_thread
id	src/vr_worker.h	/^    int id;$/;"	m	struct:vr_worker
id	tests/vrt_backend.h	/^    int id;$/;"	m	struct:backend_thread
id	tests/vrt_benchmark.c	/^    int id;$/;"	m	struct:benchmark_thread	file:
id	tests/vrt_check_data.c	/^    int id;$/;"	m	struct:check_data_thread	file:
id	tests/vrt_dispatch_data.h	/^    int id;$/;"	m	struct:dispatch_data_thread
id	tests/vrt_produce_data.c	/^    int id;$/;"	m	struct:produce_thread	file:
idle	src/vr_db.h	/^    unsigned long long idle;    \/* Object idle time. *\/$/;"	m	struct:evictionPoolEntry
idlemode	tests/vrt_benchmark.c	/^    int idlemode;$/;"	m	struct:config	file:
idx	src/vr_command.h	/^    int idx;$/;"	m	struct:redisCommand
idx	src/vr_stats.h	/^        int idx;$/;"	m	struct:vr_stats::__anon20
idx	tests/vrt_dispatch_data.c	/^    int idx;$/;"	m	struct:callback_data	file:
idx_cmp	tests/vrt_public.c	/^    unsigned int idx_cmp;$/;"	m	struct:sort_unit	file:
ii	src/vr_server.h	/^    int ii; \/* intset iterator *\/$/;"	m	struct:__anon18
ii	src/vr_t_zset.h	/^                int ii;$/;"	m	struct:__anon8::__anon9::_iterset::__anon10
in	src/vr_util.h	/^        struct sockaddr_in  in;    \/* ipv4 socket address *\/$/;"	m	union:sockinfo::__anon5	typeref:struct:sockinfo::__anon5::sockaddr_in
in6	src/vr_util.h	/^        struct sockaddr_in6 in6;   \/* ipv6 socket address *\/$/;"	m	union:sockinfo::__anon5	typeref:struct:sockinfo::__anon5::sockaddr_in6
incrCommand	src/vr_t_string.c	/^void incrCommand(client *c) {$/;"	f
incrDecrCommand	src/vr_t_string.c	/^void incrDecrCommand(client *c, long long incr) {$/;"	f
incrRefCount	src/vr_object.c	/^void incrRefCount(robj *o) {$/;"	f
incr_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *incr_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
incrbyCommand	src/vr_t_string.c	/^void incrbyCommand(client *c) {$/;"	f
incrby_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *incrby_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
incrbyfloatCommand	src/vr_t_string.c	/^void incrbyfloatCommand(client *c) {$/;"	f
incrbyfloat_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *incrbyfloat_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
incrementallyRehashForDb	src/vr_db.c	/^int incrementallyRehashForDb(int dbid) {$/;"	f
index	dep/dhashkit/dhashkit.h	/^    uint32_t index;  \/* server index *\/$/;"	m	struct:continuum
index	src/vr_dict.h	/^    long index;$/;"	m	struct:dictIterator
info	src/vr_listen.h	/^    struct sockinfo info;   \/* listen socket info *\/$/;"	m	struct:vr_listen	typeref:struct:vr_listen::sockinfo
infoCommand	src/vr_server.c	/^void infoCommand(client *c) {$/;"	f
initClientMultiState	src/vr_multi.c	/^void initClientMultiState(client *c) {$/;"	f
initEntry	src/vr_quicklist.c	41;"	d	file:
init_server	src/vr_server.c	/^init_server(struct instance *nci)$/;"	f
inline	src/vr_lzf_c.c	44;"	d	file:
inline	src/vr_lzf_c.c	47;"	d	file:
inqueue	src/vr_connection.h	/^    dlist                *inqueue;        \/* incoming request queue *\/$/;"	m	struct:conn
inst_metric	src/vr_stats.h	/^    } inst_metric[STATS_METRIC_COUNT];$/;"	m	struct:vr_stats	typeref:struct:vr_stats::__anon20
instance	src/vr_core.h	/^struct instance {$/;"	s
integer	dep/himemcached-0.1.0/himcread.h	/^    long long integer; \/* Cache the integer if need *\/$/;"	m	struct:mcReader
integer	dep/himemcached-0.1.0/himemcached.h	/^    long long integer; \/* The integer when type is MC_REPLY_INTEGER *\/$/;"	m	struct:mcReply
integers	src/vr_server.h	/^    *integers[OBJ_SHARED_INTEGERS],$/;"	m	struct:sharedObjectsStruct
internal_dbs_per_databases	src/vr_conf.h	/^    int           internal_dbs_per_databases;$/;"	m	struct:conf_server
intrev16	src/vr_util.c	/^uint16_t intrev16(uint16_t v) {$/;"	f
intrev16ifbe	src/vr_util.h	207;"	d
intrev16ifbe	src/vr_util.h	214;"	d
intrev32	src/vr_util.c	/^uint32_t intrev32(uint32_t v) {$/;"	f
intrev32ifbe	src/vr_util.h	208;"	d
intrev32ifbe	src/vr_util.h	215;"	d
intrev64	src/vr_util.c	/^uint64_t intrev64(uint64_t v) {$/;"	f
intrev64ifbe	src/vr_util.h	209;"	d
intrev64ifbe	src/vr_util.h	216;"	d
intset	src/vr_intset.h	/^typedef struct intset {$/;"	s
intset	src/vr_intset.h	/^} intset;$/;"	t	typeref:struct:intset
intsetAdd	src/vr_intset.c	/^intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {$/;"	f
intsetBlobLen	src/vr_intset.c	/^size_t intsetBlobLen(intset *is) {$/;"	f
intsetFind	src/vr_intset.c	/^uint8_t intsetFind(intset *is, int64_t value) {$/;"	f
intsetGet	src/vr_intset.c	/^uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {$/;"	f
intsetLen	src/vr_intset.c	/^uint32_t intsetLen(intset *is) {$/;"	f
intsetMoveTail	src/vr_intset.c	/^static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {$/;"	f	file:
intsetNew	src/vr_intset.c	/^intset *intsetNew(void) {$/;"	f
intsetRandom	src/vr_intset.c	/^int64_t intsetRandom(intset *is) {$/;"	f
intsetRemove	src/vr_intset.c	/^intset *intsetRemove(intset *is, int64_t value, int *success) {$/;"	f
intsetResize	src/vr_intset.c	/^static intset *intsetResize(intset *is, uint32_t len) {$/;"	f	file:
intsetSearch	src/vr_intset.c	/^static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {$/;"	f	file:
intsetUpgradeAndAdd	src/vr_intset.c	/^static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {$/;"	f	file:
invalid_hll_err	src/vr_hyperloglog.c	/^static char *invalid_hll_err = "-INVALIDOBJ Corrupted HLL object detected\\r\\n";$/;"	v	file:
is	src/vr_t_zset.h	/^                intset *is;$/;"	m	struct:__anon8::__anon9::_iterset::__anon10
is	src/vr_t_zset.h	/^            } is;$/;"	m	union:__anon8::__anon9::_iterset	typeref:struct:__anon8::__anon9::_iterset::__anon10
isHLLObjectOrReply	src/vr_hyperloglog.c	/^int isHLLObjectOrReply(client *c, robj *o) {$/;"	f
isObjectRepresentableAsLongLong	src/vr_object.c	/^int isObjectRepresentableAsLongLong(robj *o, long long *llval) {$/;"	f
is_hex_digit	dep/himemcached-0.1.0/himcdep/sds.c	/^int is_hex_digit(char c) {$/;"	f
is_hex_digit	dep/sds/sds.c	/^int is_hex_digit(char c) {$/;"	f
isfinite	dep/util/dspecialconfig.h	34;"	d
isfinite	dep/util/dspecialconfig.h	35;"	d
isinf	dep/util/dspecialconfig.h	39;"	d
isinf	dep/util/dspecialconfig.h	40;"	d
isnan	dep/util/dspecialconfig.h	29;"	d
isnan	dep/util/dspecialconfig.h	30;"	d
iter	src/vr_server.h	/^    quicklistIter *iter;$/;"	m	struct:__anon16
iter	src/vr_t_zset.h	/^    } iter;$/;"	m	struct:__anon8	typeref:union:__anon8::__anon9
iterators	src/vr_dict.h	/^    int iterators; \/* number of iterators currently running *\/$/;"	m	struct:dict
iterset	src/vr_t_zset.c	/^typedef union _iterset iterset;$/;"	t	typeref:union:_iterset	file:
iterzset	src/vr_t_zset.c	/^typedef union _iterzset iterzset;$/;"	t	typeref:union:_iterzset	file:
kcp_get_from_ps	tests/vrt_produce_data.c	/^key_cache_array *kcp_get_from_ps(produce_scheme *ps, data_producer *dp)$/;"	f
kcps	tests/vrt_produce_data.h	/^    darray *kcps;   \/* Key cached pools for every type command. *\/$/;"	m	struct:produce_scheme
keepalive	tests/vrt_benchmark.c	/^    int keepalive;$/;"	m	struct:config	file:
ketama_dispatch	dep/dhashkit/dketama.c	/^ketama_dispatch(struct continuum *continuum, uint32_t ncontinuum, uint32_t hash)$/;"	f
ketama_hash	dep/dhashkit/dketama.c	/^ketama_hash(const char *key, size_t key_length, uint32_t alignment)$/;"	f	file:
ketama_item_cmp	dep/dhashkit/dketama.c	/^ketama_item_cmp(const void *t1, const void *t2)$/;"	f	file:
key	dep/himemcached-0.1.0/himemcached.h	/^    char *key;  \/* Key string *\/$/;"	m	struct:mcReply
key	src/vr_db.h	/^    sds key;                    \/* Key name. *\/$/;"	m	struct:evictionPoolEntry
key	src/vr_dict.h	/^    void *key;$/;"	m	struct:dictEntry
key	src/vr_multi.c	/^    robj *key;$/;"	m	struct:watchedKey	file:
key	src/vr_rbtree.h	/^    int64_t       key;       \/* key for ordering *\/$/;"	m	struct:rbnode
key	src/vr_server.h	/^    robj *key;$/;"	m	struct:readyList
key	tests/vrt_check_data.c	/^    sds key;$/;"	m	struct:check_unit	file:
keyCompare	src/vr_dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	struct:dictType
keyDestructor	src/vr_dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	struct:dictType
keyDup	src/vr_dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	struct:dictType
key_cache_array	tests/vrt_public.h	/^typedef struct key_cache_array {$/;"	s
key_cache_array	tests/vrt_public.h	/^} key_cache_array;$/;"	t	typeref:struct:key_cache_array
key_cache_array_create	tests/vrt_public.c	/^key_cache_array *key_cache_array_create(long long max_pool_size)$/;"	f
key_cache_array_destroy	tests/vrt_public.c	/^void key_cache_array_destroy(key_cache_array *kca)$/;"	f
key_cache_array_input	tests/vrt_public.c	/^int key_cache_array_input(key_cache_array *kca, char *key, size_t keylen)$/;"	f
key_cache_array_random	tests/vrt_public.c	/^sds key_cache_array_random(key_cache_array *kca)$/;"	f
key_cache_pools_count	tests/vrt_produce_data.c	/^static int key_cache_pools_count = 0;$/;"	v	file:
key_length_max	tests/vrt_produce_data.c	/^static unsigned int key_length_max;$/;"	v	file:
key_length_min	tests/vrt_produce_data.c	/^static unsigned int key_length_min;$/;"	v	file:
key_length_range_begin	tests/vrabtest.c	/^    int key_length_range_begin;$/;"	m	struct:config	file:
key_length_range_end	tests/vrabtest.c	/^    int key_length_range_end;$/;"	m	struct:config	file:
key_length_range_gap	tests/vrt_produce_data.c	/^static unsigned int key_length_range_gap;$/;"	v	file:
key_persist	tests/vrt_check_data.c	/^    int key_persist;$/;"	m	struct:check_unit	file:
key_type	tests/vrt_check_data.c	/^    int key_type;$/;"	m	struct:check_unit	file:
keylen	dep/himemcached-0.1.0/himemcached.h	/^    int keylen; \/* Length of key *\/$/;"	m	struct:mcReply
keylistDictType	src/vr_db.c	/^dictType keylistDictType = {$/;"	v
keyptrDictType	src/vr_db.c	/^dictType keyptrDictType = {$/;"	v
keys	src/vr_block.h	/^    dict *keys;             \/* The keys we are waiting to terminate a blocking$/;"	m	struct:blockingState
keysCommand	src/vr_db.c	/^void keysCommand(client *c) {$/;"	f
keys_all	src/vr_server.c	/^    long long keys_all;$/;"	m	struct:keys_statistics	file:
keys_statistics	src/vr_server.c	/^struct keys_statistics {$/;"	s	file:
keysize	tests/vrt_benchmark.c	/^    int keysize;$/;"	m	struct:config	file:
keyspaceEventsFlagsToString	src/vr_notify.c	/^sds keyspaceEventsFlagsToString(int flags) {$/;"	f
keyspaceEventsStringToFlags	src/vr_notify.c	/^int keyspaceEventsStringToFlags(char *classes) {$/;"	f
keyspace_hits	src/vr_stats.h	/^    long long keyspace_hits;   \/* Number of successful lookups of keys *\/$/;"	m	struct:vr_stats
keyspace_misses	src/vr_stats.h	/^    long long keyspace_misses; \/* Number of failed lookups of keys *\/$/;"	m	struct:vr_stats
keystep	src/vr_command.h	/^    int keystep;  \/* The step between first and last key *\/$/;"	m	struct:redisCommand
keystep	tests/vrt_produce_data.h	/^    int keystep;  \/* The step between first and last key *\/$/;"	m	struct:data_producer
kflags	dep/himemcached-0.1.0/himcread.h	/^    int kflags;  \/* Used for key flags (get\/gets command reply) *\/$/;"	m	struct:mcReader
killed	src/vr_client.c	/^    int killed;$/;"	m	struct:clientkilldata	file:
kqfd	dep/ae/ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:
kversion	dep/himemcached-0.1.0/himcread.h	/^    long long kversion;  \/* Used for key version (gets command reply) *\/$/;"	m	struct:mcReader
l	dep/dlist/dlockqueue.h	/^    struct dlist *l;$/;"	m	struct:dlockqueue	typeref:struct:dlockqueue::dlist
l	dep/dlist/dmtqueue.h	/^    void *l;$/;"	m	struct:dmtqueue
lastTime	dep/ae/ae.h	/^    time_t lastTime;     \/* Used to detect system clock skew *\/$/;"	m	struct:aeEventLoop
last_check_begin_time	tests/vrt_check_data.c	/^static long long last_check_begin_time;$/;"	v	file:
last_fast_cycle	src/vr_backend.h	/^    long long last_fast_cycle;  \/* When last fast cycle ran. *\/$/;"	m	struct:vr_backend
last_fast_cycle	src/vr_worker.h	/^    long long last_fast_cycle;  \/* When last fast cycle ran. *\/$/;"	m	struct:vr_worker
last_sample_count	src/vr_stats.h	/^        long long last_sample_count;\/* Count in last sample *\/$/;"	m	struct:vr_stats::__anon20
last_sample_time	src/vr_stats.h	/^        long long last_sample_time; \/* Timestamp of last sample in ms *\/$/;"	m	struct:vr_stats::__anon20
last_test_begin_time	tests/vrabtest.c	/^long long last_test_begin_time;$/;"	v
last_worker_thread	src/vr_worker.c	/^static int last_worker_thread = -1;$/;"	v	file:
lastbgsave_status	src/vr_server.h	/^    int lastbgsave_status;          \/* VR_OK or VR_ERROR *\/$/;"	m	struct:vr_server
lastbgsave_try	src/vr_server.h	/^    time_t lastbgsave_try;          \/* Unix time of last attempted bgsave *\/$/;"	m	struct:vr_server
lastcmd	src/vr_client.h	/^    struct redisCommand *cmd, *lastcmd;  \/* Last command executed. *\/$/;"	m	struct:client	typeref:struct:client::
lastinteraction	src/vr_client.h	/^    time_t lastinteraction; \/* Time of the last interaction, used for timeout *\/$/;"	m	struct:client
lastkey	src/vr_command.h	/^    int lastkey;  \/* The last argument that's a key *\/$/;"	m	struct:redisCommand
lastkey	tests/vrt_produce_data.h	/^    int lastkey;  \/* The last argument that's a key *\/$/;"	m	struct:data_producer
lastsave	src/vr_server.h	/^    time_t lastsave;                \/* Unix time of last successful save *\/$/;"	m	struct:vr_server
lastsaveCommand	src/vr_db.c	/^void lastsaveCommand(client *c) {$/;"	f
latency	tests/vrt_benchmark.c	/^    long long *latency;$/;"	m	struct:benchmark_thread	file:
latency	tests/vrt_benchmark.c	/^    long long *latency;$/;"	m	struct:config	file:
latency	tests/vrt_benchmark.c	/^    long long latency;      \/* Request latency *\/$/;"	m	struct:_benchmark_client	file:
left	src/vr_rbtree.h	/^    struct rbnode *left;     \/* left link *\/$/;"	m	struct:rbnode	typeref:struct:rbnode::rbnode
len	dep/dlist/dlist.h	/^    unsigned long len;$/;"	m	struct:dlist
len	dep/himemcached-0.1.0/himcdep/sds.h	/^    int len;$/;"	m	struct:sdshdr
len	dep/himemcached-0.1.0/himcread.h	/^    size_t len; \/* Buffer length *\/$/;"	m	struct:mcReader
len	dep/himemcached-0.1.0/himemcached.h	/^    int len; \/* Length of string *\/$/;"	m	struct:mcReply
len	dep/sds/sds.h	/^    uint16_t len; \/* used *\/$/;"	m	struct:sdshdr16
len	dep/sds/sds.h	/^    uint32_t len; \/* used *\/$/;"	m	struct:sdshdr32
len	dep/sds/sds.h	/^    uint64_t len; \/* used *\/$/;"	m	struct:sdshdr64
len	dep/sds/sds.h	/^    uint8_t len; \/* used *\/$/;"	m	struct:sdshdr8
len	src/vr_quicklist.h	/^    unsigned int len;           \/* number of quicklistNodes *\/$/;"	m	struct:quicklist
len	src/vr_ziplist.c	/^    unsigned int lensize, len;$/;"	m	struct:zlentry	file:
length	dep/dlist/dmtqueue.h	/^    long long (*length)(void *q);$/;"	m	struct:dmtqueue
length	src/vr_intset.h	/^    uint32_t length;$/;"	m	struct:intset
length	src/vr_server.h	/^    unsigned long length;$/;"	m	struct:zskiplist
lensize	src/vr_ziplist.c	/^    unsigned int lensize, len;$/;"	m	struct:zlentry	file:
level	dep/util/dlog.h	/^    int  level;  \/* log level *\/$/;"	m	struct:logger
level	src/vr_server.h	/^    int level;$/;"	m	struct:zskiplist
level	src/vr_server.h	/^    } level[];$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistLevel
li	src/vr_server.h	/^    listTypeIterator *li;$/;"	m	struct:__anon17
likely	src/vr_quicklist.c	52;"	d	file:
likely	src/vr_quicklist.c	55;"	d	file:
lindexCommand	src/vr_t_list.c	/^void lindexCommand(client *c) {$/;"	f
lindex_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *lindex_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
lines	src/vr_conf.c	/^    sds *lines;           \/* Current lines as an array of sds strings *\/$/;"	m	struct:rewriteConfigState	file:
linkClientToEventloop	src/vr_client.c	/^void linkClientToEventloop(client *c,vr_eventloop *vel) {$/;"	f
linsertCommand	src/vr_t_list.c	/^void linsertCommand(client *c) {$/;"	f
listMatchObjects	src/vr_client.c	/^int listMatchObjects(void *a, void *b) {$/;"	f
listPopSaver	src/vr_t_list.c	/^void *listPopSaver(unsigned char *data, unsigned int sz) {$/;"	f
listTypeConvert	src/vr_t_list.c	/^void listTypeConvert(robj *subject, int enc) {$/;"	f
listTypeDelete	src/vr_t_list.c	/^void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {$/;"	f
listTypeEntry	src/vr_server.h	/^} listTypeEntry;$/;"	t	typeref:struct:__anon17
listTypeEqual	src/vr_t_list.c	/^int listTypeEqual(listTypeEntry *entry, robj *o) {$/;"	f
listTypeGet	src/vr_t_list.c	/^robj *listTypeGet(listTypeEntry *entry) {$/;"	f
listTypeInitIterator	src/vr_t_list.c	/^listTypeIterator *listTypeInitIterator(robj *subject, long index,$/;"	f
listTypeInsert	src/vr_t_list.c	/^void listTypeInsert(listTypeEntry *entry, robj *value, int where) {$/;"	f
listTypeIterator	src/vr_server.h	/^} listTypeIterator;$/;"	t	typeref:struct:__anon16
listTypeLength	src/vr_t_list.c	/^unsigned long listTypeLength(robj *subject) {$/;"	f
listTypeNext	src/vr_t_list.c	/^int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {$/;"	f
listTypePop	src/vr_t_list.c	/^robj *listTypePop(robj *subject, int where) {$/;"	f
listTypePush	src/vr_t_list.c	/^void listTypePush(robj *subject, robj *value, int where) {$/;"	f
listTypeReleaseIterator	src/vr_t_list.c	/^void listTypeReleaseIterator(listTypeIterator *li) {$/;"	f
list_compress_depth	src/vr_server.h	/^    int list_compress_depth;$/;"	m	struct:vr_server
list_max_ziplist_size	src/vr_server.h	/^    int list_max_ziplist_size;$/;"	m	struct:vr_server
listens	src/vr_master.h	/^    struct darray listens;   \/* type: vr_listen *\/$/;"	m	struct:vr_master	typeref:struct:vr_master::darray
liveclients	tests/vrt_benchmark.c	/^    int liveclients;$/;"	m	struct:benchmark_thread	file:
liveclients	tests/vrt_benchmark.c	/^    int liveclients;$/;"	m	struct:config	file:
ll2string	src/vr_util.c	/^ll2string(char* dst, size_t dstlen, long long svalue) {$/;"	f
ll2string	tests/vrt_util.c	/^int ll2string(char* dst, size_t dstlen, long long svalue) {$/;"	f
llenCommand	src/vr_t_list.c	/^void llenCommand(client *c) {$/;"	f
llen_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *llen_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
lmutex	dep/dlist/dlockqueue.h	/^    pthread_mutex_t lmutex;$/;"	m	struct:dlockqueue
lnode	tests/vrt_check_data.c	/^    dlistNode *lnode;$/;"	m	struct:check_unit	file:
lo	dep/dhashkit/dmd5.c	/^    MD5_u32plus lo, hi;$/;"	m	struct:__anon2	file:
loading	src/vr_server.h	/^    int loading;                \/* We are loading data from disk if true *\/$/;"	m	struct:vr_server
loading_loaded_bytes	src/vr_server.h	/^    off_t loading_loaded_bytes;$/;"	m	struct:vr_server
loading_process_events_interval_bytes	src/vr_server.h	/^    off_t loading_process_events_interval_bytes;$/;"	m	struct:vr_server
loading_start_time	src/vr_server.h	/^    time_t loading_start_time;$/;"	m	struct:vr_server
loading_total_bytes	src/vr_server.h	/^    off_t loading_total_bytes;$/;"	m	struct:vr_server
loadingerr	src/vr_server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
lockDbRead	src/vr_db.c	/^lockDbRead(redisDb *db)$/;"	f
lockDbWrite	src/vr_db.c	/^lockDbWrite(redisDb *db)$/;"	f
lock_pop	dep/dlist/dmtqueue.h	/^    void *(*lock_pop)(void *q);$/;"	m	struct:dmtqueue
lock_push	dep/dlist/dmtqueue.h	/^    long long (*lock_push)(void *q, void *value);$/;"	m	struct:dmtqueue
log_debug	dep/util/dlog.h	43;"	d
log_debug	dep/util/dlog.h	51;"	d
log_deinit	dep/util/dlog.c	/^log_deinit(void)$/;"	f
log_error	dep/util/dlog.h	89;"	d
log_file	tests/vrt_public.h	/^    sds log_file;$/;"	m	struct:vire_instance
log_filename	src/vr_core.h	/^    char            *log_filename;               \/* log filename *\/$/;"	m	struct:instance
log_filename	tests/vrabtest.c	/^    char *log_filename;$/;"	m	struct:config	file:
log_hexdump	dep/util/dlog.h	55;"	d
log_init	dep/util/dlog.c	/^log_init(int level, char *name)$/;"	f
log_level	src/vr_core.h	/^    int             log_level;                   \/* log level *\/$/;"	m	struct:instance
log_level_down	dep/util/dlog.c	/^log_level_down(void)$/;"	f
log_level_set	dep/util/dlog.c	/^log_level_set(int level)$/;"	f
log_level_up	dep/util/dlog.c	/^log_level_up(void)$/;"	f
log_loggable	dep/util/dlog.c	/^log_loggable(int level)$/;"	f
log_notice	dep/util/dlog.h	101;"	d
log_panic	dep/util/dlog.h	107;"	d
log_reopen	dep/util/dlog.c	/^log_reopen(void)$/;"	f
log_safe	dep/util/dlog.h	71;"	d
log_stacktrace	dep/util/dlog.c	/^log_stacktrace(void)$/;"	f
log_stderr	dep/util/dlog.h	63;"	d
log_stderr_safe	dep/util/dlog.h	75;"	d
log_stdout	dep/util/dlog.h	67;"	d
log_warn	dep/util/dlog.h	95;"	d
log_write_len	dep/util/dlog.c	/^void log_write_len(char *str, size_t len)$/;"	f
loga	dep/util/dlog.h	79;"	d
loga_hexdump	dep/util/dlog.h	83;"	d
logger	dep/util/dlog.c	/^static struct logger logger;$/;"	v	typeref:struct:logger	file:
logger	dep/util/dlog.h	/^struct logger {$/;"	s
long_options	src/vr.c	/^static struct option long_options[] = {$/;"	v	typeref:struct:option	file:
long_options	tests/vrabtest.c	/^static struct option long_options[] = {$/;"	v	typeref:struct:option	file:
long_options	tests/vrtest.c	/^static struct option long_options[] = {$/;"	v	typeref:struct:option	file:
longval	src/vr_quicklist.h	/^    long long longval;$/;"	m	struct:quicklistEntry
lookupCommand	src/vr_command.c	/^struct redisCommand *lookupCommand(sds name) {$/;"	f
lookupCommandByCString	src/vr_command.c	/^struct redisCommand *lookupCommandByCString(char *s) {$/;"	f
lookupCommandOrOriginal	src/vr_command.c	/^struct redisCommand *lookupCommandOrOriginal(sds name) {$/;"	f
lookupKey	src/vr_db.c	/^robj *lookupKey(redisDb *db, robj *key) {$/;"	f
lookupKeyRead	src/vr_db.c	/^robj *lookupKeyRead(redisDb *db, robj *key) {$/;"	f
lookupKeyReadOrReply	src/vr_db.c	/^robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {$/;"	f
lookupKeyWrite	src/vr_db.c	/^robj *lookupKeyWrite(redisDb *db, robj *key, int *expired) {$/;"	f
lookupKeyWriteOrReply	src/vr_db.c	/^robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply, int *expired) {$/;"	f
lookupStringForBitCommand	src/vr_bitops.c	/^robj *lookupStringForBitCommand(client *c, size_t maxbit, int *expired) {$/;"	f
loop	tests/vrt_benchmark.c	/^    int loop;$/;"	m	struct:config	file:
looptimes	tests/vrt_produce_data.c	/^    long long looptimes;$/;"	m	struct:produce_thread	file:
lpop	src/vr_server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
lpopCommand	src/vr_server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:vr_server	typeref:struct:vr_server::
lpopCommand	src/vr_t_list.c	/^void lpopCommand(client *c) {$/;"	f
lpop_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *lpop_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
lpush	src/vr_server.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct
lpushCommand	src/vr_server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:vr_server	typeref:struct:vr_server::
lpushCommand	src/vr_t_list.c	/^void lpushCommand(client *c) {$/;"	f
lpush_cmd_nck	tests/vrt_produce_data.c	/^static int lpush_cmd_nck(redisReply *reply)$/;"	f	file:
lpush_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *lpush_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
lpushxCommand	src/vr_t_list.c	/^void lpushxCommand(client *c) {$/;"	f
lrangeCommand	src/vr_t_list.c	/^void lrangeCommand(client *c) {$/;"	f
lrange_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *lrange_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
lremCommand	src/vr_t_list.c	/^void lremCommand(client *c) {$/;"	f
lrem_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *lrem_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
lru	src/vr_object.h	/^    unsigned lru:LRU_BITS; \/* lru time (relative to server.lruclock) *\/$/;"	m	struct:vr_object
lruclock	src/vr_eventloop.h	/^    unsigned lruclock:LRU_BITS; \/* Clock for LRU eviction *\/$/;"	m	struct:vr_eventloop
lruclock	src/vr_server.h	/^    unsigned lruclock:LRU_BITS; \/* Clock for LRU eviction *\/$/;"	m	struct:vr_server
lsetCommand	src/vr_t_list.c	/^void lsetCommand(client *c) {$/;"	f
lset_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *lset_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
ltrimCommand	src/vr_t_list.c	/^void ltrimCommand(client *c) {$/;"	f
ltrim_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *ltrim_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
lua_always_replicate_commands	src/vr_server.h	/^    int lua_always_replicate_commands; \/* Default replication type. *\/$/;"	m	struct:vr_server
lua_caller	src/vr_server.h	/^    struct client *lua_caller;   \/* The client running EVAL right now, or NULL *\/$/;"	m	struct:vr_server	typeref:struct:vr_server::client
lua_client	src/vr_server.h	/^    struct client *lua_client;   \/* The "fake client" to query Redis from Lua *\/$/;"	m	struct:vr_server	typeref:struct:vr_server::client
lua_kill	src/vr_server.h	/^    int lua_kill;         \/* Kill the script if true. *\/$/;"	m	struct:vr_server
lua_multi_emitted	src/vr_server.h	/^    int lua_multi_emitted;\/* True if we already proagated MULTI. *\/$/;"	m	struct:vr_server
lua_random_dirty	src/vr_server.h	/^    int lua_random_dirty; \/* True if a random command was called during the$/;"	m	struct:vr_server
lua_repl	src/vr_server.h	/^    int lua_repl;         \/* Script replication flags for redis.set_repl(). *\/$/;"	m	struct:vr_server
lua_replicate_commands	src/vr_server.h	/^    int lua_replicate_commands; \/* True if we are doing single commands repl. *\/$/;"	m	struct:vr_server
lua_scripts	src/vr_server.h	/^    dict *lua_scripts;         \/* A dictionary of SHA1 -> Lua scripts *\/$/;"	m	struct:vr_server
lua_time_limit	src/vr_server.h	/^    mstime_t lua_time_limit;  \/* Script timeout in milliseconds *\/$/;"	m	struct:vr_server
lua_time_start	src/vr_server.h	/^    mstime_t lua_time_start;  \/* Start time of script, milliseconds time *\/$/;"	m	struct:vr_server
lua_timedout	src/vr_server.h	/^    int lua_timedout;     \/* True if we reached the time limit for script$/;"	m	struct:vr_server
lua_write_dirty	src/vr_server.h	/^    int lua_write_dirty;  \/* True if a write command was called during the$/;"	m	struct:vr_server
lzf_compress	src/vr_lzf_c.c	/^lzf_compress (const void *const in_data, unsigned int in_len,$/;"	f
lzf_decompress	src/vr_lzf_d.c	/^lzf_decompress (const void *const in_data,  unsigned int in_len,$/;"	f
lzf_movsb	src/vr_lzf_d.c	12;"	d	file:
magic	src/vr_hyperloglog.c	/^    char magic[4];      \/* "HYLL" *\/$/;"	m	struct:hllhdr	file:
main	dep/himemcached-0.1.0/himcdep/sds.c	/^int main(void) {$/;"	f
main	dep/sds/sds.c	/^int main(void) {$/;"	f
main	src/vr.c	/^main(int argc, char **argv)$/;"	f
main	tests/vrabtest.c	/^main(int argc, char **argv)$/;"	f
main	tests/vrt_benchmark.c	/^int main(int argc, const char **argv) {$/;"	f
main	tests/vrtest.c	/^main(int argc, char **argv)$/;"	f
malloc_lock_type	dep/dmalloc/dmalloc.c	/^char *malloc_lock_type(void) {return "HAVE_ATOMIC";}$/;"	f
malloc_lock_type	dep/dmalloc/dmalloc.c	/^char *malloc_lock_type(void) {return "__ATOMIC_RELAXED";}$/;"	f
malloc_lock_type	dep/dmalloc/dmalloc.c	/^char *malloc_lock_type(void) {return "pthread_mutex_t";}$/;"	f
mask	dep/ae/ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	struct:aeFileEvent
mask	dep/ae/ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent
master	src/vr_master.c	/^vr_master master;$/;"	v
master	src/vr_replication.h	/^    client *master;     \/* Client that is master for this slave *\/$/;"	m	struct:vr_replication
master	tests/vrt_check_data.c	/^    conn_context *master;   \/* If this is a slave *\/$/;"	m	struct:data_checker	file:
master_deinit	src/vr_master.c	/^master_deinit(void)$/;"	f
master_init	src/vr_master.c	/^master_init(vr_conf *conf)$/;"	f
master_repl_offset	src/vr_replication.h	/^    long long master_repl_offset;   \/* Global replication offset *\/$/;"	m	struct:vr_replication
master_run	src/vr_master.c	/^master_run(void)$/;"	f
master_thread_run	src/vr_master.c	/^master_thread_run(void *args)$/;"	f	file:
masterauth	src/vr_replication.h	/^    char *masterauth;               \/* AUTH with this password with master *\/$/;"	m	struct:vr_replication
masterdownerr	src/vr_server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noadminerr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
masterhost	src/vr_replication.h	/^    char *masterhost;               \/* Hostname of master *\/$/;"	m	struct:vr_replication
masterport	src/vr_replication.h	/^    int masterport;                 \/* Port of master *\/$/;"	m	struct:vr_replication
match	dep/dlist/dlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	struct:dlist
max	src/vr_t_zset.h	/^    double min, max;$/;"	m	struct:__anon6
max	src/vr_t_zset.h	/^    robj *min, *max;  \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	struct:__anon7
max_pool_size	tests/vrt_public.h	/^    long long max_pool_size;    \/* Max keys count that can be cached in the ckeys array. *\/$/;"	m	struct:key_cache_array
max_time_complexity_limit	src/vr_conf.h	/^    long long     max_time_complexity_limit;$/;"	m	struct:conf_server
max_time_complexity_limit	src/vr_conf.h	/^    long long max_time_complexity_limit;$/;"	m	struct:conf_cache
max_ttl_gap	tests/vrt_check_data.c	/^    long long min_ttl, max_ttl_gap;$/;"	m	struct:check_unit	file:
maxbuf	dep/himemcached-0.1.0/himcread.h	/^    size_t maxbuf; \/* Max length of unused buffer *\/$/;"	m	struct:mcReader
maxclients	src/vr_conf.h	/^    int           maxclients;           \/* Max number of simultaneous clients *\/$/;"	m	struct:conf_server
maxclients	src/vr_conf.h	/^    int maxclients;$/;"	m	struct:conf_cache
maxex	src/vr_t_zset.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon6
maxex	src/vr_t_zset.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon7
maxfd	dep/ae/ae.h	/^    int maxfd;   \/* highest file descriptor currently registered *\/$/;"	m	struct:aeEventLoop
maxlen	dep/dlist/dlockqueue.h	/^    long long maxlen;$/;"	m	struct:dlockqueue
maxlen_policy	dep/dlist/dlockqueue.h	/^    int maxlen_policy;$/;"	m	struct:dlockqueue
maxmemory	src/vr_conf.h	/^    long long     maxmemory;            \/* Max number of memory bytes to use *\/$/;"	m	struct:conf_server
maxmemory	src/vr_conf.h	/^    long long maxmemory;$/;"	m	struct:conf_cache
maxmemory	tests/vrt_backend.c	/^    long long maxmemory;$/;"	m	struct:task_data	file:
maxmemory_policy	src/vr_conf.h	/^    int           maxmemory_policy;     \/* Policy for key eviction *\/$/;"	m	struct:conf_server
maxmemory_samples	src/vr_conf.h	/^    int           maxmemory_samples;    \/* Pricision of random sampling *\/$/;"	m	struct:conf_server
maxstring	src/vr_server.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct
mbuf_chunk_size	src/vr_core.h	/^    size_t          mbuf_chunk_size;             \/* mbuf chunk size *\/$/;"	m	struct:instance
mbulkhdr	src/vr_server.h	/^    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], \/* "*<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct
mc	tests/vrt_benchmark.c	/^    mcContext *mc;$/;"	m	struct:_benchmark_client	file:
mcConnectionType	dep/himemcached-0.1.0/himemcached.h	/^enum mcConnectionType {$/;"	g
mcContext	dep/himemcached-0.1.0/himemcached.h	/^typedef struct mcContext {$/;"	s
mcContext	dep/himemcached-0.1.0/himemcached.h	/^} mcContext;$/;"	t	typeref:struct:mcContext
mcReader	dep/himemcached-0.1.0/himcread.h	/^typedef struct mcReader {$/;"	s
mcReader	dep/himemcached-0.1.0/himcread.h	/^} mcReader;$/;"	t	typeref:struct:mcReader
mcReply	dep/himemcached-0.1.0/himemcached.h	/^typedef struct mcReply {$/;"	s
mcReply	dep/himemcached-0.1.0/himemcached.h	/^} mcReply;$/;"	t	typeref:struct:mcReply
mcReplyObjectFunctions	dep/himemcached-0.1.0/himcread.h	/^typedef struct mcReplyObjectFunctions {$/;"	s
mcReplyObjectFunctions	dep/himemcached-0.1.0/himcread.h	/^} mcReplyObjectFunctions;$/;"	t	typeref:struct:mcReplyObjectFunctions
md5_signature	dep/dhashkit/dmd5.c	/^md5_signature(const unsigned char *key, unsigned long length, unsigned char *result)$/;"	f
memcachedBufferRead	dep/himemcached-0.1.0/himemcached.c	/^int memcachedBufferRead(mcContext *c) {$/;"	f
memcachedBufferWrite	dep/himemcached-0.1.0/himemcached.c	/^int memcachedBufferWrite(mcContext *c, int *done) {$/;"	f
memcachedContextInit	dep/himemcached-0.1.0/himemcached.c	/^mcContext *memcachedContextInit(void) {$/;"	f
memcachedFormatCommand	dep/himemcached-0.1.0/himemcached.c	/^int memcachedFormatCommand(char **target, const char *format, ...) {$/;"	f
memcachedFormatCommandArgv	dep/himemcached-0.1.0/himemcached.c	/^int memcachedFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {$/;"	f
memcachedFormatCommandSdsArgv	dep/himemcached-0.1.0/himemcached.c	/^int memcachedFormatCommandSdsArgv(char **target, int argc, const sds *argv) {$/;"	f
memcachedFree	dep/himemcached-0.1.0/himemcached.c	/^void memcachedFree(mcContext *c) {$/;"	f
memcachedGetReply	dep/himemcached-0.1.0/himemcached.c	/^int memcachedGetReply(mcContext *c, void **reply) {$/;"	f
memcachedGetReplyFromReader	dep/himemcached-0.1.0/himemcached.c	/^int memcachedGetReplyFromReader(mcContext *c, void **reply) {$/;"	f
memcachedParseResponse	dep/himemcached-0.1.0/himcread.c	/^static void memcachedParseResponse(mcReader *r)$/;"	f	file:
memcachedReaderCreate	dep/himemcached-0.1.0/himemcached.c	/^mcReader *memcachedReaderCreate(void) {$/;"	f
memcachedReaderCreateWithFunctions	dep/himemcached-0.1.0/himcread.c	/^mcReader *memcachedReaderCreateWithFunctions(mcReplyObjectFunctions *fn) $/;"	f
memcachedReaderFeed	dep/himemcached-0.1.0/himcread.c	/^int memcachedReaderFeed(mcReader *r, const char *buf, size_t len) $/;"	f
memcachedReaderFree	dep/himemcached-0.1.0/himcread.c	/^void memcachedReaderFree(mcReader *r) $/;"	f
memcachedReaderGetReply	dep/himemcached-0.1.0/himcread.c	/^int memcachedReaderGetReply(mcReader *r, void **reply) {$/;"	f
memcachedReaderReset	dep/himemcached-0.1.0/himcread.c	/^static void memcachedReaderReset(mcReader *r) $/;"	f	file:
memcachedvFormatCommand	dep/himemcached-0.1.0/himemcached.c	/^int memcachedvFormatCommand(char **target, const char *format, va_list ap)$/;"	f
memrev16	src/vr_util.c	/^void memrev16(void *p) {$/;"	f
memrev16ifbe	src/vr_util.h	204;"	d
memrev16ifbe	src/vr_util.h	211;"	d
memrev32	src/vr_util.c	/^void memrev32(void *p) {$/;"	f
memrev32ifbe	src/vr_util.h	205;"	d
memrev32ifbe	src/vr_util.h	212;"	d
memrev64	src/vr_util.c	/^void memrev64(void *p) {$/;"	f
memrev64ifbe	src/vr_util.h	206;"	d
memrev64ifbe	src/vr_util.h	213;"	d
memtoll	src/vr_util.c	/^long long memtoll(const char *p, int *err) {$/;"	f
messagebulk	src/vr_server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
mgetCommand	src/vr_t_string.c	/^void mgetCommand(client *c) {$/;"	f
mget_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *mget_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
microseconds	src/vr_command.h	/^    long long microseconds;$/;"	m	struct:commandStats
migrateGetKeys	src/vr_db.c	/^int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f
min	src/vr_t_zset.h	/^    double min, max;$/;"	m	struct:__anon6
min	src/vr_t_zset.h	/^    robj *min, *max;  \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	struct:__anon7
min_ttl	tests/vrt_check_data.c	/^    long long min_ttl, max_ttl_gap;$/;"	m	struct:check_unit	file:
minex	src/vr_t_zset.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon6
minex	src/vr_t_zset.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon7
minreplicas	src/vr_multi.h	/^    int minreplicas;        \/* MINREPLICAS for synchronous replication *\/$/;"	m	struct:multiState
minreplicas_timeout	src/vr_multi.h	/^    time_t minreplicas_timeout; \/* MINREPLICAS timeout as unixtime. *\/$/;"	m	struct:multiState
minstring	src/vr_server.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct
mix	dep/dhashkit/djenkins.c	7;"	d	file:
modula_dispatch	dep/dhashkit/dmodula.c	/^modula_dispatch(struct continuum *continuum, uint32_t ncontinuum, uint32_t hash)$/;"	f
monitors	src/vr_server.h	/^    dlist *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:vr_server
moveCommand	src/vr_db.c	/^void moveCommand(client *c) {$/;"	f
msetCommand	src/vr_t_string.c	/^void msetCommand(client *c) {$/;"	f
msetGenericCommand	src/vr_t_string.c	/^void msetGenericCommand(client *c, int nx) {$/;"	f
mset_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *mset_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
msetnxCommand	src/vr_t_string.c	/^void msetnxCommand(client *c) {$/;"	f
mstate	src/vr_client.h	/^    multiState mstate;      \/* MULTI\/EXEC state *\/$/;"	m	struct:client
mstime	src/vr_eventloop.h	/^    long long mstime;           \/* Like 'unixtime' but with milliseconds resolution. *\/$/;"	m	struct:vr_eventloop
mstime	src/vr_server.h	/^    long long mstime;       \/* Like 'unixtime' but with milliseconds resolution. *\/$/;"	m	struct:vr_server
mstime_t	src/vr_core.h	/^typedef long long mstime_t; \/* millisecond time type. *\/$/;"	t
multiCmd	src/vr_multi.h	/^typedef struct multiCmd {$/;"	s
multiCmd	src/vr_multi.h	/^} multiCmd;$/;"	t	typeref:struct:multiCmd
multiCommand	src/vr_multi.c	/^void multiCommand(client *c) {$/;"	f
multiCommand	src/vr_server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:vr_server	typeref:struct:vr_server::
multiState	src/vr_multi.h	/^typedef struct multiState {$/;"	s
multiState	src/vr_multi.h	/^} multiState;$/;"	t	typeref:struct:multiState
multibulklen	src/vr_client.h	/^    int multibulklen;       \/* Number of multi bulk arguments left to read. *\/$/;"	m	struct:client
nalloc	dep/darray/darray.h	/^    unsigned long long   nalloc; \/* # allocated element *\/$/;"	m	struct:darray
name	dep/util/dlog.h	/^    char *name;  \/* log file name *\/$/;"	m	struct:logger
name	src/vr_client.h	/^    robj *name;             \/* As set by CLIENT SETNAME. *\/$/;"	m	struct:client
name	src/vr_command.h	/^    char *name;$/;"	m	struct:commandStats
name	src/vr_command.h	/^    char *name;$/;"	m	struct:redisCommand
name	src/vr_conf.h	/^    char    *name;      \/* option name *\/$/;"	m	struct:conf_option
name	src/vr_listen.h	/^    sds name;               \/* hostname:port *\/$/;"	m	struct:vr_listen
name	tests/vrt_produce_data.h	/^    char *name;     \/* Command name *\/$/;"	m	struct:data_producer
nck_when_noerror	tests/vrt_produce_data.c	/^static int nck_when_noerror(redisReply *reply)$/;"	f	file:
nck_when_nonzero_unsigned_integer	tests/vrt_produce_data.c	/^static int nck_when_nonzero_unsigned_integer(redisReply *reply)$/;"	f	file:
nck_when_ok	tests/vrt_produce_data.c	/^static int nck_when_ok(redisReply *reply)$/;"	f	file:
nck_when_one	tests/vrt_produce_data.c	/^static int nck_when_one(redisReply *reply)$/;"	f	file:
nck_when_str	tests/vrt_produce_data.c	/^static int nck_when_str(redisReply *reply)$/;"	f	file:
nck_when_unsigned_integer	tests/vrt_produce_data.c	/^static int nck_when_unsigned_integer(redisReply *reply)$/;"	f	file:
nck_when_zero_or_one	tests/vrt_produce_data.c	/^static int nck_when_zero_or_one(redisReply *reply)$/;"	f	file:
ncurr_cconn	src/vr_client.c	/^int ncurr_cconn = 0;       \/* current # client connections *\/$/;"	v
ncurr_cconn	src/vr_connection.h	/^    uint32_t ncurr_cconn;       \/* current # client connections *\/$/;"	m	struct:conn_base
ncurr_conn	src/vr_connection.h	/^    uint32_t ncurr_conn;        \/* current # connections *\/$/;"	m	struct:conn_base
need_cache_key_proc	tests/vrt_produce_data.h	/^    produce_need_cache_key_proc *need_cache_key_proc;$/;"	m	struct:data_producer
needadmin	src/vr_command.h	/^    int needadmin;$/;"	m	struct:redisCommand
needed_cmd_type_producer	tests/vrt_produce_data.c	/^static darray needed_cmd_type_producer;  \/* type:  data_producer*\/$/;"	v	file:
needed_cmd_type_producer_count	tests/vrt_produce_data.c	/^static unsigned int needed_cmd_type_producer_count;$/;"	v	file:
nelem	dep/darray/darray.h	/^    unsigned long long   nelem;  \/* # element *\/$/;"	m	struct:darray
nerror	dep/util/dlog.h	/^    int  nerror; \/* # log error *\/$/;"	m	struct:logger
net_input_bytes	src/vr_stats.h	/^    long long net_input_bytes; \/* Bytes read from network. *\/$/;"	m	struct:vr_stats
net_output_bytes	src/vr_stats.h	/^    long long net_output_bytes; \/* Bytes written to network. *\/$/;"	m	struct:vr_stats
nexist	src/vr_server.c	/^    int nexist;$/;"	m	struct:keys_statistics	file:
next	dep/ae/ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent
next	dep/dlist/dlist.h	/^    dlistNode *next;$/;"	m	struct:dlistIter
next	dep/dlist/dlist.h	/^    struct dlistNode *next;$/;"	m	struct:dlistNode	typeref:struct:dlistNode::dlistNode
next	src/vr_dict.h	/^    struct dictEntry *next;$/;"	m	struct:dictEntry	typeref:struct:dictEntry::dictEntry
next	src/vr_quicklist.h	/^    struct quicklistNode *next;$/;"	m	struct:quicklistNode	typeref:struct:quicklistNode::quicklistNode
next	src/vr_worker.h	/^    struct connswapunit *next;$/;"	m	struct:connswapunit	typeref:struct:connswapunit::connswapunit
nextEntry	src/vr_dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator
next_client_id	src/vr_eventloop.h	/^    uint64_t next_client_id;    \/* Next client unique ID. Incremental. *\/$/;"	m	struct:vr_eventloop
nfield	tests/vrt_public.c	/^    size_t nfield;$/;"	m	struct:sort_unit	file:
noadminerr	src/vr_server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noadminerr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
noautherr	src/vr_server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noadminerr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
node	src/vr_quicklist.h	/^    quicklistNode *node;$/;"	m	struct:quicklistEntry
node	src/vr_t_zset.h	/^                zskiplistNode *node;$/;"	m	struct:__anon8::__anon9::_iterzset::__anon13
noinline	tests/vrt_benchmark.c	/^    int noinline;$/;"	m	struct:config	file:
nokeyerr	src/vr_server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
non_empty_kcps_count	tests/vrt_produce_data.c	/^static int non_empty_kcps_count = 0;$/;"	v	file:
non_empty_kcps_idx	tests/vrt_produce_data.c	/^unsigned int non_empty_kcps_idx[PRODUCE_KEY_CACHE_POOL_COUNT] = {-1};$/;"	v
noreplicaserr	src/vr_server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noadminerr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
noscripterr	src/vr_server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
not_exist_count	tests/vrt_check_data.c	/^    unsigned int not_exist_count;$/;"	m	struct:check_unit	file:
notifyKeyspaceEvent	src/vr_notify.c	/^void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {$/;"	f
notify_keyspace_events	src/vr_eventloop.h	/^    int notify_keyspace_events; \/* Events to propagate via Pub\/Sub. This is an$/;"	m	struct:vr_eventloop
notify_keyspace_events	src/vr_server.h	/^    int notify_keyspace_events; \/* Events to propagate via Pub\/Sub. This is an$/;"	m	struct:vr_server
notused	src/vr_hyperloglog.c	/^    uint8_t notused[3]; \/* Reserved for future use, must be zero. *\/$/;"	m	struct:hllhdr	file:
npending	dep/ae/ae_evport.c	/^    int     npending;                           \/* # of pending fds *\/$/;"	m	struct:aeApiState	file:
ntotal_conn	src/vr_connection.h	/^    uint64_t ntotal_conn;       \/* total # connections counter from start *\/$/;"	m	struct:conn_base
null_darray	dep/darray/darray.h	14;"	d
nullbulk	src/vr_server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct
nullmultibulk	src/vr_server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct
num	src/vr_worker.h	/^    int num;$/;"	m	struct:connswapunit
num_backend_threads	src/vr_backend.c	/^static int num_backend_threads;$/;"	v	file:
num_worker_threads	src/vr_worker.c	/^static int num_worker_threads;$/;"	v	file:
numclients	tests/vrt_benchmark.c	/^    int numclients;$/;"	m	struct:benchmark_thread	file:
numclients	tests/vrt_benchmark.c	/^    int numclients;$/;"	m	struct:config	file:
numcommands	src/vr_stats.h	/^    long long numcommands;     \/* Number of processed commands *\/$/;"	m	struct:vr_stats
numconnections	src/vr_stats.h	/^    long long numconnections;  \/* Number of connections received *\/$/;"	m	struct:vr_stats
numlines	src/vr_conf.c	/^    int numlines;         \/* Number of lines in current config *\/$/;"	m	struct:rewriteConfigState	file:
numops	src/vr_command.h	/^    int numops;$/;"	m	struct:redisOpArray
numreplicas	src/vr_block.h	/^    int numreplicas;        \/* Number of replicas we are waiting for ACK. *\/$/;"	m	struct:blockingState
obj	src/vr_server.h	/^    robj *obj;$/;"	m	struct:zskiplistNode
objectCommand	src/vr_object.c	/^void objectCommand(client *c) {$/;"	f
objectCommandLookup	src/vr_object.c	/^robj *objectCommandLookup(client *c, robj *key) {$/;"	f
objectCommandLookupOrReply	src/vr_object.c	/^robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {$/;"	f
obuf	dep/himemcached-0.1.0/himemcached.h	/^    char *obuf; \/* Write buffer *\/$/;"	m	struct:mcContext
obuf	tests/vrt_benchmark.c	/^    sds obuf;$/;"	m	struct:_benchmark_client	file:
obuf_soft_limit_reached_time	src/vr_client.h	/^    time_t obuf_soft_limit_reached_time;$/;"	m	struct:client
offset	src/vr_bitops.c	/^    uint64_t offset;    \/* Bitfield offset. *\/$/;"	m	struct:bitfieldOp	file:
offset	src/vr_conf.h	/^    int     offset;     \/* offset of this option field in the struct  *\/$/;"	m	struct:conf_option
offset	src/vr_quicklist.h	/^    int offset;$/;"	m	struct:quicklistEntry
offset	src/vr_quicklist.h	/^    long offset; \/* offset in current ziplist *\/$/;"	m	struct:quicklistIter
ok	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
one_backend_thread_paused	tests/vrt_check_data.c	/^void one_backend_thread_paused(void)$/;"	f
one_check_data_thread_finished	tests/vrt_check_data.c	/^static void one_check_data_thread_finished(void)$/;"	f	file:
one_dispatch_thread_paused	tests/vrt_check_data.c	/^void one_dispatch_thread_paused(void)$/;"	f
one_produce_thread_paused	tests/vrt_check_data.c	/^void one_produce_thread_paused(void)$/;"	f
oomerr	src/vr_server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
opcode	src/vr_bitops.c	/^    int opcode;         \/* Operation id. *\/$/;"	m	struct:bitfieldOp	file:
ops	src/vr_command.h	/^    redisOp *ops;$/;"	m	struct:redisOpArray
optimization_level	src/vr_quicklist.c	/^static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};$/;"	v	file:
optionSetDictType	src/vr_conf.c	/^dictType optionSetDictType = {$/;"	v
optionToLineDictType	src/vr_conf.c	/^dictType optionToLineDictType = {$/;"	v
option_to_line	src/vr_conf.c	/^    dict *option_to_line; \/* Option -> list of config file lines map *\/$/;"	m	struct:rewriteConfigState	file:
organizations	src/vr_conf.h	/^    dict          *organizations;    \/* organizations *\/$/;"	m	struct:vr_conf
orig_commands	src/vr_server.h	/^    dict *orig_commands;        \/* Command table before command renaming. *\/$/;"	m	struct:vr_server
outofcomplexitylimit	src/vr_server.h	/^    *outofcomplexitylimit,$/;"	m	struct:sharedObjectsStruct
outofrangeerr	src/vr_server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
outqueue	src/vr_connection.h	/^    dlist                *outqueue;       \/* outputing response queue *\/$/;"	m	struct:conn
owner	src/vr_connection.h	/^    void                *owner;          \/* connection owner *\/$/;"	m	struct:conn
owtype	src/vr_bitops.c	/^    int owtype;         \/* Overflow type to use. *\/$/;"	m	struct:bitfieldOp	file:
p	src/vr_ziplist.c	/^    unsigned char *p;$/;"	m	struct:zlentry	file:
parent	src/vr_rbtree.h	/^    struct rbnode *parent;   \/* parent link *\/$/;"	m	struct:rbnode	typeref:struct:rbnode::rbnode
parseOptions	tests/vrt_benchmark.c	/^int parseOptions(int argc, const char **argv) {$/;"	f
parseScanCursorOrReply	src/vr_db.c	/^int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {$/;"	f
parse_command_list	tests/vrt_public.c	/^darray *parse_command_list(char *command_list_str)$/;"	f
parse_command_types	tests/vrt_public.c	/^int parse_command_types(char *command_types_str)$/;"	f
path	dep/himemcached-0.1.0/himemcached.h	/^        char *path;$/;"	m	struct:mcContext::__anon4
pattern	src/vr_pubsub.h	/^    robj *pattern;$/;"	m	struct:pubsubPattern
pause	tests/vrt_backend.h	/^    int pause;$/;"	m	struct:backend_thread
pause	tests/vrt_dispatch_data.h	/^    int pause;$/;"	m	struct:dispatch_data_thread
pause	tests/vrt_produce_data.c	/^    int pause;$/;"	m	struct:produce_thread	file:
pauseClients	src/vr_client.c	/^void pauseClients(vr_eventloop *vel, long long end) {$/;"	f
peak_memory	src/vr_stats.h	/^    size_t    peak_memory;     \/* Max used memory record *\/$/;"	m	struct:vr_stats
peerid	src/vr_client.h	/^    sds peerid;             \/* Cached peer ID. *\/$/;"	m	struct:client
pending	tests/vrt_benchmark.c	/^    int pending;            \/* Number of pending requests (replies to consume) *\/$/;"	m	struct:_benchmark_client	file:
pending_fds	dep/ae/ae_evport.c	/^    int     pending_fds[MAX_EVENT_BATCHSZ];     \/* pending fds *\/$/;"	m	struct:aeApiState	file:
pending_masks	dep/ae/ae_evport.c	/^    int     pending_masks[MAX_EVENT_BATCHSZ];   \/* pending fds' masks *\/$/;"	m	struct:aeApiState	file:
perm	src/vr_listen.h	/^    mode_t perm;            \/* socket permissions *\/$/;"	m	struct:vr_listen
persistCommand	src/vr_db.c	/^void persistCommand(client *c) {$/;"	f
pexpireCommand	src/vr_db.c	/^void pexpireCommand(client *c) {$/;"	f
pexpireatCommand	src/vr_db.c	/^void pexpireatCommand(client *c) {$/;"	f
pfaddCommand	src/vr_hyperloglog.c	/^void pfaddCommand(client *c) {$/;"	f
pfcountCommand	src/vr_hyperloglog.c	/^void pfcountCommand(client *c) {$/;"	f
pfdebugCommand	src/vr_hyperloglog.c	/^void pfdebugCommand(client *c) {$/;"	f
pfmergeCommand	src/vr_hyperloglog.c	/^void pfmergeCommand(client *c) {$/;"	f
pfselftestCommand	src/vr_hyperloglog.c	/^void pfselftestCommand(client *c) {$/;"	f
pid	src/vr_core.h	/^    pid_t           pid;                         \/* process id *\/$/;"	m	struct:instance
pid	src/vr_server.h	/^    pid_t pid;                  \/* Main process pid. *\/$/;"	m	struct:vr_server
pid	tests/vrt_public.h	/^    int pid;$/;"	m	struct:vire_instance
pid	tests/vrtest.c	/^    int pid;$/;"	m	struct:config	file:
pid_file	tests/vrt_public.h	/^    sds pid_file;$/;"	m	struct:vire_instance
pid_filename	src/vr_core.h	/^    char            *pid_filename;               \/* pid filename *\/$/;"	m	struct:instance
pid_filename	tests/vrabtest.c	/^    char *pid_filename;$/;"	m	struct:config	file:
pid_filename	tests/vrtest.c	/^    char *pid_filename;$/;"	m	struct:config	file:
pidfile	src/vr_core.h	/^    unsigned        pidfile:1;                   \/* pid file created? *\/$/;"	m	struct:instance
pidfile	src/vr_server.h	/^    char *pidfile;              \/* PID file path *\/$/;"	m	struct:vr_server
pidfile	tests/vrtest.c	/^    int pidfile;$/;"	m	struct:config	file:
pingCommand	src/vr_server.c	/^void pingCommand(client *c) {$/;"	f
pipeline	tests/vrt_benchmark.c	/^    int pipeline;$/;"	m	struct:config	file:
plus	src/vr_server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
pmessagebulk	src/vr_server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
pmutex	tests/vrt_public.h	/^    pthread_mutex_t pmutex;$/;"	m	struct:key_cache_array
pong	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
pop	src/vr_ziplist.c	/^static unsigned char *pop(unsigned char *zl, int where) {$/;"	f	file:
popGenericCommand	src/vr_t_list.c	/^void popGenericCommand(client *c, int where) {$/;"	f
populateCommandTable	src/vr_command.c	/^void populateCommandTable(void) {$/;"	f
populateCommandsNeedAdminpass	src/vr_command.c	/^int populateCommandsNeedAdminpass(void) {$/;"	f
port	dep/himemcached-0.1.0/himemcached.h	/^        int port;$/;"	m	struct:mcContext::__anon3
port	src/vr_conf.h	/^    int           port;$/;"	m	struct:conf_server
port	src/vr_listen.h	/^    int port;               \/* port *\/$/;"	m	struct:vr_listen
port	src/vr_server.h	/^    int port;                   \/* TCP listening port *\/$/;"	m	struct:vr_server
port	tests/vrabtest.h	/^    int port;$/;"	m	struct:abtest_server
port	tests/vrt_public.h	/^    int port;$/;"	m	struct:vire_instance
portfd	dep/ae/ae_evport.c	/^    int     portfd;                             \/* event port *\/$/;"	m	struct:aeApiState	file:
pos	dep/himemcached-0.1.0/himcread.h	/^    size_t pos; \/* Buffer cursor *\/$/;"	m	struct:mcReader
prefix_pending	tests/vrt_benchmark.c	/^    int prefix_pending;     \/* If non-zero, number of pending prefix commands. Commands$/;"	m	struct:_benchmark_client	file:
prefixlen	tests/vrt_benchmark.c	/^    int prefixlen;          \/* Size in bytes of the pending prefix commands *\/$/;"	m	struct:_benchmark_client	file:
prepareClientToWrite	src/vr_client.c	/^int prepareClientToWrite(client *c) {$/;"	f
prev	dep/dlist/dlist.h	/^    struct dlistNode *prev;$/;"	m	struct:dlistNode	typeref:struct:dlistNode::dlistNode
prev	src/vr_quicklist.h	/^    struct quicklistNode *prev;$/;"	m	struct:quicklistNode	typeref:struct:quicklistNode::quicklistNode
preventCommandAOF	src/vr_command.c	/^void preventCommandAOF(client *c) {$/;"	f
preventCommandPropagation	src/vr_command.c	/^void preventCommandPropagation(client *c) {$/;"	f
preventCommandReplication	src/vr_command.c	/^void preventCommandReplication(client *c) {$/;"	f
prevrawlen	src/vr_ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	struct:zlentry	file:
prevrawlensize	src/vr_ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	struct:zlentry	file:
printBits	src/vr_bitops.c	/^void printBits(unsigned char *p, unsigned long count) {$/;"	f
print_producer_command	tests/vrt_produce_data.c	/^void print_producer_command(data_unit *du)$/;"	f
privdata	dep/himemcached-0.1.0/himcread.h	/^    void *privdata;$/;"	m	struct:mcReader
privdata	src/vr_dict.h	/^    void *privdata;$/;"	m	struct:dict
proc	src/vr_command.h	/^    redisCommandProc *proc;$/;"	m	struct:redisCommand
proc	tests/vrt_produce_data.h	/^    redis_command_proc *proc;$/;"	m	struct:data_producer
processCommand	src/vr_command.c	/^int processCommand(client *c) {$/;"	f
processEventsWhileBlocked	src/vr_client.c	/^int processEventsWhileBlocked(vr_eventloop *vel) {$/;"	f
processInlineBuffer	src/vr_client.c	/^int processInlineBuffer(client *c) {$/;"	f
processInputBuffer	src/vr_client.c	/^void processInputBuffer(client *c) {$/;"	f
processMultibulkBuffer	src/vr_client.c	/^int processMultibulkBuffer(client *c) {$/;"	f
processTimeEvents	dep/ae/ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	file:
produce_data_threads	tests/vrabtest.c	/^    int produce_data_threads;$/;"	m	struct:config	file:
produce_data_threads_count	tests/vrt_produce_data.c	/^int produce_data_threads_count;$/;"	v
produce_need_cache_key_proc	tests/vrt_produce_data.h	/^typedef int produce_need_cache_key_proc(struct redisReply *reply);$/;"	t
produce_scheme	tests/vrt_produce_data.h	/^typedef struct produce_scheme {$/;"	s
produce_scheme	tests/vrt_produce_data.h	/^} produce_scheme;$/;"	t	typeref:struct:produce_scheme
produce_scheme_create	tests/vrt_produce_data.c	/^static produce_scheme *produce_scheme_create(long long max_cached_keys, int hit_ratio)$/;"	f	file:
produce_scheme_destroy	tests/vrt_produce_data.c	/^static void produce_scheme_destroy(produce_scheme *ps)$/;"	f	file:
produce_thread	tests/vrt_produce_data.c	/^typedef struct produce_thread {$/;"	s	file:
produce_thread	tests/vrt_produce_data.c	/^} produce_thread;$/;"	t	typeref:struct:produce_thread	file:
produce_threads	tests/vrt_produce_data.c	/^static darray produce_threads;$/;"	v	file:
produce_threads_pause_finished_count	tests/vrt_produce_data.c	/^int produce_threads_pause_finished_count;$/;"	v
producers_count	tests/vrt_produce_data.c	/^static int producers_count;$/;"	v	file:
propagate	src/vr_command.c	/^void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f
propagateExpire	src/vr_db.c	/^void propagateExpire(redisDb *db, robj *key) {$/;"	f
protocol	tests/vrt_benchmark.c	/^    int protocol;$/;"	m	struct:config	file:
ps	tests/vrt_produce_data.c	/^    produce_scheme *ps;$/;"	m	struct:produce_thread	file:
psetexCommand	src/vr_t_string.c	/^void psetexCommand(client *c) {$/;"	f
psetex_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *psetex_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
psubscribeCommand	src/vr_pubsub.c	/^void psubscribeCommand(client *c) {$/;"	f
psubscribebulk	src/vr_server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
psync_initial_offset	src/vr_client.h	/^    long long psync_initial_offset; \/* FULLRESYNC reply offset other slaves$/;"	m	struct:client
ptr	src/vr_object.h	/^    void *ptr;$/;"	m	struct:vr_object
pttlCommand	src/vr_db.c	/^void pttlCommand(client *c) {$/;"	f
pttl_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *pttl_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
pubsubPattern	src/vr_pubsub.h	/^typedef struct pubsubPattern {$/;"	s
pubsubPattern	src/vr_pubsub.h	/^} pubsubPattern;$/;"	t	typeref:struct:pubsubPattern
pubsubPublishMessage	src/vr_pubsub.c	/^int pubsubPublishMessage(robj *channel, robj *message) {$/;"	f
pubsubSubscribeChannel	src/vr_pubsub.c	/^int pubsubSubscribeChannel(client *c, robj *channel) {$/;"	f
pubsubSubscribePattern	src/vr_pubsub.c	/^int pubsubSubscribePattern(client *c, robj *pattern) {$/;"	f
pubsubUnsubscribeAllChannels	src/vr_pubsub.c	/^int pubsubUnsubscribeAllChannels(client *c, int notify) {$/;"	f
pubsubUnsubscribeAllPatterns	src/vr_pubsub.c	/^int pubsubUnsubscribeAllPatterns(client *c, int notify) {$/;"	f
pubsubUnsubscribeChannel	src/vr_pubsub.c	/^int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {$/;"	f
pubsubUnsubscribePattern	src/vr_pubsub.c	/^int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {$/;"	f
pubsub_channels	src/vr_client.h	/^    dict *pubsub_channels;  \/* channels a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:client
pubsub_channels	src/vr_eventloop.h	/^    dict *pubsub_channels;  \/* Map channels to list of subscribed clients *\/$/;"	m	struct:vr_eventloop
pubsub_channels	src/vr_server.h	/^    dict *pubsub_channels;  \/* Map channels to list of subscribed clients *\/$/;"	m	struct:vr_server
pubsub_patterns	src/vr_client.h	/^    dlist *pubsub_patterns;  \/* patterns a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:client
pubsub_patterns	src/vr_eventloop.h	/^    dlist *pubsub_patterns;  \/* A list of pubsub_patterns *\/$/;"	m	struct:vr_eventloop
pubsub_patterns	src/vr_server.h	/^    dlist *pubsub_patterns;  \/* A list of pubsub_patterns *\/$/;"	m	struct:vr_server
punsubscribeCommand	src/vr_pubsub.c	/^void punsubscribeCommand(client *c) {$/;"	f
punsubscribebulk	src/vr_server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
pushGenericCommand	src/vr_t_list.c	/^void pushGenericCommand(client *c, int where) {$/;"	f
pushxGenericCommand	src/vr_t_list.c	/^void pushxGenericCommand(client *c, robj *refval, robj *val, int where) {$/;"	f
putSlaveOnline	src/vr_replication.c	/^void putSlaveOnline(client *slave) {$/;"	f
qsortCompareSetsByCardinality	src/vr_t_set.c	/^int qsortCompareSetsByCardinality(const void *s1, const void *s2) {$/;"	f
qsortCompareSetsByRevCardinality	src/vr_t_set.c	/^int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {$/;"	f
querybuf	src/vr_client.h	/^    sds querybuf;           \/* Buffer we use to accumulate client queries. *\/$/;"	m	struct:client
querybuf_peak	src/vr_client.h	/^    size_t querybuf_peak;   \/* Recent (100ms or more) peak of querybuf size. *\/$/;"	m	struct:client
queueMultiCommand	src/vr_multi.c	/^void queueMultiCommand(client *c) {$/;"	f
queued	src/vr_server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct
quicklist	src/vr_quicklist.h	/^    const quicklist *quicklist;$/;"	m	struct:quicklistEntry
quicklist	src/vr_quicklist.h	/^    const quicklist *quicklist;$/;"	m	struct:quicklistIter
quicklist	src/vr_quicklist.h	/^typedef struct quicklist {$/;"	s
quicklist	src/vr_quicklist.h	/^} quicklist;$/;"	t	typeref:struct:quicklist
quicklistAllowsCompression	src/vr_quicklist.c	226;"	d	file:
quicklistAppendValuesFromZiplist	src/vr_quicklist.c	/^quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,$/;"	f
quicklistAppendZiplist	src/vr_quicklist.c	/^void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {$/;"	f
quicklistCompare	src/vr_quicklist.c	/^int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {$/;"	f
quicklistCompress	src/vr_quicklist.c	300;"	d	file:
quicklistCompressNode	src/vr_quicklist.c	173;"	d	file:
quicklistCount	src/vr_quicklist.c	/^unsigned int quicklistCount(quicklist *ql) { return ql->count; }$/;"	f
quicklistCreate	src/vr_quicklist.c	/^quicklist *quicklistCreate(void) {$/;"	f
quicklistCreateFromZiplist	src/vr_quicklist.c	/^quicklist *quicklistCreateFromZiplist(int fill, int compress,$/;"	f
quicklistCreateNode	src/vr_quicklist.c	/^REDIS_STATIC quicklistNode *quicklistCreateNode(void) {$/;"	f
quicklistDecompressNode	src/vr_quicklist.c	201;"	d	file:
quicklistDecompressNodeForUse	src/vr_quicklist.c	209;"	d	file:
quicklistDelEntry	src/vr_quicklist.c	/^void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {$/;"	f
quicklistDelIndex	src/vr_quicklist.c	/^REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,$/;"	f
quicklistDelRange	src/vr_quicklist.c	/^int quicklistDelRange(quicklist *quicklist, const long start,$/;"	f
quicklistDeleteIfEmpty	src/vr_quicklist.c	538;"	d	file:
quicklistDup	src/vr_quicklist.c	/^quicklist *quicklistDup(quicklist *orig) {$/;"	f
quicklistEntry	src/vr_quicklist.h	/^typedef struct quicklistEntry {$/;"	s
quicklistEntry	src/vr_quicklist.h	/^} quicklistEntry;$/;"	t	typeref:struct:quicklistEntry
quicklistGetIterator	src/vr_quicklist.c	/^quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction) {$/;"	f
quicklistGetIteratorAtIdx	src/vr_quicklist.c	/^quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist,$/;"	f
quicklistGetLzf	src/vr_quicklist.c	/^size_t quicklistGetLzf(const quicklistNode *node, void **data) {$/;"	f
quicklistIndex	src/vr_quicklist.c	/^int quicklistIndex(const quicklist *quicklist, const long long idx,$/;"	f
quicklistInsertAfter	src/vr_quicklist.c	/^void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,$/;"	f
quicklistInsertBefore	src/vr_quicklist.c	/^void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *entry,$/;"	f
quicklistIter	src/vr_quicklist.h	/^typedef struct quicklistIter {$/;"	s
quicklistIter	src/vr_quicklist.h	/^} quicklistIter;$/;"	t	typeref:struct:quicklistIter
quicklistLZF	src/vr_quicklist.h	/^typedef struct quicklistLZF {$/;"	s
quicklistLZF	src/vr_quicklist.h	/^} quicklistLZF;$/;"	t	typeref:struct:quicklistLZF
quicklistNew	src/vr_quicklist.c	/^quicklist *quicklistNew(int fill, int compress) {$/;"	f
quicklistNext	src/vr_quicklist.c	/^int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {$/;"	f
quicklistNode	src/vr_quicklist.h	/^typedef struct quicklistNode {$/;"	s
quicklistNode	src/vr_quicklist.h	/^} quicklistNode;$/;"	t	typeref:struct:quicklistNode
quicklistNodeIsCompressed	src/vr_quicklist.h	84;"	d
quicklistNodeUpdateSz	src/vr_quicklist.c	438;"	d	file:
quicklistPop	src/vr_quicklist.c	/^int quicklistPop(quicklist *quicklist, int where, unsigned char **data,$/;"	f
quicklistPopCustom	src/vr_quicklist.c	/^int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,$/;"	f
quicklistPush	src/vr_quicklist.c	/^void quicklistPush(quicklist *quicklist, void *value, const size_t sz,$/;"	f
quicklistPushHead	src/vr_quicklist.c	/^int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {$/;"	f
quicklistPushTail	src/vr_quicklist.c	/^int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {$/;"	f
quicklistRecompressOnly	src/vr_quicklist.c	309;"	d	file:
quicklistRelease	src/vr_quicklist.c	/^void quicklistRelease(quicklist *quicklist) {$/;"	f
quicklistReleaseIterator	src/vr_quicklist.c	/^void quicklistReleaseIterator(quicklistIter *iter) {$/;"	f
quicklistReplaceAtIndex	src/vr_quicklist.c	/^int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,$/;"	f
quicklistRotate	src/vr_quicklist.c	/^void quicklistRotate(quicklist *quicklist) {$/;"	f
quicklistSetCompressDepth	src/vr_quicklist.c	/^void quicklistSetCompressDepth(quicklist *quicklist, int compress) {$/;"	f
quicklistSetFill	src/vr_quicklist.c	/^void quicklistSetFill(quicklist *quicklist, int fill) {$/;"	f
quicklistSetOptions	src/vr_quicklist.c	/^void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {$/;"	f
quiet	tests/vrt_benchmark.c	/^    int quiet;$/;"	m	struct:config	file:
randfree	tests/vrt_benchmark.c	/^    size_t randfree;        \/* Number of unused pointers in client->randptr *\/$/;"	m	struct:_benchmark_client	file:
randlen	tests/vrt_benchmark.c	/^    size_t randlen;         \/* Number of pointers in client->randptr *\/$/;"	m	struct:_benchmark_client	file:
random_dispatch	dep/dhashkit/drandom.c	/^random_dispatch(struct continuum *continuum, uint32_t ncontinuum, uint32_t hash)$/;"	f
randomizeClientKey	tests/vrt_benchmark.c	/^static void randomizeClientKey(benchmark_client c) {$/;"	f	file:
randomkeyCommand	src/vr_db.c	/^void randomkeyCommand(client *c) {$/;"	f
randomkeys	tests/vrt_benchmark.c	/^    int randomkeys;$/;"	m	struct:config	file:
randomkeys_keyspacelen	tests/vrt_benchmark.c	/^    int randomkeys_keyspacelen;$/;"	m	struct:config	file:
randptr	tests/vrt_benchmark.c	/^    char **randptr;         \/* Pointers to :rand: strings inside the command buf *\/$/;"	m	struct:_benchmark_client	file:
randstring	src/vr_ziplist.c	/^static int randstring(char *target, unsigned int min, unsigned int max) {$/;"	f	file:
rbnode	src/vr_rbtree.h	/^struct rbnode {$/;"	s
rbtree	src/vr_rbtree.h	/^struct rbtree {$/;"	s
rbtree_black	src/vr_rbtree.h	5;"	d
rbtree_copy_color	src/vr_rbtree.h	8;"	d
rbtree_delete	src/vr_rbtree.c	/^rbtree_delete(struct rbtree *tree, struct rbnode *node)$/;"	f
rbtree_init	src/vr_rbtree.c	/^rbtree_init(struct rbtree *tree, struct rbnode *node)$/;"	f
rbtree_insert	src/vr_rbtree.c	/^rbtree_insert(struct rbtree *tree, struct rbnode *node)$/;"	f
rbtree_is_black	src/vr_rbtree.h	7;"	d
rbtree_is_red	src/vr_rbtree.h	6;"	d
rbtree_left_rotate	src/vr_rbtree.c	/^rbtree_left_rotate(struct rbnode **root, struct rbnode *sentinel,$/;"	f	file:
rbtree_min	src/vr_rbtree.c	/^rbtree_min(struct rbtree *tree)$/;"	f
rbtree_node_init	src/vr_rbtree.c	/^rbtree_node_init(struct rbnode *node)$/;"	f
rbtree_node_min	src/vr_rbtree.c	/^rbtree_node_min(struct rbnode *node, struct rbnode *sentinel)$/;"	f	file:
rbtree_red	src/vr_rbtree.h	4;"	d
rbtree_right_rotate	src/vr_rbtree.c	/^rbtree_right_rotate(struct rbnode **root, struct rbnode *sentinel,$/;"	f	file:
rc	tests/vrt_benchmark.c	/^    redisContext *rc;$/;"	m	struct:_benchmark_client	file:
rdatas	tests/vrt_dispatch_data.h	/^    struct dlist *rdatas;   \/* Value is reply_unit, used to cache data $/;"	m	struct:dispatch_data_thread	typeref:struct:dispatch_data_thread::dlist
rdbRemoveTempFile	src/vr_rdb.c	/^void rdbRemoveTempFile(pid_t childpid) {$/;"	f
rdbSave	src/vr_rdb.c	/^int rdbSave(char *filename) {$/;"	f
rdb_checksum	src/vr_server.h	/^    int rdb_checksum;               \/* Use RDB checksum? *\/$/;"	m	struct:vr_server
rdb_child_pid	src/vr_server.h	/^    pid_t rdb_child_pid;            \/* PID of RDB saving child *\/$/;"	m	struct:vr_server
rdb_child_type	src/vr_server.h	/^    int rdb_child_type;             \/* Type of save by active child. *\/$/;"	m	struct:vr_server
rdb_compression	src/vr_server.h	/^    int rdb_compression;            \/* Use compression in RDB? *\/$/;"	m	struct:vr_server
rdb_filename	src/vr_server.h	/^    char *rdb_filename;             \/* Name of RDB file *\/$/;"	m	struct:vr_server
rdb_pipe_read_result_from_child	src/vr_server.h	/^    int rdb_pipe_read_result_from_child; \/* of each slave in diskless SYNC. *\/$/;"	m	struct:vr_server
rdb_pipe_write_result_to_parent	src/vr_server.h	/^    int rdb_pipe_write_result_to_parent; \/* RDB pipes used to return the state *\/$/;"	m	struct:vr_server
rdb_save_time_last	src/vr_server.h	/^    time_t rdb_save_time_last;      \/* Time used by last RDB save run. *\/$/;"	m	struct:vr_server
rdb_save_time_start	src/vr_server.h	/^    time_t rdb_save_time_start;     \/* Current RDB save start time. *\/$/;"	m	struct:vr_server
readHandler	tests/vrt_benchmark.c	/^static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
readHandlerMC	tests/vrt_benchmark.c	/^static void readHandlerMC(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
readQueryFromClient	src/vr_client.c	/^void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
reader	dep/himemcached-0.1.0/himemcached.h	/^    mcReader *reader; \/* Protocol reader *\/$/;"	m	struct:mcContext
readyList	src/vr_server.h	/^typedef struct readyList {$/;"	s
readyList	src/vr_server.h	/^} readyList;$/;"	t	typeref:struct:readyList
ready_keys	src/vr_db.h	/^    dict *ready_keys;           \/* Blocked keys that received a PUSH *\/$/;"	m	struct:redisDb
ready_keys	src/vr_server.h	/^    dlist *ready_keys;        \/* List of readyList structures for BLPOP & co *\/$/;"	m	struct:vr_server
received_count	tests/vrt_dispatch_data.c	/^    int received_count;$/;"	m	struct:reply_unit	file:
recompress	src/vr_quicklist.h	/^    unsigned int recompress : 1; \/* was this node previous compressed? *\/$/;"	m	struct:quicklistNode
recv_active	src/vr_connection.h	/^    unsigned            recv_active:1;   \/* recv active? *\/$/;"	m	struct:conn
recv_bytes	src/vr_connection.h	/^    size_t              recv_bytes;      \/* received (read) bytes *\/$/;"	m	struct:conn
recv_ready	src/vr_connection.h	/^    unsigned            recv_ready:1;    \/* recv ready? *\/$/;"	m	struct:conn
redisBitpos	src/vr_bitops.c	/^long redisBitpos(void *s, unsigned long count, int bit) {$/;"	f
redisCommand	src/vr_command.h	/^struct redisCommand {$/;"	s
redisCommandProc	src/vr_command.h	/^typedef void redisCommandProc(struct client *c);$/;"	t
redisCommandTable	src/vr_command.c	/^struct redisCommand redisCommandTable[] = {$/;"	v	typeref:struct:redisCommand
redisDb	src/vr_db.h	/^typedef struct redisDb {$/;"	s
redisDb	src/vr_db.h	/^} redisDb;$/;"	t	typeref:struct:redisDb
redisDbDeinit	src/vr_db.c	/^redisDbDeinit(redisDb *db)$/;"	f
redisDbInit	src/vr_db.c	/^int redisDbInit(redisDb *db)$/;"	f
redisGetKeysProc	src/vr_command.h	/^typedef int *redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	t
redisOp	src/vr_command.h	/^typedef struct redisOp {$/;"	s
redisOp	src/vr_command.h	/^} redisOp;$/;"	t	typeref:struct:redisOp
redisOpArray	src/vr_command.h	/^typedef struct redisOpArray {$/;"	s
redisOpArray	src/vr_command.h	/^} redisOpArray;$/;"	t	typeref:struct:redisOpArray
redisOpArrayAppend	src/vr_command.c	/^int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,$/;"	f
redisOpArrayFree	src/vr_command.c	/^void redisOpArrayFree(redisOpArray *oa) {$/;"	f
redisOpArrayInit	src/vr_command.c	/^void redisOpArrayInit(redisOpArray *oa) {$/;"	f
redisPopcount	src/vr_bitops.c	/^size_t redisPopcount(void *s, long count) {$/;"	f
redis_command_proc	tests/vrt_produce_data.h	/^typedef struct data_unit *redis_command_proc(struct data_producer *dp, struct produce_scheme *ps);$/;"	t	typeref:struct:redis_command_proc
redis_data_producer_table	tests/vrt_produce_data.c	/^data_producer redis_data_producer_table[] = {$/;"	v
redis_get_keys_proc	tests/vrt_produce_data.h	/^typedef int *redis_get_keys_proc(struct data_producer *dp, sds *argv, int argc, int *numkeys);$/;"	t
refcount	src/vr_object.h	/^    int refcount;$/;"	m	struct:vr_object
refreshGoodSlavesCount	src/vr_replication.c	/^void refreshGoodSlavesCount(void) {$/;"	f
registers	src/vr_hyperloglog.c	/^    uint8_t registers[]; \/* Data bytes. *\/$/;"	m	struct:hllhdr	file:
rehash_db	src/vr_backend.h	/^    unsigned int rehash_db;$/;"	m	struct:vr_backend
rehash_db	src/vr_worker.h	/^    unsigned int rehash_db;$/;"	m	struct:vr_worker
rehashidx	src/vr_dict.h	/^    long rehashidx; \/* rehashing not in progress if rehashidx == -1 *\/$/;"	m	struct:dict
rejected_conn	src/vr_stats.h	/^    long long rejected_conn;   \/* Clients rejected because of maxclients *\/$/;"	m	struct:vr_stats
removeExpire	src/vr_db.c	/^int removeExpire(redisDb *db, robj *key) {$/;"	f
renameCommand	src/vr_db.c	/^void renameCommand(client *c) {$/;"	f
renameGenericCommand	src/vr_db.c	/^void renameGenericCommand(client *c, int nx) {$/;"	f
renamenxCommand	src/vr_db.c	/^void renamenxCommand(client *c) {$/;"	f
repl	src/vr_replication.c	/^struct vr_replication repl;$/;"	v	typeref:struct:vr_replication
repl_ack_off	src/vr_client.h	/^    long long repl_ack_off; \/* Replication ack offset, if this is a slave. *\/$/;"	m	struct:client
repl_ack_time	src/vr_client.h	/^    long long repl_ack_time;\/* Replication ack time, if this is a slave. *\/$/;"	m	struct:client
repl_backlog	src/vr_replication.h	/^    char *repl_backlog;             \/* Replication backlog for partial syncs *\/$/;"	m	struct:vr_replication
repl_backlog_histlen	src/vr_replication.h	/^    long long repl_backlog_histlen; \/* Backlog actual data length *\/$/;"	m	struct:vr_replication
repl_backlog_idx	src/vr_replication.h	/^    long long repl_backlog_idx;     \/* Backlog circular buffer current offset *\/$/;"	m	struct:vr_replication
repl_backlog_off	src/vr_replication.h	/^    long long repl_backlog_off;     \/* Replication offset of first byte in the$/;"	m	struct:vr_replication
repl_backlog_size	src/vr_replication.h	/^    long long repl_backlog_size;    \/* Backlog circular buffer size *\/$/;"	m	struct:vr_replication
repl_backlog_time_limit	src/vr_replication.h	/^    time_t repl_backlog_time_limit; \/* Time without slaves after the backlog$/;"	m	struct:vr_replication
repl_disable_tcp_nodelay	src/vr_replication.h	/^    int repl_disable_tcp_nodelay;   \/* Disable TCP_NODELAY after SYNC? *\/$/;"	m	struct:vr_replication
repl_diskless_sync	src/vr_replication.h	/^    int repl_diskless_sync;         \/* Send RDB to slaves sockets directly. *\/$/;"	m	struct:vr_replication
repl_diskless_sync_delay	src/vr_replication.h	/^    int repl_diskless_sync_delay;   \/* Delay to start a diskless repl BGSAVE. *\/$/;"	m	struct:vr_replication
repl_down_since	src/vr_replication.h	/^    time_t repl_down_since; \/* Unix time at which link with master went down *\/$/;"	m	struct:vr_replication
repl_good_slaves_count	src/vr_replication.h	/^    int repl_good_slaves_count;     \/* Number of slaves with lag <= max_lag. *\/$/;"	m	struct:vr_replication
repl_master_initial_offset	src/vr_replication.h	/^    long long repl_master_initial_offset;         \/* Master PSYNC offset. *\/$/;"	m	struct:vr_replication
repl_master_runid	src/vr_replication.h	/^    char repl_master_runid[CONFIG_RUN_ID_SIZE+1];  \/* Master run id for PSYNC. *\/$/;"	m	struct:vr_replication
repl_min_slaves_max_lag	src/vr_replication.h	/^    int repl_min_slaves_max_lag;    \/* Max lag of <count> slaves to write. *\/$/;"	m	struct:vr_replication
repl_min_slaves_to_write	src/vr_replication.h	/^    int repl_min_slaves_to_write;   \/* Min number of slaves to write. *\/$/;"	m	struct:vr_replication
repl_no_slaves_since	src/vr_replication.h	/^    time_t repl_no_slaves_since;    \/* We have no slaves since that time.$/;"	m	struct:vr_replication
repl_ping_slave_period	src/vr_replication.h	/^    int repl_ping_slave_period;     \/* Master pings the slave every N seconds *\/$/;"	m	struct:vr_replication
repl_put_online_on_ack	src/vr_client.h	/^    int repl_put_online_on_ack; \/* Install slave write handler on ACK. *\/$/;"	m	struct:client
repl_serve_stale_data	src/vr_replication.h	/^    int repl_serve_stale_data; \/* Serve stale data when link is down? *\/$/;"	m	struct:vr_replication
repl_slave_ro	src/vr_replication.h	/^    int repl_slave_ro;          \/* Slave is read only? *\/$/;"	m	struct:vr_replication
repl_state	src/vr_replication.h	/^    int repl_state;          \/* Replication status if the instance is a slave *\/$/;"	m	struct:vr_replication
repl_syncio_timeout	src/vr_replication.h	/^    int repl_syncio_timeout; \/* Timeout for synchronous I\/O calls *\/$/;"	m	struct:vr_replication
repl_timeout	src/vr_replication.h	/^    int repl_timeout;               \/* Timeout after N seconds of master idle *\/$/;"	m	struct:vr_replication
repl_transfer_fd	src/vr_replication.h	/^    int repl_transfer_fd;    \/* Slave -> Master SYNC temp file descriptor *\/$/;"	m	struct:vr_replication
repl_transfer_last_fsync_off	src/vr_replication.h	/^    off_t repl_transfer_last_fsync_off; \/* Offset when we fsync-ed last time. *\/$/;"	m	struct:vr_replication
repl_transfer_lastio	src/vr_replication.h	/^    time_t repl_transfer_lastio; \/* Unix time of the latest read, for timeout *\/$/;"	m	struct:vr_replication
repl_transfer_read	src/vr_replication.h	/^    off_t repl_transfer_read; \/* Amount of RDB read from master during sync. *\/$/;"	m	struct:vr_replication
repl_transfer_s	src/vr_replication.h	/^    int repl_transfer_s;     \/* Slave -> Master SYNC socket *\/$/;"	m	struct:vr_replication
repl_transfer_size	src/vr_replication.h	/^    off_t repl_transfer_size; \/* Size of RDB to read from master during sync. *\/$/;"	m	struct:vr_replication
repl_transfer_tmpfile	src/vr_replication.h	/^    char *repl_transfer_tmpfile; \/* Slave-> master SYNC temp file name *\/$/;"	m	struct:vr_replication
replaceClientCommandVector	src/vr_client.c	/^void replaceClientCommandVector(client *c, int argc, robj **argv) {$/;"	f
replconfCommand	src/vr_replication.c	/^void replconfCommand(client *c) {$/;"	f
repldbfd	src/vr_client.h	/^    int repldbfd;           \/* Replication DB file descriptor. *\/$/;"	m	struct:client
repldboff	src/vr_client.h	/^    off_t repldboff;        \/* Replication DB file offset. *\/$/;"	m	struct:client
repldbsize	src/vr_client.h	/^    off_t repldbsize;       \/* Replication DB file size. *\/$/;"	m	struct:client
replicationCacheMaster	src/vr_replication.c	/^void replicationCacheMaster(client *c) {$/;"	f
replicationFeedMonitors	src/vr_replication.c	/^void replicationFeedMonitors(client *c, dlist *monitors, int dictid, robj **argv, int argc) {$/;"	f
replicationFeedSlaves	src/vr_replication.c	/^void replicationFeedSlaves(dlist *slaves, int dictid, robj **argv, int argc) {$/;"	f
replicationGetSlaveName	src/vr_replication.c	/^char *replicationGetSlaveName(client *c) {$/;"	f
replicationHandleMasterDisconnection	src/vr_replication.c	/^void replicationHandleMasterDisconnection(void) {$/;"	f
replicationSendAck	src/vr_replication.c	/^void replicationSendAck(void) {$/;"	f
reploff	src/vr_client.h	/^    long long reploff;      \/* Replication offset if this is our master. *\/$/;"	m	struct:client
reploffset	src/vr_block.h	/^    long long reploffset;   \/* Replication offset to reach. *\/$/;"	m	struct:blockingState
replpreamble	src/vr_client.h	/^    sds replpreamble;       \/* Replication DB preamble. *\/$/;"	m	struct:client
replrunid	src/vr_client.h	/^    char replrunid[CONFIG_RUN_ID_SIZE+1]; \/* Master run id if is a master. *\/$/;"	m	struct:client
replstate	src/vr_client.h	/^    int replstate;          \/* Replication state if this is a slave. *\/$/;"	m	struct:client
reply	src/vr_client.h	/^    dlist *reply;            \/* List of reply objects to send to the client. *\/$/;"	m	struct:client
reply_bytes	src/vr_client.h	/^    unsigned long long reply_bytes; \/* Tot bytes of objects in reply list. *\/$/;"	m	struct:client
reply_callback	tests/vrt_dispatch_data.c	/^static void reply_callback(redisAsyncContext *c, void *r, void *privdata) {$/;"	f	file:
reply_string_binary_compare	tests/vrt_public.c	/^int reply_string_binary_compare(const void *r1,const void *r2)$/;"	f
reply_total_count_per_cycle	tests/vrt_dispatch_data.h	/^    long long reply_total_count_per_cycle;$/;"	m	struct:dispatch_data_thread
reply_type_err_count_per_cycle	tests/vrt_dispatch_data.h	/^    long long reply_type_err_count_per_cycle;$/;"	m	struct:dispatch_data_thread
reply_unit	tests/vrt_dispatch_data.c	/^typedef struct reply_unit {$/;"	s	file:
reply_unit	tests/vrt_dispatch_data.c	/^} reply_unit;$/;"	t	typeref:struct:reply_unit	file:
replys	tests/vrt_check_data.c	/^    darray replys;  \/* Used to cache the replys from the servers, type is pointer of redisReply *\/$/;"	m	struct:check_unit	file:
replys	tests/vrt_dispatch_data.c	/^    redisReply **replys;$/;"	m	struct:reply_unit	file:
replys_count	tests/vrt_check_data.c	/^    unsigned int replys_count;$/;"	m	struct:check_unit	file:
reqtype	src/vr_client.h	/^    int reqtype;            \/* Request protocol type: PROTO_REQ_* *\/$/;"	m	struct:client
requests	tests/vrt_benchmark.c	/^    int requests;$/;"	m	struct:benchmark_thread	file:
requests	tests/vrt_benchmark.c	/^    int requests;$/;"	m	struct:config	file:
requests_finished	tests/vrt_benchmark.c	/^    int requests_finished;$/;"	m	struct:benchmark_thread	file:
requests_finished	tests/vrt_benchmark.c	/^    int requests_finished;$/;"	m	struct:config	file:
requests_issued	tests/vrt_benchmark.c	/^    int requests_issued;$/;"	m	struct:benchmark_thread	file:
requests_issued	tests/vrt_benchmark.c	/^    int requests_issued;$/;"	m	struct:config	file:
requirepass	src/vr_conf.h	/^    sds           requirepass;          \/* Pass for AUTH command, or NULL *\/$/;"	m	struct:conf_server
requirepass	src/vr_conf.h	/^    sds requirepass;$/;"	m	struct:conf_cache
reserved_fds	src/vr_core.c	/^static uint32_t reserved_fds = 0;$/;"	v	file:
resetClient	src/vr_client.c	/^void resetClient(client *c) {$/;"	f
resetClient	tests/vrt_benchmark.c	/^static void resetClient(benchmark_client c) {$/;"	f	file:
resetRefCount	src/vr_object.c	/^robj *resetRefCount(robj *obj) {$/;"	f
reset_total_count_per_cycle	tests/vrt_dispatch_data.c	/^void reset_total_count_per_cycle(void)$/;"	f
resident_set_size	src/vr_eventloop.h	/^    size_t resident_set_size;   \/* RSS sampled in workerCron(). *\/$/;"	m	struct:vr_eventloop
resize_db	src/vr_backend.h	/^    unsigned int resize_db;$/;"	m	struct:vr_backend
resize_db	src/vr_worker.h	/^    unsigned int resize_db;$/;"	m	struct:vr_worker
result	dep/himemcached-0.1.0/himcread.h	/^    int result; \/* Parsing result *\/$/;"	m	struct:mcReader
rev	src/vr_dict.c	/^static unsigned long rev(unsigned long v) {$/;"	f	file:
rewriteClientCommandArgument	src/vr_client.c	/^void rewriteClientCommandArgument(client *c, int i, robj *newval) {$/;"	f
rewriteClientCommandVector	src/vr_client.c	/^void rewriteClientCommandVector(client *c, int argc, ...) {$/;"	f
rewriteConfig	src/vr_conf.c	/^static int rewriteConfig(char *path) {$/;"	f	file:
rewriteConfigAddLineNumberToOption	src/vr_conf.c	/^static void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {$/;"	f	file:
rewriteConfigAppendLine	src/vr_conf.c	/^static void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {$/;"	f	file:
rewriteConfigBindOption	src/vr_conf.c	/^static void rewriteConfigBindOption(struct rewriteConfigState *state) {$/;"	f	file:
rewriteConfigBytesOption	src/vr_conf.c	/^static void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, long long defvalue) {$/;"	f	file:
rewriteConfigCommandsNAPOption	src/vr_conf.c	/^void rewriteConfigCommandsNAPOption(struct rewriteConfigState *state) {$/;"	f
rewriteConfigEnumOption	src/vr_conf.c	/^static void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, configEnumGetStrFun fun, int defval) {$/;"	f	file:
rewriteConfigFormatMemory	src/vr_conf.c	/^static int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {$/;"	f	file:
rewriteConfigGetContentFromState	src/vr_conf.c	/^static sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {$/;"	f	file:
rewriteConfigIntOption	src/vr_conf.c	/^static void rewriteConfigIntOption(struct rewriteConfigState *state, char *option, int defvalue) {$/;"	f	file:
rewriteConfigLongLongOption	src/vr_conf.c	/^static void rewriteConfigLongLongOption(struct rewriteConfigState *state, char *option, long long defvalue) {$/;"	f	file:
rewriteConfigMarkAsProcessed	src/vr_conf.c	/^static void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {$/;"	f	file:
rewriteConfigOverwriteFile	src/vr_conf.c	/^static int rewriteConfigOverwriteFile(char *configfile, sds content) {$/;"	f	file:
rewriteConfigReadOldFile	src/vr_conf.c	/^static struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {$/;"	f	file:
rewriteConfigReleaseState	src/vr_conf.c	/^static void rewriteConfigReleaseState(struct rewriteConfigState *state) {$/;"	f	file:
rewriteConfigRemoveOrphaned	src/vr_conf.c	/^static void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {$/;"	f	file:
rewriteConfigRewriteLine	src/vr_conf.c	/^static void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {$/;"	f	file:
rewriteConfigSdsOption	src/vr_conf.c	/^static void rewriteConfigSdsOption(struct rewriteConfigState *state, char *option, sds defvalue) {$/;"	f	file:
rewriteConfigState	src/vr_conf.c	/^struct rewriteConfigState {$/;"	s	file:
rewritten	src/vr_conf.c	/^    dict *rewritten;      \/* Dictionary of already processed options *\/$/;"	m	struct:rewriteConfigState	file:
rfds	dep/ae/ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
rfileProc	dep/ae/ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent
right	src/vr_rbtree.h	/^    struct rbnode *right;    \/* right link *\/$/;"	m	struct:rbnode	typeref:struct:rbnode::rbnode
robj	src/vr_object.h	/^} robj;$/;"	t	typeref:struct:vr_object
rol	dep/dhashkit/dsha1.c	30;"	d	file:
role	src/vr_replication.h	/^    int role;               \/* Master\/slave? *\/$/;"	m	struct:vr_replication
root	src/vr_rbtree.h	/^    struct rbnode *root;     \/* root node *\/$/;"	m	struct:rbtree	typeref:struct:rbtree::rbnode
roslaveerr	src/vr_server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noadminerr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct
rot	dep/dhashkit/djenkins.c	5;"	d	file:
rpop	src/vr_server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
rpopCommand	src/vr_server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	struct:vr_server	typeref:struct:vr_server::
rpopCommand	src/vr_t_list.c	/^void rpopCommand(client *c) {$/;"	f
rpop_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *rpop_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
rpoplpushCommand	src/vr_t_list.c	/^void rpoplpushCommand(client *c) {$/;"	f
rpoplpushHandlePush	src/vr_t_list.c	/^void rpoplpushHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value) {$/;"	f
rpushCommand	src/vr_t_list.c	/^void rpushCommand(client *c) {$/;"	f
rpush_cmd_nck	tests/vrt_produce_data.c	/^static int rpush_cmd_nck(redisReply *reply)$/;"	f	file:
rpush_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *rpush_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
rpushxCommand	src/vr_t_list.c	/^void rpushxCommand(client *c) {$/;"	f
rstatus_t	src/vr_core.h	/^typedef int rstatus_t; \/* return type *\/$/;"	t
ru	tests/vrt_dispatch_data.c	/^    reply_unit *ru;$/;"	m	struct:callback_data	file:
run_with_period	src/vr_server.h	56;"	d
runid	src/vr_server.h	/^    char runid[CONFIG_RUN_ID_SIZE+1];  \/* ID always different at every exec. *\/$/;"	m	struct:vr_server
running	tests/vrt_public.h	/^    int running;$/;"	m	struct:vire_instance
rwl	src/vr_conf.h	/^    pthread_rwlock_t rwl;            \/* config read write lock *\/$/;"	m	struct:vr_conf
rwl	src/vr_db.h	/^    pthread_rwlock_t rwl;       \/* read write lock *\/$/;"	m	struct:redisDb
rwlocker	src/vr_slowlog.c	/^static pthread_rwlock_t rwlocker;$/;"	v	file:
s64	src/vr_dict.h	/^        int64_t s64;$/;"	m	union:dictEntry::__anon15
s_free	dep/sds/sdsalloc.h	43;"	d
s_malloc	dep/sds/sdsalloc.h	41;"	d
s_realloc	dep/sds/sdsalloc.h	42;"	d
saddCommand	src/vr_t_set.c	/^void saddCommand(client *c) {$/;"	f
sadd_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *sadd_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
safe	src/vr_dict.h	/^    int table, safe;$/;"	m	struct:dictIterator
sameobjecterr	src/vr_server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
samples	src/vr_stats.h	/^        long long samples[STATS_METRIC_SAMPLES];$/;"	m	struct:vr_stats::__anon20
saveparam	src/vr_rdb.h	/^struct saveparam {$/;"	s
saveparams	src/vr_server.h	/^    struct saveparam *saveparams;   \/* Save points array for RDB *\/$/;"	m	struct:vr_server	typeref:struct:vr_server::saveparam
saveparamslen	src/vr_server.h	/^    int saveparamslen;              \/* Number of saving points *\/$/;"	m	struct:vr_server
scanCallback	src/vr_db.c	/^void scanCallback(void *privdata, const dictEntry *de) {$/;"	f
scanCommand	src/vr_db.c	/^void scanCommand(client *c) {$/;"	f
scanGenericCommand	src/vr_db.c	/^void scanGenericCommand(client *c, int scantype) {$/;"	f
scan_finished_count	tests/vrt_check_data.c	/^    int scan_finished_count;$/;"	m	struct:check_data_thread	file:
scan_for_check_callback	tests/vrt_check_data.c	/^static void scan_for_check_callback(redisAsyncContext *c, void *r, void *privdata) {$/;"	f	file:
scan_for_delete_callback	tests/vrt_backend.c	/^static void scan_for_delete_callback(redisAsyncContext *c, void *r, void *privdata) {$/;"	f	file:
scan_group_idx	tests/vrt_check_data.c	/^    int scan_group_idx; \/* The group idx to scan keys *\/$/;"	m	struct:check_data_thread	file:
scan_keys_count	tests/vrt_check_data.c	/^    long long scan_keys_count;$/;"	m	struct:check_data_thread	file:
scan_servers	tests/vrt_check_data.c	/^    darray *scan_servers;   \/* The servers in the scan group, type is abtest_server *\/$/;"	m	struct:check_data_thread	file:
scanid	src/vr_client.h	/^    int scanid;             \/* Internal ID of the currently DB for scan *\/$/;"	m	struct:client
scardCommand	src/vr_t_set.c	/^void scardCommand(client *c) {$/;"	f
scard_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *scard_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
score	src/vr_server.h	/^    double score;$/;"	m	struct:zskiplistNode
score	src/vr_t_zset.h	/^    double score;$/;"	m	struct:__anon14
scriptCommand	src/vr_scripting.c	/^void scriptCommand(client *c) {$/;"	f
sd	src/vr_connection.h	/^    int                 sd;              \/* socket descriptor *\/$/;"	m	struct:conn
sd	src/vr_listen.h	/^    int sd;                 \/* socket descriptor *\/$/;"	m	struct:vr_listen
sdiffCommand	src/vr_t_set.c	/^void sdiffCommand(client *c) {$/;"	f
sdiff_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *sdiff_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
sdiffstoreCommand	src/vr_t_set.c	/^void sdiffstoreCommand(client *c) {$/;"	f
sdigits10	src/vr_util.c	/^uint32_t sdigits10(int64_t v) {$/;"	f
sdigits10	tests/vrt_util.c	/^uint32_t sdigits10(int64_t v) {$/;"	f
sds	dep/himemcached-0.1.0/himcdep/sds.h	/^typedef char *sds;$/;"	t
sds	dep/sds/sds.h	/^typedef char *sds;$/;"	t
sdsAllocPtr	dep/sds/sds.c	/^void *sdsAllocPtr(sds s) {$/;"	f
sdsAllocSize	dep/himemcached-0.1.0/himcdep/sds.c	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsAllocSize	dep/sds/sds.c	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsEncodedObject	src/vr_object.h	31;"	d
sdsHdrSize	dep/sds/sds.c	/^static inline int sdsHdrSize(char type) {$/;"	f	file:
sdsIncrLen	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdsIncrLen(sds s, int incr) {$/;"	f
sdsIncrLen	dep/sds/sds.c	/^void sdsIncrLen(sds s, int incr) {$/;"	f
sdsIsNum	dep/sds/sds.c	/^int sdsIsNum(sds s) {$/;"	f
sdsMakeRoomFor	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsMakeRoomFor	dep/sds/sds.c	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsRemoveFreeSpace	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdsRemoveFreeSpace	dep/sds/sds.c	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdsReqType	dep/sds/sds.c	/^static inline char sdsReqType(size_t string_size) {$/;"	f	file:
sdsTest	dep/sds/sds.c	/^int sdsTest(void) {$/;"	f
sdsZmallocSize	src/vr_client.c	/^size_t sdsZmallocSize(sds s) {$/;"	f
sds_free	dep/sds/sds.c	/^void sds_free(void *ptr) { s_free(ptr); }$/;"	f
sds_malloc	dep/sds/sds.c	/^void *sds_malloc(size_t size) { return s_malloc(size); }$/;"	f
sds_realloc	dep/sds/sds.c	/^void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }$/;"	f
sdsalloc	dep/sds/sds.h	/^static inline size_t sdsalloc(const sds s) {$/;"	f
sdsavail	dep/himemcached-0.1.0/himcdep/sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdsavail	dep/sds/sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdscat	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscat	dep/sds/sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatfmt	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscatfmt(sds s, char const *fmt, ...) {$/;"	f
sdscatfmt	dep/sds/sds.c	/^sds sdscatfmt(sds s, char const *fmt, ...) {$/;"	f
sdscatlen	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatlen	dep/sds/sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatprintf	dep/sds/sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatrepr	dep/sds/sds.c	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatsds	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatsds	dep/sds/sds.c	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatvprintf	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdscatvprintf	dep/sds/sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdsclear	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdsclear(sds s) {$/;"	f
sdsclear	dep/sds/sds.c	/^void sdsclear(sds s) {$/;"	f
sdscmp	dep/himemcached-0.1.0/himcdep/sds.c	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscmp	dep/sds/sds.c	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscpy	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpy	dep/sds/sds.c	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpylen	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdscpylen	dep/sds/sds.c	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdsdup	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsdup(const sds s) {$/;"	f
sdsdup	dep/sds/sds.c	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsempty(void) {$/;"	f
sdsempty	dep/sds/sds.c	/^sds sdsempty(void) {$/;"	f
sdsfree	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdsfree(sds s) {$/;"	f
sdsfree	dep/sds/sds.c	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfreesplitres	dep/sds/sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsfromlonglong	dep/sds/sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdsgrowzero	dep/sds/sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdshdr	dep/himemcached-0.1.0/himcdep/sds.h	/^struct sdshdr {$/;"	s
sdshdr16	dep/sds/sds.h	/^struct __attribute__ ((__packed__)) sdshdr16 {$/;"	s
sdshdr32	dep/sds/sds.h	/^struct __attribute__ ((__packed__)) sdshdr32 {$/;"	s
sdshdr5	dep/sds/sds.h	/^struct __attribute__ ((__packed__)) sdshdr5 {$/;"	s
sdshdr64	dep/sds/sds.h	/^struct __attribute__ ((__packed__)) sdshdr64 {$/;"	s
sdshdr8	dep/sds/sds.h	/^struct __attribute__ ((__packed__)) sdshdr8 {$/;"	s
sdsinclen	dep/sds/sds.h	/^static inline void sdsinclen(sds s, size_t inc) {$/;"	f
sdsjoin	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsjoin(char **argv, int argc, char *sep, size_t seplen) {$/;"	f
sdsjoin	dep/sds/sds.c	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f
sdsjoinsds	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {$/;"	f
sdsjoinsds	dep/sds/sds.c	/^sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {$/;"	f
sdslen	dep/himemcached-0.1.0/himcdep/sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
sdslen	dep/sds/sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
sdsll2str	dep/himemcached-0.1.0/himcdep/sds.c	/^int sdsll2str(char *s, long long value) {$/;"	f
sdsll2str	dep/sds/sds.c	/^int sdsll2str(char *s, long long value) {$/;"	f
sdsmapchars	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsmapchars	dep/sds/sds.c	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsnew	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsnew(const char *init) {$/;"	f
sdsnew	dep/sds/sds.c	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	dep/himemcached-0.1.0/himcdep/sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsnewlen	dep/sds/sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdsrange(sds s, int start, int end) {$/;"	f
sdsrange	dep/sds/sds.c	/^void sdsrange(sds s, int start, int end) {$/;"	f
sdssetalloc	dep/sds/sds.h	/^static inline void sdssetalloc(sds s, size_t newlen) {$/;"	f
sdssetlen	dep/sds/sds.h	/^static inline void sdssetlen(sds s, size_t newlen) {$/;"	f
sdssplitargs	dep/himemcached-0.1.0/himcdep/sds.c	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitargs	dep/sds/sds.c	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitlen	dep/himemcached-0.1.0/himcdep/sds.c	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f
sdssplitlen	dep/sds/sds.c	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f
sdstolower	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdstolower(sds s) {$/;"	f
sdstolower	dep/sds/sds.c	/^void sdstolower(sds s) {$/;"	f
sdstoupper	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdstoupper(sds s) {$/;"	f
sdstoupper	dep/sds/sds.c	/^void sdstoupper(sds s) {$/;"	f
sdstrim	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdstrim(sds s, const char *cset) {$/;"	f
sdstrim	dep/sds/sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsull2str	dep/himemcached-0.1.0/himcdep/sds.c	/^int sdsull2str(char *s, unsigned long long v) {$/;"	f
sdsull2str	dep/sds/sds.c	/^int sdsull2str(char *s, unsigned long long v) {$/;"	f
sdsupdatelen	dep/himemcached-0.1.0/himcdep/sds.c	/^void sdsupdatelen(sds s) {$/;"	f
sdsupdatelen	dep/sds/sds.c	/^void sdsupdatelen(sds s) {$/;"	f
seconds	src/vr_rdb.h	/^    time_t seconds;$/;"	m	struct:saveparam
select	src/vr_server.h	/^    *select[PROTO_SHARED_SELECT_CMDS],$/;"	m	struct:sharedObjectsStruct
selectCommand	src/vr_db.c	/^void selectCommand(client *c) {$/;"	f
selectDb	src/vr_db.c	/^int selectDb(client *c, int id) {$/;"	f
sendReplyToClient	src/vr_client.c	/^void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
send_active	src/vr_connection.h	/^    unsigned            send_active:1;   \/* send active? *\/$/;"	m	struct:conn
send_bytes	src/vr_connection.h	/^    size_t              send_bytes;      \/* sent (written) bytes *\/$/;"	m	struct:conn
send_ready	src/vr_connection.h	/^    unsigned            send_ready:1;    \/* send ready? *\/$/;"	m	struct:conn
sentinel	src/vr_rbtree.h	/^    struct rbnode *sentinel; \/* nil node *\/$/;"	m	struct:rbtree	typeref:struct:rbtree::rbnode
sentinel	src/vr_server.h	/^    *sentinel;  \/* NULL pointer *\/$/;"	m	struct:sharedObjectsStruct
sentlen	src/vr_client.h	/^    size_t sentlen;         \/* Amount of bytes already sent in the current$/;"	m	struct:client
serveClientBlockedOnList	src/vr_t_list.c	/^int serveClientBlockedOnList(client *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)$/;"	f
server	src/vr_server.c	/^struct vr_server server; \/* server global state *\/$/;"	v	typeref:struct:vr_server
serverAssertWithInfo	src/vr_server.h	319;"	d
serverPanic	src/vr_server.h	318;"	d
servers	tests/vrt_check_data.c	/^    darray servers; \/* Servers used to send the check messages, type is pointer of abtest_server *\/$/;"	m	struct:check_unit	file:
servers_count	tests/vrt_check_data.c	/^    unsigned int servers_count;$/;"	m	struct:check_unit	file:
set	src/vr_conf.h	/^    int     (*set)(void *cf, struct conf_option *opt, void *data);$/;"	m	struct:conf_option
set	src/vr_t_zset.h	/^        } set;$/;"	m	union:__anon8::__anon9	typeref:union:__anon8::__anon9::_iterset
setCommand	src/vr_t_string.c	/^void setCommand(client *c) {$/;"	f
setDeferredMultiBulkLength	src/vr_client.c	/^void setDeferredMultiBulkLength(client *c, void *node, long length) {$/;"	f
setDictType	src/vr_server.c	/^dictType setDictType = {$/;"	v
setExpire	src/vr_db.c	/^void setExpire(redisDb *db, robj *key, long long when) {$/;"	f
setGenericCommand	src/vr_t_string.c	/^void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {$/;"	f
setKey	src/vr_db.c	/^void setKey(redisDb *db, robj *key, robj *val, int *expired) {$/;"	f
setProtocolError	src/vr_client.c	/^static void setProtocolError(client *c, int pos) {$/;"	f	file:
setSignedBitfield	src/vr_bitops.c	/^void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {$/;"	f
setTypeAdd	src/vr_t_set.c	/^int setTypeAdd(robj *subject, robj *value) {$/;"	f
setTypeConvert	src/vr_t_set.c	/^void setTypeConvert(robj *setobj, int enc) {$/;"	f
setTypeCreate	src/vr_t_set.c	/^robj *setTypeCreate(robj *value) {$/;"	f
setTypeInitIterator	src/vr_t_set.c	/^setTypeIterator *setTypeInitIterator(robj *subject) {$/;"	f
setTypeIsMember	src/vr_t_set.c	/^int setTypeIsMember(robj *subject, robj *value) {$/;"	f
setTypeIterator	src/vr_server.h	/^} setTypeIterator;$/;"	t	typeref:struct:__anon18
setTypeNext	src/vr_t_set.c	/^int setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele) {$/;"	f
setTypeNextObject	src/vr_t_set.c	/^robj *setTypeNextObject(setTypeIterator *si) {$/;"	f
setTypeRandomElement	src/vr_t_set.c	/^int setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele) {$/;"	f
setTypeReleaseIterator	src/vr_t_set.c	/^void setTypeReleaseIterator(setTypeIterator *si) {$/;"	f
setTypeRemove	src/vr_t_set.c	/^int setTypeRemove(robj *setobj, robj *value) {$/;"	f
setTypeSize	src/vr_t_set.c	/^unsigned long setTypeSize(robj *subject) {$/;"	f
setUnsignedBitfield	src/vr_bitops.c	/^void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {$/;"	f
set_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *set_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
set_execute_file	tests/vrt_public.c	/^void set_execute_file(char *file)$/;"	f
set_max_intset_entries	src/vr_server.h	/^    size_t set_max_intset_entries;$/;"	m	struct:vr_server
set_non_empty_kcps_idx	tests/vrt_produce_data.c	/^static void set_non_empty_kcps_idx(void)$/;"	f	file:
setbitCommand	src/vr_bitops.c	/^void setbitCommand(client *c) {$/;"	f
setbit_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *setbit_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
setexCommand	src/vr_t_string.c	/^void setexCommand(client *c) {$/;"	f
setex_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *setex_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
setnxCommand	src/vr_t_string.c	/^void setnxCommand(client *c) {$/;"	f
setnx_cmd_nck	tests/vrt_produce_data.c	/^static int setnx_cmd_nck(redisReply *reply)$/;"	f	file:
setnx_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *setnx_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
setrangeCommand	src/vr_t_string.c	/^void setrangeCommand(client *c) {$/;"	f
setrange_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *setrange_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
setsize	dep/ae/ae.h	/^    int setsize; \/* max number of file descriptors tracked *\/$/;"	m	struct:aeEventLoop
setup_backend	src/vr_backend.c	/^setup_backend(vr_backend *backend)$/;"	f	file:
setup_master	src/vr_master.c	/^setup_master(void)$/;"	f	file:
setup_worker	src/vr_worker.c	/^setup_worker(vr_worker *worker)$/;"	f	file:
sflags	src/vr_command.h	/^    char *sflags; \/* Flags as string representation, one char per flag. *\/$/;"	m	struct:redisCommand
sflags	tests/vrt_produce_data.h	/^    char *sflags; \/* Flags as string representation, one char per flag. *\/$/;"	m	struct:data_producer
shared	src/vr_server.c	/^struct sharedObjectsStruct shared;$/;"	v	typeref:struct:sharedObjectsStruct
sharedObjectsStruct	src/vr_server.h	/^struct sharedObjectsStruct {$/;"	s
short_options	src/vr.c	/^static char short_options[] = "hVtdv:o:c:p:T:";$/;"	v	file:
short_options	tests/vrabtest.c	/^static char short_options[] = "hVDEP:C:i:k:s:f:T:B:W:t:p:K:H:d:c:o:";$/;"	v	file:
short_options	tests/vrtest.c	/^static char short_options[] = "hVe:p:";$/;"	v	file:
showLatencyReport	tests/vrt_benchmark.c	/^static void showLatencyReport(void) {$/;"	f	file:
showThroughput	tests/vrt_benchmark.c	/^static int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f	file:
show_help	src/vr.c	/^static int show_help;$/;"	v	file:
show_help	tests/vrabtest.c	/^static int show_help;$/;"	v	file:
show_help	tests/vrtest.c	/^static int show_help;$/;"	v	file:
show_replys_inconsistency_msg	tests/vrt_dispatch_data.c	/^static void show_replys_inconsistency_msg(data_unit *du, redisReply *reply1, redisReply *reply2)$/;"	f	file:
show_test_result	tests/vrt_public.c	/^void show_test_result(int result,char *test_content,char *errmsg)$/;"	f
show_version	src/vr.c	/^static int show_version;$/;"	v	file:
show_version	tests/vrabtest.c	/^static int show_version;$/;"	v	file:
show_version	tests/vrtest.c	/^static int show_version;$/;"	v	file:
showerrors	tests/vrt_benchmark.c	/^    int showerrors;$/;"	m	struct:config	file:
shutdownCommand	src/vr_db.c	/^void shutdownCommand(client *c) {$/;"	f
sign	src/vr_bitops.c	/^    int sign;           \/* True if signed, otherwise unsigned op. *\/$/;"	m	struct:bitfieldOp	file:
signal	src/vr_signal.h	/^struct signal {$/;"	s
signalFlushedDb	src/vr_db.c	/^void signalFlushedDb(int dbid) {$/;"	f
signalListAsReady	src/vr_t_list.c	/^void signalListAsReady(redisDb *db, robj *key) {$/;"	f
signalModifiedKey	src/vr_db.c	/^void signalModifiedKey(redisDb *db, robj *key) {$/;"	f
signal_deinit	src/vr_signal.c	/^signal_deinit(void)$/;"	f
signal_handler	src/vr_signal.c	/^signal_handler(int signo)$/;"	f
signal_init	src/vr_signal.c	/^signal_init(void)$/;"	f
signals	src/vr_signal.c	/^static struct signal signals[] = {$/;"	v	typeref:struct:signal	file:
signame	src/vr_signal.h	/^    char *signame;$/;"	m	struct:signal
signo	src/vr_signal.h	/^    int  signo;$/;"	m	struct:signal
simple_test	tests/vrt_simple.c	/^int simple_test(void)$/;"	f
simple_test_cmd_append	tests/vrt_simple.c	/^static int simple_test_cmd_append(vire_instance *vi)$/;"	f	file:
simple_test_cmd_bitpos	tests/vrt_simple.c	/^static int simple_test_cmd_bitpos(vire_instance *vi)$/;"	f	file:
simple_test_cmd_decr	tests/vrt_simple.c	/^static int simple_test_cmd_decr(vire_instance *vi)$/;"	f	file:
simple_test_cmd_decrby	tests/vrt_simple.c	/^static int simple_test_cmd_decrby(vire_instance *vi)$/;"	f	file:
simple_test_cmd_get_set	tests/vrt_simple.c	/^static int simple_test_cmd_get_set(vire_instance *vi)$/;"	f	file:
simple_test_cmd_getbit_setbit_bitcount	tests/vrt_simple.c	/^static int simple_test_cmd_getbit_setbit_bitcount(vire_instance *vi)$/;"	f	file:
simple_test_cmd_getrange_setrange	tests/vrt_simple.c	/^static int simple_test_cmd_getrange_setrange(vire_instance *vi)$/;"	f	file:
simple_test_cmd_getset	tests/vrt_simple.c	/^static int simple_test_cmd_getset(vire_instance *vi)$/;"	f	file:
simple_test_cmd_hdel	tests/vrt_simple.c	/^static int simple_test_cmd_hdel(vire_instance *vi)$/;"	f	file:
simple_test_cmd_hget_hset	tests/vrt_simple.c	/^static int simple_test_cmd_hget_hset(vire_instance *vi)$/;"	f	file:
simple_test_cmd_hlen	tests/vrt_simple.c	/^static int simple_test_cmd_hlen(vire_instance *vi)$/;"	f	file:
simple_test_cmd_incr	tests/vrt_simple.c	/^static int simple_test_cmd_incr(vire_instance *vi)$/;"	f	file:
simple_test_cmd_incrby	tests/vrt_simple.c	/^static int simple_test_cmd_incrby(vire_instance *vi)$/;"	f	file:
simple_test_cmd_incrbyfloat	tests/vrt_simple.c	/^static int simple_test_cmd_incrbyfloat(vire_instance *vi)$/;"	f	file:
simple_test_cmd_mget_mset	tests/vrt_simple.c	/^static int simple_test_cmd_mget_mset(vire_instance *vi)$/;"	f	file:
simple_test_cmd_pfadd_pfcount	tests/vrt_simple.c	/^static int simple_test_cmd_pfadd_pfcount(vire_instance *vi)$/;"	f	file:
simple_test_cmd_psetex	tests/vrt_simple.c	/^static int simple_test_cmd_psetex(vire_instance *vi)$/;"	f	file:
simple_test_cmd_setex	tests/vrt_simple.c	/^static int simple_test_cmd_setex(vire_instance *vi)$/;"	f	file:
simple_test_cmd_setnx	tests/vrt_simple.c	/^static int simple_test_cmd_setnx(vire_instance *vi)$/;"	f	file:
simple_test_cmd_strlen	tests/vrt_simple.c	/^static int simple_test_cmd_strlen(vire_instance *vi)$/;"	f	file:
simple_test_hash_encode	tests/vrt_simple.c	/^static int simple_test_hash_encode(vire_instance *vi)$/;"	f	file:
simple_test_hash_init	tests/vrt_simple.c	/^static struct test_hash_member **simple_test_hash_init(vire_instance *vi, char *key, int hash_encode, int encode_cause)$/;"	f	file:
sinterCommand	src/vr_t_set.c	/^void sinterCommand(client *c) {$/;"	f
sinterGenericCommand	src/vr_t_set.c	/^void sinterGenericCommand(client *c, robj **setkeys,$/;"	f
sinter_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *sinter_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
sinterstoreCommand	src/vr_t_set.c	/^void sinterstoreCommand(client *c) {$/;"	f
sismemberCommand	src/vr_t_set.c	/^void sismemberCommand(client *c) {$/;"	f
sismember_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *sismember_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
size	dep/darray/darray.h	/^    size_t               size;   \/* element size *\/$/;"	m	struct:darray
size	src/vr_dict.h	/^    unsigned long size;$/;"	m	struct:dictht
sizeMeetsSafetyLimit	src/vr_quicklist.c	385;"	d	file:
sizemask	src/vr_dict.h	/^    unsigned long sizemask;$/;"	m	struct:dictht
skipme	src/vr_client.c	/^    int skipme;$/;"	m	struct:clientkilldata	file:
sl	src/vr_t_zset.h	/^            } sl;$/;"	m	union:__anon8::__anon9::_iterzset	typeref:struct:__anon8::__anon9::_iterzset::__anon13
slave_capa	src/vr_client.h	/^    int slave_capa;         \/* Slave capabilities: SLAVE_CAPA_* bitwise OR. *\/$/;"	m	struct:client
slave_listening_port	src/vr_client.h	/^    int slave_listening_port; \/* As configured with: SLAVECONF listening-port *\/$/;"	m	struct:client
slave_priority	src/vr_replication.h	/^    int slave_priority;             \/* Reported in INFO and used by Sentinel. *\/$/;"	m	struct:vr_replication
slaves	src/vr_replication.h	/^    dlist *slaves;           \/* List of slaves *\/$/;"	m	struct:vr_replication
slaveseldb	src/vr_replication.h	/^    int slaveseldb;                 \/* Last SELECTed DB in replication output *\/$/;"	m	struct:vr_replication
slowlog	src/vr_slowlog.c	/^static dlist *slowlog;                  \/* SLOWLOG list of commands *\/$/;"	v	file:
slowlogCommand	src/vr_slowlog.c	/^void slowlogCommand(client *c) {$/;"	f
slowlogCreateEntry	src/vr_slowlog.c	/^slowlogEntry *slowlogCreateEntry(robj **argv, int argc, long long duration) {$/;"	f
slowlogEntry	src/vr_slowlog.h	/^typedef struct slowlogEntry {$/;"	s
slowlogEntry	src/vr_slowlog.h	/^} slowlogEntry;$/;"	t	typeref:struct:slowlogEntry
slowlogFreeEntry	src/vr_slowlog.c	/^void slowlogFreeEntry(void *septr) {$/;"	f
slowlogInit	src/vr_slowlog.c	/^void slowlogInit(void) {$/;"	f
slowlogPushEntryIfNeeded	src/vr_slowlog.c	/^void slowlogPushEntryIfNeeded(vr_eventloop *vel, robj **argv, int argc, long long duration) {$/;"	f
slowlogReset	src/vr_slowlog.c	/^void slowlogReset(void) {$/;"	f
slowlog_entry_id	src/vr_slowlog.c	/^static long long slowlog_entry_id;     \/* SLOWLOG current entry ID *\/$/;"	v	file:
slowlog_log_slower_than	src/vr_conf.h	/^    long long     slowlog_log_slower_than;  \/* SLOWLOG time limit (to get logged) *\/$/;"	m	struct:conf_server
slowlog_log_slower_than	src/vr_conf.h	/^    long long slowlog_log_slower_than;$/;"	m	struct:conf_cache
slowlog_max_len	src/vr_conf.h	/^    int           slowlog_max_len;      \/* SLOWLOG max number of items logged *\/$/;"	m	struct:conf_server
slowscripterr	src/vr_server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct
smembersCommand	src/vr_t_set.c	/^void smembersCommand(client *c) {$/;"	f
smembersGenericCommand	src/vr_t_set.c	/^void smembersGenericCommand(client *c, robj *set)$/;"	f
smembers_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *smembers_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
smoveCommand	src/vr_t_set.c	/^void smoveCommand(client *c) {$/;"	f
socketpairs	src/vr_worker.h	/^    int socketpairs[2];         \/*0: belong to master thread, 1: belong to myself*\/$/;"	m	struct:vr_worker
sockinfo	src/vr_util.h	/^struct sockinfo {$/;"	s
soft_limit_bytes	src/vr_client.h	/^    unsigned long long soft_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig
soft_limit_seconds	src/vr_client.h	/^    time_t soft_limit_seconds;$/;"	m	struct:clientBufferLimitsConfig
sortGetKeys	src/vr_db.c	/^int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f
sort_array_by_step	tests/vrt_public.c	/^int sort_array_by_step(void **element, size_t elements, $/;"	f
sort_replys_if_needed	tests/vrt_check_data.c	/^static int sort_replys_if_needed(check_unit *cunit)$/;"	f	file:
sort_replys_if_needed	tests/vrt_dispatch_data.c	/^static int sort_replys_if_needed(reply_unit *ru)$/;"	f	file:
sort_unit	tests/vrt_public.c	/^struct sort_unit {$/;"	s	file:
source_addr	dep/himemcached-0.1.0/himemcached.h	/^        char *source_addr;$/;"	m	struct:mcContext::__anon3
space	src/vr_server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct
span	src/vr_server.h	/^        unsigned int span;$/;"	m	struct:zskiplistNode::zskiplistLevel
spopCommand	src/vr_t_set.c	/^void spopCommand(client *c) {$/;"	f
spopWithCountCommand	src/vr_t_set.c	/^void spopWithCountCommand(client *c) {$/;"	f
sptr	src/vr_t_zset.h	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon8::__anon9::_iterzset::__anon12
srandmemberCommand	src/vr_t_set.c	/^void srandmemberCommand(client *c) {$/;"	f
srandmemberWithCountCommand	src/vr_t_set.c	/^void srandmemberWithCountCommand(client *c) {$/;"	f
sremCommand	src/vr_server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	struct:vr_server	typeref:struct:vr_server::
sremCommand	src/vr_t_set.c	/^void sremCommand(client *c) {$/;"	f
srem_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *srem_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
sscanCommand	src/vr_t_set.c	/^void sscanCommand(client *c) {$/;"	f
start	tests/vrt_benchmark.c	/^    long long start;        \/* Start time of a request *\/$/;"	m	struct:_benchmark_client	file:
start	tests/vrt_benchmark.c	/^    long long start;$/;"	m	struct:benchmark_thread	file:
start	tests/vrt_benchmark.c	/^    long long start;$/;"	m	struct:config	file:
start_benchmark_threads_until_finish	tests/vrt_benchmark.c	/^static int start_benchmark_threads_until_finish(void)$/;"	f	file:
start_check_data	tests/vrt_check_data.c	/^static int start_check_data(char *key, size_t keylen, check_data_thread *cdt)$/;"	f	file:
start_check_data_threads	tests/vrt_check_data.c	/^static int start_check_data_threads(void)$/;"	f	file:
start_one_vire_instance	tests/vrt_public.c	/^vire_instance *start_one_vire_instance(void)$/;"	f
starttime	src/vr_server.h	/^    time_t starttime;       \/* Server start time *\/$/;"	m	struct:vr_server
starttime	src/vr_stats.h	/^    time_t starttime;          \/* Server start time *\/$/;"	m	struct:vr_stats
state	dep/dhashkit/dhashkit.h	/^    uint32_t state[5];    $/;"	m	struct:__anon1
state	dep/himemcached-0.1.0/himcread.h	/^    int state;  \/* Current parser state *\/$/;"	m	struct:mcReader
state	tests/vrt_check_data.c	/^    int state;$/;"	m	struct:check_unit	file:
state_locker	tests/vrt_public.c	/^pthread_mutex_t state_locker = PTHREAD_MUTEX_INITIALIZER;$/;"	v
stats	src/vr_eventloop.h	/^    vr_stats *stats;            \/* stats for this thread *\/$/;"	m	struct:vr_eventloop
statslock	src/vr_stats.h	/^    pthread_spinlock_t statslock;$/;"	m	struct:vr_stats
steal_hiredis_redisreply	tests/vrt_public.c	/^redisReply *steal_hiredis_redisreply(redisReply *r)$/;"	f
steps	src/vr_client.h	/^    int steps;              \/* The steps that this client jumps between workers. *\/$/;"	m	struct:client
stop	dep/ae/ae.h	/^    int stop;$/;"	m	struct:aeEventLoop
stop_writes_on_bgsave_err	src/vr_server.h	/^    int stop_writes_on_bgsave_err;  \/* Don't allow writes if can't BGSAVE *\/$/;"	m	struct:vr_server
str	dep/himemcached-0.1.0/himcread.h	/^    char *str;$/;"	m	struct:mcReader
str	dep/himemcached-0.1.0/himemcached.h	/^    char *str; \/* Used for both REDIS_REPLY_ERROR and MC_REPLY_STRING *\/$/;"	m	struct:mcReply
strEncoding	src/vr_object.c	/^char *strEncoding(int encoding) {$/;"	f
stress	src/vr_ziplist.c	/^static void stress(int pos, int num, int maxsize, int dnum) {$/;"	f	file:
string2l	src/vr_util.c	/^int string2l(const char *s, size_t slen, long *lval) {$/;"	f
string2l	tests/vrt_util.c	/^int string2l(const char *s, size_t slen, long *lval) {$/;"	f
string2ll	src/vr_util.c	/^string2ll(const char *s, size_t slen, long long *value) {$/;"	f
string2ll	tests/vrt_util.c	/^int string2ll(const char *s, size_t slen, long long *value) {$/;"	f
stringObjectLen	src/vr_object.c	/^size_t stringObjectLen(robj *o) {$/;"	f
string_length_max	tests/vrt_produce_data.c	/^static unsigned int string_length_max;$/;"	v	file:
string_match	dep/util/dutil.c	/^int string_match(const char *pattern, const char *string, int nocase) {$/;"	f
string_match_len	dep/util/dutil.c	/^int string_match_len(const char *pattern, int patternLen,$/;"	f
string_max_length	tests/vrabtest.c	/^    int string_max_length;$/;"	m	struct:config	file:
stringmatch	src/vr_util.c	/^int stringmatch(const char *pattern, const char *string, int nocase) {$/;"	f
stringmatchlen	src/vr_util.c	/^int stringmatchlen(const char *pattern, int patternLen,$/;"	f
strlen	dep/himemcached-0.1.0/himcread.h	/^    size_t strlen;$/;"	m	struct:mcReader
strlenCommand	src/vr_t_string.c	/^void strlenCommand(client *c) {$/;"	f
strlen_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *strlen_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
strtold	src/vr_object.c	7;"	d	file:
subject	src/vr_server.h	/^    robj *subject;$/;"	m	struct:__anon16
subject	src/vr_server.h	/^    robj *subject;$/;"	m	struct:__anon18
subject	src/vr_server.h	/^    robj *subject;$/;"	m	struct:__anon19
subject	src/vr_t_zset.h	/^    robj *subject;$/;"	m	struct:__anon8
subreply	dep/himemcached-0.1.0/himcread.h	/^    void *subreply; \/* Temporary reply for array type *\/$/;"	m	struct:mcReader
subscribeCommand	src/vr_pubsub.c	/^void subscribeCommand(client *c) {$/;"	f
subscribebulk	src/vr_server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct
sunionCommand	src/vr_t_set.c	/^void sunionCommand(client *c) {$/;"	f
sunionDiffGenericCommand	src/vr_t_set.c	/^void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,$/;"	f
sunion_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *sunion_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
sunionstoreCommand	src/vr_t_set.c	/^void sunionstoreCommand(client *c) {$/;"	f
sync_full	src/vr_stats.h	/^    long long sync_full;       \/* Number of full resyncs with slaves. *\/$/;"	m	struct:vr_stats
sync_partial_err	src/vr_stats.h	/^    long long sync_partial_err;\/* Number of unaccepted PSYNC requests. *\/$/;"	m	struct:vr_stats
sync_partial_ok	src/vr_stats.h	/^    long long sync_partial_ok; \/* Number of accepted PSYNC requests. *\/$/;"	m	struct:vr_stats
syntaxerr	src/vr_server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
system_memory_size	src/vr_server.h	/^    size_t system_memory_size;  \/* Total memory in system as reported by OS *\/$/;"	m	struct:vr_server
sz	src/vr_quicklist.h	/^    unsigned int sz;             \/* ziplist size in bytes *\/$/;"	m	struct:quicklistNode
sz	src/vr_quicklist.h	/^    unsigned int sz; \/* LZF size in bytes*\/$/;"	m	struct:quicklistLZF
sz	src/vr_quicklist.h	/^    unsigned int sz;$/;"	m	struct:quicklistEntry
table	src/vr_dict.h	/^    dictEntry **table;$/;"	m	struct:dictht
table	src/vr_dict.h	/^    int table, safe;$/;"	m	struct:dictIterator
tail	dep/dlist/dlist.h	/^    dlistNode *tail;$/;"	m	struct:dlist
tail	src/vr_quicklist.h	/^    quicklistNode *tail;$/;"	m	struct:quicklist
tail	src/vr_server.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::
target	src/vr_block.h	/^    robj *target;           \/* The key that should receive the element,$/;"	m	struct:blockingState
target	src/vr_command.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp
taridx	src/vr_client.h	/^    int taridx;             \/* The target worker idx that this client will jump to *\/$/;"	m	struct:client
task_data	tests/vrt_backend.c	/^typedef struct task_data {$/;"	s	file:
task_data	tests/vrt_backend.c	/^} task_data;$/;"	t	typeref:struct:task_data	file:
task_data_create	tests/vrt_backend.c	/^static int task_data_create(void)$/;"	f	file:
task_data_destroy	tests/vrt_backend.c	/^static void task_data_destroy(task_data *td)$/;"	f	file:
tcp	dep/himemcached-0.1.0/himemcached.h	/^    } tcp;$/;"	m	struct:mcContext	typeref:struct:mcContext::__anon3
tcp_backlog	src/vr_server.h	/^    int tcp_backlog;            \/* TCP listen() backlog *\/$/;"	m	struct:vr_server
tcpkeepalive	src/vr_server.h	/^    int tcpkeepalive;               \/* Set SO_KEEPALIVE if non-zero. *\/$/;"	m	struct:vr_server
test_can_continue	tests/vrt_check_data.c	/^void test_can_continue(void)$/;"	f
test_conf	src/vr.c	/^static int test_conf;$/;"	v	file:
test_hash_member	tests/vrt_simple.c	/^struct test_hash_member {$/;"	s	file:
test_hash_member_length	tests/vrt_simple.c	/^static int test_hash_member_length(struct test_hash_member **thms)$/;"	f	file:
test_hash_members_destroy	tests/vrt_simple.c	/^static void test_hash_members_destroy(struct test_hash_member **thms)$/;"	f	file:
test_if_need_pause	tests/vrt_check_data.c	/^int test_if_need_pause(void)$/;"	f
test_interval	tests/vrabtest.c	/^    long long test_interval;$/;"	m	struct:config	file:
test_interval	tests/vrabtest.c	/^long long test_interval;$/;"	v
test_is_selected	tests/vrt_benchmark.c	/^int test_is_selected(char *name) {$/;"	f
test_log_debug	tests/vrt_util.h	37;"	d
test_log_debug	tests/vrt_util.h	41;"	d
test_log_error	tests/vrt_util.h	43;"	d
test_log_out	tests/vrt_util.h	46;"	d
test_memcached	tests/vrt_benchmark.c	/^static int test_memcached(int argc, const char **argv)$/;"	f	file:
test_need_pause	tests/vrt_check_data.c	/^static int test_need_pause = 0;$/;"	v	file:
test_need_to_pause	tests/vrt_check_data.c	/^void test_need_to_pause(void)$/;"	f
test_redis	tests/vrt_benchmark.c	/^static int test_redis(int argc, const char **argv)$/;"	f	file:
test_target_groups	tests/vrt_check_data.c	/^    sds test_target_groups;$/;"	m	struct:data_checker	file:
test_targets	tests/vrabtest.c	/^    char *test_targets; $/;"	m	struct:config	file:
tests	tests/vrt_benchmark.c	/^    char *tests;$/;"	m	struct:config	file:
thread	src/vr_eventloop.h	/^    vr_thread thread;$/;"	m	struct:vr_eventloop
thread_event_process	src/vr_master.c	/^thread_event_process(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
thread_event_process	src/vr_worker.c	/^thread_event_process(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
thread_id	src/vr_thread.h	/^    pthread_t thread_id;$/;"	m	struct:vr_thread
thread_id	tests/vrt_backend.h	/^    pthread_t thread_id;$/;"	m	struct:backend_thread
thread_id	tests/vrt_benchmark.c	/^    pthread_t thread_id;$/;"	m	struct:benchmark_thread	file:
thread_id	tests/vrt_check_data.c	/^    pthread_t thread_id;$/;"	m	struct:check_data_thread	file:
thread_id	tests/vrt_check_data.c	/^    pthread_t thread_id;$/;"	m	struct:data_checker	file:
thread_id	tests/vrt_dispatch_data.h	/^    pthread_t thread_id;$/;"	m	struct:dispatch_data_thread
thread_id	tests/vrt_produce_data.c	/^    pthread_t thread_id;$/;"	m	struct:produce_thread	file:
thread_num	src/vr_core.h	/^    int             thread_num;                  \/* the thread number *\/$/;"	m	struct:instance
threads	src/vr_conf.h	/^    int           threads;$/;"	m	struct:conf_server
threads_count	tests/vrt_benchmark.c	/^    int threads_count;$/;"	m	struct:config	file:
time	src/vr_slowlog.h	/^    time_t time;        \/* Unix time at which the query was executed. *\/$/;"	m	struct:slowlogEntry
timeCommand	src/vr_server.c	/^void timeCommand(client *c) {$/;"	f
timeEventHead	dep/ae/ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop
timeEventNextId	dep/ae/ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop
timeInMilliseconds	src/vr_dict.c	/^long long timeInMilliseconds(void) {$/;"	f
timeProc	dep/ae/ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent
time_independent_strcmp	src/vr_server.c	/^int time_independent_strcmp(char *a, char *b) {$/;"	f
timelimit_exit	src/vr_backend.h	/^    int timelimit_exit;         \/* Time limit hit in previous call? *\/$/;"	m	struct:vr_backend
timelimit_exit	src/vr_worker.h	/^    int timelimit_exit;         \/* Time limit hit in previous call? *\/$/;"	m	struct:vr_worker
timeout	dep/himemcached-0.1.0/himemcached.h	/^    struct timeval *timeout;$/;"	m	struct:mcContext	typeref:struct:mcContext::timeval
timeout	src/vr_block.h	/^    long long timeout;       \/* Blocking operation timeout. If UNIX current time$/;"	m	struct:blockingState
title	tests/vrt_benchmark.c	/^    const char *title;$/;"	m	struct:config	file:
token	dep/himemcached-0.1.0/himcread.h	/^    char *token;    \/* Token marker *\/$/;"	m	struct:mcReader
total_count	tests/vrt_dispatch_data.c	/^    int total_count;$/;"	m	struct:reply_unit	file:
total_reply_err_count	tests/vrt_dispatch_data.c	/^static long long total_reply_err_count = 0;$/;"	v	file:
total_reply_err_count_per_cycle	tests/vrt_dispatch_data.c	/^static long long total_reply_err_count_per_cycle = 0;$/;"	v	file:
total_system_memory	tests/vrt_backend.c	/^    long long total_system_memory;$/;"	m	struct:task_data	file:
total_tested_commands_count	tests/vrt_dispatch_data.c	/^static long long total_tested_commands_count = 0;$/;"	v	file:
total_tested_commands_count_per_cycle	tests/vrt_dispatch_data.c	/^static long long total_tested_commands_count_per_cycle = 0;$/;"	v	file:
totlatency	tests/vrt_benchmark.c	/^    long long totlatency;$/;"	m	struct:benchmark_thread	file:
totlatency	tests/vrt_benchmark.c	/^    long long totlatency;$/;"	m	struct:config	file:
touchWatchedKey	src/vr_multi.c	/^void touchWatchedKey(redisDb *db, robj *key) {$/;"	f
touchWatchedKeysOnFlush	src/vr_multi.c	/^void touchWatchedKeysOnFlush(int dbid) {$/;"	f
trackInstantaneousMetric	src/vr_stats.c	/^void trackInstantaneousMetric(vr_stats *stats, int metric, long long current_reading) {$/;"	f
tryObjectEncoding	src/vr_object.c	/^robj *tryObjectEncoding(robj *o) {$/;"	f
tryResizeHashTablesForDb	src/vr_db.c	/^void tryResizeHashTablesForDb(int dbid) {$/;"	f
ttlCommand	src/vr_db.c	/^void ttlCommand(client *c) {$/;"	f
ttlGenericCommand	src/vr_db.c	/^void ttlGenericCommand(client *c, int output_ms) {$/;"	f
ttl_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *ttl_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
type	dep/himemcached-0.1.0/himcread.h	/^    int type;   \/* Response type *\/$/;"	m	struct:mcReader
type	dep/himemcached-0.1.0/himemcached.h	/^    int type; \/* MC_REPLY_* *\/$/;"	m	struct:mcReply
type	src/vr_client.c	/^    int type;$/;"	m	struct:clientkilldata	file:
type	src/vr_conf.h	/^    int     type;       \/* value type *\/$/;"	m	struct:conf_option
type	src/vr_conf.h	/^    int     type;$/;"	m	struct:conf_value
type	src/vr_dict.h	/^    dictType *type;$/;"	m	struct:dict
type	src/vr_object.h	/^    unsigned type:4;$/;"	m	struct:vr_object
type	src/vr_t_zset.h	/^    int type; \/* Set, sorted set *\/$/;"	m	struct:__anon8
type	tests/vrabtest.h	/^    int type;$/;"	m	struct:abtest_group
typeCommand	src/vr_db.c	/^void typeCommand(client *c) {$/;"	f
u16	src/vr_lzfP.h	/^    typedef unsigned int u16;$/;"	t
u16	src/vr_lzfP.h	/^    typedef unsigned short u16;$/;"	t
u64	src/vr_dict.h	/^        uint64_t u64;$/;"	m	union:dictEntry::__anon15
u8	src/vr_lzfP.h	/^typedef unsigned char u8;$/;"	t
u_int	dep/util/dspecialconfig.h	44;"	d
u_int32_t	dep/util/dspecialconfig.h	45;"	d
un	src/vr_util.h	/^        struct sockaddr_un  un;    \/* unix domain address *\/$/;"	m	union:sockinfo::__anon5	typeref:struct:sockinfo::__anon5::sockaddr_un
unblockClient	src/vr_block.c	/^void unblockClient(client *c) {$/;"	f
unblockClientWaitingData	src/vr_t_list.c	/^void unblockClientWaitingData(client *c) {$/;"	f
unblockClientWaitingReplicas	src/vr_replication.c	/^void unblockClientWaitingReplicas(client *c) {$/;"	f
unblocked_clients	src/vr_eventloop.h	/^    dlist *unblocked_clients;        \/* list of clients to unblock before next loop *\/$/;"	m	struct:vr_eventloop
unix_sock	dep/himemcached-0.1.0/himemcached.h	/^    } unix_sock;$/;"	m	struct:mcContext	typeref:struct:mcContext::__anon4
unixsocket	src/vr_server.h	/^    char *unixsocket;           \/* UNIX socket path *\/$/;"	m	struct:vr_server
unixtime	src/vr_eventloop.h	/^    time_t unixtime;            \/* Unix time sampled every cron cycle. *\/$/;"	m	struct:vr_eventloop
unixtime	src/vr_server.h	/^    time_t unixtime;        \/* Unix time sampled every cron cycle. *\/$/;"	m	struct:vr_server
unlikely	src/vr_quicklist.c	53;"	d	file:
unlikely	src/vr_quicklist.c	56;"	d	file:
unlinkClient	src/vr_client.c	/^void unlinkClient(client *c) {$/;"	f
unlinkClientFromEventloop	src/vr_client.c	/^void unlinkClientFromEventloop(client *c) {$/;"	f
unlockDb	src/vr_db.c	/^unlockDb(redisDb *db)$/;"	f
unsubscribeCommand	src/vr_pubsub.c	/^void unsubscribeCommand(client *c) {$/;"	f
unsubscribebulk	src/vr_server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct
unwatchAllKeys	src/vr_multi.c	/^void unwatchAllKeys(client *c) {$/;"	f
updateBenchmarkStats	tests/vrt_benchmark.c	/^static void updateBenchmarkStats(void)$/;"	f	file:
update_curr_clients_add	src/vr_client.h	207;"	d
update_curr_clients_add	src/vr_client.h	210;"	d
update_curr_clients_add	src/vr_client.h	215;"	d
update_curr_clients_sub	src/vr_client.h	208;"	d
update_curr_clients_sub	src/vr_client.h	211;"	d
update_curr_clients_sub	src/vr_client.h	221;"	d
update_dmalloc_stat_alloc	dep/dmalloc/dmalloc.c	42;"	d	file:
update_dmalloc_stat_free	dep/dmalloc/dmalloc.c	48;"	d	file:
update_maxmemory_callback	tests/vrt_backend.c	/^static void update_maxmemory_callback(redisAsyncContext *c, void *r, void *privdata) {$/;"	f	file:
update_memory_callback	tests/vrt_backend.c	/^static void update_memory_callback(redisAsyncContext *c, void *r, void *privdata) {$/;"	f	file:
update_memory_info	tests/vrt_backend.c	/^static void update_memory_info(darray *abgs)$/;"	f	file:
update_state_add	tests/vrt_public.h	39;"	d
update_state_add	tests/vrt_public.h	49;"	d
update_state_add	tests/vrt_public.h	60;"	d
update_state_get	tests/vrt_public.h	42;"	d
update_state_get	tests/vrt_public.h	52;"	d
update_state_get	tests/vrt_public.h	78;"	d
update_state_set	tests/vrt_public.h	41;"	d
update_state_set	tests/vrt_public.h	51;"	d
update_state_set	tests/vrt_public.h	72;"	d
update_state_sub	tests/vrt_public.h	40;"	d
update_state_sub	tests/vrt_public.h	50;"	d
update_state_sub	tests/vrt_public.h	66;"	d
update_stats_add	src/vr_stats.h	48;"	d
update_stats_add	src/vr_stats.h	58;"	d
update_stats_add	src/vr_stats.h	67;"	d
update_stats_get	src/vr_stats.h	51;"	d
update_stats_get	src/vr_stats.h	61;"	d
update_stats_get	src/vr_stats.h	85;"	d
update_stats_set	src/vr_stats.h	50;"	d
update_stats_set	src/vr_stats.h	60;"	d
update_stats_set	src/vr_stats.h	79;"	d
update_stats_sub	src/vr_stats.h	49;"	d
update_stats_sub	src/vr_stats.h	59;"	d
update_stats_sub	src/vr_stats.h	73;"	d
update_used_mem_stat_add	dep/dmalloc/dmalloc.c	19;"	d	file:
update_used_mem_stat_add	dep/dmalloc/dmalloc.c	23;"	d	file:
update_used_mem_stat_add	dep/dmalloc/dmalloc.c	27;"	d	file:
update_used_mem_stat_sub	dep/dmalloc/dmalloc.c	20;"	d	file:
update_used_mem_stat_sub	dep/dmalloc/dmalloc.c	24;"	d	file:
update_used_mem_stat_sub	dep/dmalloc/dmalloc.c	33;"	d	file:
usec	src/vr_ziplist.c	/^static long long usec(void) {$/;"	f	file:
used	src/vr_aof.h	/^    unsigned long used, free;$/;"	m	struct:aofrwblock
used	src/vr_dict.h	/^    unsigned long used;$/;"	m	struct:dictht
used_memory	dep/dmalloc/dmalloc.c	/^static size_t used_memory = 0;$/;"	v	file:
used_memory	tests/vrt_backend.c	/^    long long used_memory;$/;"	m	struct:task_data	file:
used_memory_mutex	dep/dmalloc/dmalloc.c	/^pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
v	src/vr_dict.h	/^    } v;$/;"	m	struct:dictEntry	typeref:union:dictEntry::__anon15
val	src/vr_dict.h	/^        void *val;$/;"	m	union:dictEntry::__anon15
valDestructor	src/vr_dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	struct:dictType
valDup	src/vr_dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	struct:dictType
value	dep/dhashkit/dhashkit.h	/^    uint32_t value;  \/* hash value *\/$/;"	m	struct:continuum
value	dep/dlist/dlist.h	/^    void *value;$/;"	m	struct:dlistNode
value	src/vr_conf.h	/^    void    *value;$/;"	m	struct:conf_value
value	src/vr_quicklist.h	/^    unsigned char *value;$/;"	m	struct:quicklistEntry
value	tests/vrt_simple.c	/^    char *value;$/;"	m	struct:test_hash_member	file:
vel	src/vr_backend.h	/^    vr_eventloop vel;$/;"	m	struct:vr_backend
vel	src/vr_client.h	/^    vr_eventloop *vel;$/;"	m	struct:client
vel	src/vr_master.h	/^    vr_eventloop vel;$/;"	m	struct:vr_master
vel	src/vr_replication.h	/^    vr_eventloop vel;$/;"	m	struct:vr_replication
vel	src/vr_worker.h	/^    vr_eventloop vel;$/;"	m	struct:vr_worker
verify	src/vr_ziplist.c	/^static void verify(unsigned char *zl, zlentry *e) {$/;"	f	file:
version	dep/himemcached-0.1.0/himemcached.h	/^    long long version;$/;"	m	struct:mcReply
version	src/vr_conf.h	/^    unsigned long long version;      \/* config version *\/$/;"	m	struct:vr_conf
vire_conf_create	tests/vrt_public.c	/^static sds vire_conf_create(char *dir, int port)$/;"	f	file:
vire_instance	tests/vrt_public.h	/^typedef struct vire_instance {$/;"	s
vire_instance	tests/vrt_public.h	/^} vire_instance;$/;"	t	typeref:struct:vire_instance
vire_instance_create	tests/vrt_public.c	/^vire_instance *vire_instance_create(int port)$/;"	f
vire_instance_destroy	tests/vrt_public.c	/^void vire_instance_destroy(vire_instance *vi)$/;"	f
vire_server_run	tests/vrt_public.c	/^int vire_server_run(vire_instance *vi)$/;"	f
vire_server_stop	tests/vrt_public.c	/^void vire_server_stop(vire_instance *vi)$/;"	f
vireport	tests/vrt_public.c	/^static int vireport = 55556; \/* The available port for vire to start *\/$/;"	v	file:
vkeys_all	src/vr_server.c	/^    long long vkeys_all;$/;"	m	struct:keys_statistics	file:
vptr	src/vr_server.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon19
vr_atoi	src/vr_util.h	60;"	d
vr_backend	src/vr_backend.h	/^typedef struct vr_backend {$/;"	s
vr_backend	src/vr_backend.h	/^}vr_backend;$/;"	t	typeref:struct:vr_backend
vr_backend_deinit	src/vr_backend.c	/^vr_backend_deinit(vr_backend *backend)$/;"	f
vr_backend_init	src/vr_backend.c	/^vr_backend_init(vr_backend *backend)$/;"	f
vr_conf	src/vr_conf.h	/^typedef struct vr_conf {$/;"	s
vr_conf	src/vr_conf.h	/^}vr_conf;$/;"	t	typeref:struct:vr_conf
vr_create_pidfile	src/vr.c	/^vr_create_pidfile(struct instance *nci)$/;"	f	file:
vr_daemonize	src/vr.c	/^vr_daemonize(int dump_core)$/;"	f	file:
vr_eventloop	src/vr_eventloop.h	/^typedef struct vr_eventloop {$/;"	s
vr_eventloop	src/vr_eventloop.h	/^}vr_eventloop;$/;"	t	typeref:struct:vr_eventloop
vr_eventloop_deinit	src/vr_eventloop.c	/^vr_eventloop_deinit(vr_eventloop *vel)$/;"	f
vr_eventloop_init	src/vr_eventloop.c	/^vr_eventloop_init(vr_eventloop *vel, int filelimit)$/;"	f
vr_get_options	src/vr.c	/^vr_get_options(int argc, char **argv, struct instance *nci)$/;"	f	file:
vr_get_options	tests/vrtest.c	/^vr_get_options(int argc, char **argv)$/;"	f	file:
vr_get_rcvbuf	src/vr_util.c	/^vr_get_rcvbuf(int sd)$/;"	f
vr_get_sndbuf	src/vr_util.c	/^vr_get_sndbuf(int sd)$/;"	f
vr_get_soerror	src/vr_util.c	/^vr_get_soerror(int sd)$/;"	f
vr_gethostname	src/vr_util.h	57;"	d
vr_listen	src/vr_listen.h	/^typedef struct vr_listen {$/;"	s
vr_listen	src/vr_listen.h	/^}vr_listen;$/;"	t	typeref:struct:vr_listen
vr_listen_accept	src/vr_listen.c	/^vr_listen_accept(vr_listen *vlisten)$/;"	f
vr_listen_begin	src/vr_listen.c	/^vr_listen_begin(vr_listen *vlisten)$/;"	f
vr_listen_create	src/vr_listen.c	/^vr_listen_create(sds listen_str)$/;"	f
vr_listen_destroy	src/vr_listen.c	/^vr_listen_destroy(vr_listen *vliston)$/;"	f
vr_listen_reuse	src/vr_listen.c	/^vr_listen_reuse(vr_listen *p)$/;"	f	file:
vr_master	src/vr_master.h	/^typedef struct vr_master {$/;"	s
vr_master	src/vr_master.h	/^}vr_master;$/;"	t	typeref:struct:vr_master
vr_memchr	src/vr_util.h	150;"	d
vr_memcpy	src/vr_util.h	144;"	d
vr_memmove	src/vr_util.h	147;"	d
vr_msec_now	src/vr_util.c	/^vr_msec_now(void)$/;"	f
vr_net_format_addr	src/vr_util.c	/^static int vr_net_format_addr(char *buf, size_t buf_len, char *ip, int port) {$/;"	f	file:
vr_net_format_peer	src/vr_util.c	/^int vr_net_format_peer(int fd, char *buf, size_t buf_len) {$/;"	f
vr_net_peer_to_string	src/vr_util.c	/^static int vr_net_peer_to_string(int fd, char *ip, size_t ip_len, int *port) {$/;"	f	file:
vr_object	src/vr_object.h	/^typedef struct vr_object {$/;"	s
vr_post_run	src/vr.c	/^vr_post_run(struct instance *nci)$/;"	f	file:
vr_pre_run	src/vr.c	/^vr_pre_run(struct instance *nci)$/;"	f	file:
vr_print_done	src/vr.c	/^vr_print_done(void)$/;"	f	file:
vr_print_run	src/vr.c	/^vr_print_run(struct instance *nci)$/;"	f	file:
vr_read	src/vr_util.h	99;"	d
vr_readv	src/vr_util.h	102;"	d
vr_recvn	src/vr_util.h	92;"	d
vr_remove_pidfile	src/vr.c	/^vr_remove_pidfile(struct instance *nci)$/;"	f	file:
vr_replication	src/vr_replication.h	/^struct vr_replication {$/;"	s
vr_replication_deinit	src/vr_replication.c	/^void vr_replication_deinit(void)$/;"	f
vr_replication_init	src/vr_replication.c	/^int vr_replication_init(void)$/;"	f
vr_resolve	src/vr_util.c	/^vr_resolve(sds name, int port, struct sockinfo *si)$/;"	f
vr_resolve_inet	src/vr_util.c	/^vr_resolve_inet(sds name, int port, struct sockinfo *si)$/;"	f	file:
vr_resolve_unix	src/vr_util.c	/^vr_resolve_unix(sds name, struct sockinfo *si)$/;"	f	file:
vr_run	src/vr.c	/^vr_run(struct instance *nci)$/;"	f	file:
vr_sendn	src/vr_util.h	89;"	d
vr_server	src/vr_server.h	/^struct vr_server {$/;"	s
vr_set_blocking	src/vr_util.c	/^vr_set_blocking(int sd)$/;"	f
vr_set_default_options	src/vr.c	/^vr_set_default_options(struct instance *nci)$/;"	f	file:
vr_set_default_options	tests/vrtest.c	/^vr_set_default_options(void)$/;"	f	file:
vr_set_linger	src/vr_util.c	/^vr_set_linger(int sd, int timeout)$/;"	f
vr_set_nonblocking	src/vr_util.c	/^vr_set_nonblocking(int sd)$/;"	f
vr_set_rcvbuf	src/vr_util.c	/^vr_set_rcvbuf(int sd, int size)$/;"	f
vr_set_reuseaddr	src/vr_util.c	/^vr_set_reuseaddr(int sd)$/;"	f
vr_set_sndbuf	src/vr_util.c	/^vr_set_sndbuf(int sd, int size)$/;"	f
vr_set_tcpkeepalive	src/vr_util.c	/^vr_set_tcpkeepalive(int sd, int keepidle, int keepinterval, int keepcount)$/;"	f
vr_set_tcpnodelay	src/vr_util.c	/^vr_set_tcpnodelay(int sd)$/;"	f
vr_show_usage	src/vr.c	/^vr_show_usage(void)$/;"	f	file:
vr_show_usage	tests/vrtest.c	/^vr_show_usage(void)$/;"	f	file:
vr_stats	src/vr_stats.h	/^typedef struct vr_stats {$/;"	s
vr_stats	src/vr_stats.h	/^}vr_stats;$/;"	t	typeref:struct:vr_stats
vr_stats_deinit	src/vr_stats.c	/^vr_stats_deinit(vr_stats *stats)$/;"	f
vr_stats_init	src/vr_stats.c	/^vr_stats_init(vr_stats *stats)$/;"	f
vr_strchr	src/vr_util.h	159;"	d
vr_strlen	src/vr_util.h	153;"	d
vr_strncmp	src/vr_util.h	156;"	d
vr_strndup	src/vr_util.h	165;"	d
vr_strrchr	src/vr_util.h	162;"	d
vr_test_conf	src/vr.c	/^vr_test_conf(struct instance *nci, int test)$/;"	f	file:
vr_thread	src/vr_thread.h	/^typedef struct vr_thread {$/;"	s
vr_thread	src/vr_thread.h	/^}vr_thread;$/;"	t	typeref:struct:vr_thread
vr_thread_deinit	src/vr_thread.c	/^vr_thread_deinit(vr_thread *thread)$/;"	f
vr_thread_func_t	src/vr_thread.h	/^typedef void *(*vr_thread_func_t)(void *data);$/;"	t
vr_thread_init	src/vr_thread.c	/^vr_thread_init(vr_thread *thread)$/;"	f
vr_thread_run	src/vr_thread.c	/^static void *vr_thread_run(void *data)$/;"	f	file:
vr_thread_start	src/vr_thread.c	/^int vr_thread_start(vr_thread *thread)$/;"	f
vr_usec_now	src/vr_util.c	/^vr_usec_now(void)$/;"	f
vr_valid_port	src/vr_util.c	/^vr_valid_port(int n)$/;"	f
vr_worker	src/vr_worker.h	/^typedef struct vr_worker {$/;"	s
vr_worker	src/vr_worker.h	/^}vr_worker;$/;"	t	typeref:struct:vr_worker
vr_worker_deinit	src/vr_worker.c	/^vr_worker_deinit(vr_worker *worker)$/;"	f
vr_worker_init	src/vr_worker.c	/^vr_worker_init(vr_worker *worker)$/;"	f
vr_write	src/vr_util.h	105;"	d
vr_writev	src/vr_util.h	108;"	d
vrt_assert	tests/vrt_util.c	/^vrt_assert(const char *cond, const char *file, int line, int panic)$/;"	f
vrt_backend_deinit	tests/vrt_backend.c	/^void vrt_backend_deinit(void)$/;"	f
vrt_backend_init	tests/vrt_backend.c	/^int vrt_backend_init(int threads_count, char *test_target_groups)$/;"	f
vrt_backend_thread_run	tests/vrt_backend.c	/^static void *vrt_backend_thread_run(void *args)$/;"	f	file:
vrt_clean_options	tests/vrabtest.c	/^vrt_clean_options(void)$/;"	f	file:
vrt_daemonize	tests/vrabtest.c	/^static int vrt_daemonize(int dump_core)$/;"	f	file:
vrt_data_checker_deinit	tests/vrt_check_data.c	/^void vrt_data_checker_deinit(void)$/;"	f
vrt_data_checker_init	tests/vrt_check_data.c	/^int vrt_data_checker_init(char *checker, char *test_target_groups)$/;"	f
vrt_data_checker_run	tests/vrt_check_data.c	/^static void *vrt_data_checker_run(void *args)$/;"	f	file:
vrt_dispatch_data_deinit	tests/vrt_dispatch_data.c	/^void vrt_dispatch_data_deinit(void)$/;"	f
vrt_dispatch_data_init	tests/vrt_dispatch_data.c	/^int vrt_dispatch_data_init(int threads_count, char *test_target_groups, int connections)$/;"	f
vrt_dispatch_data_thread_run	tests/vrt_dispatch_data.c	/^static void *vrt_dispatch_data_thread_run(void *args)$/;"	f	file:
vrt_get_options	tests/vrabtest.c	/^vrt_get_options(int argc, char **argv)$/;"	f	file:
vrt_msec_now	tests/vrt_util.c	/^vrt_msec_now(void)$/;"	f
vrt_produce_data_deinit	tests/vrt_produce_data.c	/^void vrt_produce_data_deinit(void)$/;"	f
vrt_produce_data_init	tests/vrt_produce_data.c	/^int vrt_produce_data_init(int key_length_range_min,int key_length_range_max, $/;"	f
vrt_produce_thread_run	tests/vrt_produce_data.c	/^static void *vrt_produce_thread_run(void *args)$/;"	f	file:
vrt_produce_threads_deinit	tests/vrt_produce_data.c	/^static void vrt_produce_threads_deinit(void)$/;"	f	file:
vrt_produce_threads_init	tests/vrt_produce_data.c	/^static int vrt_produce_threads_init(unsigned int produce_threads_count, $/;"	f	file:
vrt_scnprintf	tests/vrt_util.c	/^vrt_scnprintf(char *buf, size_t size, const char *fmt, ...)$/;"	f
vrt_sec_now	tests/vrt_util.c	/^vrt_sec_now(void)$/;"	f
vrt_set_default_options	tests/vrabtest.c	/^vrt_set_default_options(void)$/;"	f	file:
vrt_show_usage	tests/vrabtest.c	/^vrt_show_usage(void)$/;"	f	file:
vrt_start_backend	tests/vrt_backend.c	/^int vrt_start_backend(void)$/;"	f
vrt_start_data_checker	tests/vrt_check_data.c	/^int vrt_start_data_checker(void)$/;"	f
vrt_start_dispatch_data	tests/vrt_dispatch_data.c	/^int vrt_start_dispatch_data(void)$/;"	f
vrt_start_produce_data	tests/vrt_produce_data.c	/^int vrt_start_produce_data(void)$/;"	f
vrt_usec_now	tests/vrt_util.c	/^vrt_usec_now(void)$/;"	f
vrt_vscnprintf	tests/vrt_util.c	/^vrt_vscnprintf(char *buf, size_t size, const char *fmt, va_list args)$/;"	f
vrt_wait_backend	tests/vrt_backend.c	/^int vrt_wait_backend(void)$/;"	f
vrt_wait_data_checker	tests/vrt_check_data.c	/^int vrt_wait_data_checker(void)$/;"	f
vrt_wait_dispatch_data	tests/vrt_dispatch_data.c	/^int vrt_wait_dispatch_data(void)$/;"	f
vrt_wait_produce_data	tests/vrt_produce_data.c	/^int vrt_wait_produce_data(void)$/;"	f
watchCommand	src/vr_multi.c	/^void watchCommand(client *c) {$/;"	f
watchForKey	src/vr_multi.c	/^void watchForKey(client *c, robj *key) {$/;"	f
watchedKey	src/vr_multi.c	/^typedef struct watchedKey {$/;"	s	file:
watchedKey	src/vr_multi.c	/^} watchedKey;$/;"	t	typeref:struct:watchedKey	file:
watched_keys	src/vr_client.h	/^    dlist *watched_keys;     \/* Keys WATCHED for MULTI\/EXEC CAS *\/$/;"	m	struct:client
watched_keys	src/vr_db.h	/^    dict *watched_keys;         \/* WATCHED keys for MULTI\/EXEC CAS *\/$/;"	m	struct:redisDb
weight	src/vr_t_zset.h	/^    double weight;$/;"	m	struct:__anon8
wfds	dep/ae/ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
wfileProc	dep/ae/ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent
when_ms	dep/ae/ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	struct:aeTimeEvent
when_sec	dep/ae/ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	struct:aeTimeEvent
woff	src/vr_client.h	/^    long long woff;         \/* Last write global replication offset. *\/$/;"	m	struct:client
workdir	tests/vrt_public.c	/^static sds workdir = NULL;$/;"	v	file:
worker_before_sleep	src/vr_worker.c	/^worker_before_sleep(struct aeEventLoop *eventLoop, void *private_data) {$/;"	f
worker_cron	src/vr_worker.c	/^worker_cron(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f
worker_get_next_idx	src/vr_worker.c	/^worker_get_next_idx(int curidx)$/;"	f
worker_thread_run	src/vr_worker.c	/^worker_thread_run(void *args)$/;"	f	file:
workers	src/vr_worker.c	/^struct darray workers;$/;"	v	typeref:struct:darray
workers_deinit	src/vr_worker.c	/^workers_deinit(void)$/;"	f
workers_init	src/vr_worker.c	/^workers_init(uint32_t worker_count)$/;"	f
workers_run	src/vr_worker.c	/^workers_run(void)$/;"	f
workers_wait	src/vr_worker.c	/^workers_wait(void)$/;"	f
writeHandler	tests/vrt_benchmark.c	/^static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
writeToClient	src/vr_client.c	/^int writeToClient(int fd, client *c, int handler_installed) {$/;"	f
written	tests/vrt_benchmark.c	/^    size_t written;         \/* Bytes of 'obuf' already written *\/$/;"	m	struct:_benchmark_client	file:
wrongtypeerr	src/vr_server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct
zaddCommand	src/vr_t_zset.c	/^void zaddCommand(client *c) {$/;"	f
zaddGenericCommand	src/vr_t_zset.c	/^void zaddGenericCommand(client *c, int flags) {$/;"	f
zadd_cmd_nck	tests/vrt_produce_data.c	/^static int zadd_cmd_nck(redisReply *reply)$/;"	f	file:
zadd_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zadd_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zcardCommand	src/vr_t_zset.c	/^void zcardCommand(client *c) {$/;"	f
zcard_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zcard_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zcountCommand	src/vr_t_zset.c	/^void zcountCommand(client *c) {$/;"	f
zcount_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zcount_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zi	src/vr_quicklist.h	/^    unsigned char *zi;$/;"	m	struct:quicklistEntry
zi	src/vr_quicklist.h	/^    unsigned char *zi;$/;"	m	struct:quicklistIter
zincrbyCommand	src/vr_t_zset.c	/^void zincrbyCommand(client *c) {$/;"	f
zincrby_cmd_nck	tests/vrt_produce_data.c	/^static int zincrby_cmd_nck(redisReply *reply)$/;"	f	file:
zincrby_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zincrby_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zinterstoreCommand	src/vr_t_zset.c	/^void zinterstoreCommand(client *c) {$/;"	f
zipEncodeLength	src/vr_ziplist.c	/^static unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen) {$/;"	f	file:
zipEntry	src/vr_ziplist.c	/^static void zipEntry(unsigned char *p, zlentry *e) {$/;"	f	file:
zipIntSize	src/vr_ziplist.c	/^static unsigned int zipIntSize(unsigned char encoding) {$/;"	f	file:
zipLoadInteger	src/vr_ziplist.c	/^static int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {$/;"	f	file:
zipPrevEncodeLength	src/vr_ziplist.c	/^static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	file:
zipPrevEncodeLengthForceLarge	src/vr_ziplist.c	/^static void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len) {$/;"	f	file:
zipPrevLenByteDiff	src/vr_ziplist.c	/^static int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {$/;"	f	file:
zipRawEntryLength	src/vr_ziplist.c	/^static unsigned int zipRawEntryLength(unsigned char *p) {$/;"	f	file:
zipSaveInteger	src/vr_ziplist.c	/^static void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {$/;"	f	file:
zipTryEncoding	src/vr_ziplist.c	/^static int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {$/;"	f	file:
ziplistBlobLen	src/vr_ziplist.c	/^size_t ziplistBlobLen(unsigned char *zl) {$/;"	f
ziplistCompare	src/vr_ziplist.c	/^unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {$/;"	f
ziplistDelete	src/vr_ziplist.c	/^unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {$/;"	f
ziplistDeleteRange	src/vr_ziplist.c	/^unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {$/;"	f
ziplistFind	src/vr_ziplist.c	/^unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {$/;"	f
ziplistGet	src/vr_ziplist.c	/^unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {$/;"	f
ziplistGetObject	src/vr_t_zset.c	/^robj *ziplistGetObject(unsigned char *sptr) {$/;"	f
ziplistIndex	src/vr_ziplist.c	/^unsigned char *ziplistIndex(unsigned char *zl, int index) {$/;"	f
ziplistInsert	src/vr_ziplist.c	/^unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f
ziplistLen	src/vr_ziplist.c	/^unsigned int ziplistLen(unsigned char *zl) {$/;"	f
ziplistMerge	src/vr_ziplist.c	/^unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {$/;"	f
ziplistNew	src/vr_ziplist.c	/^unsigned char *ziplistNew(void) {$/;"	f
ziplistNext	src/vr_ziplist.c	/^unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {$/;"	f
ziplistPrev	src/vr_ziplist.c	/^unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {$/;"	f
ziplistPush	src/vr_ziplist.c	/^unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {$/;"	f
ziplistRepr	src/vr_ziplist.c	/^void ziplistRepr(unsigned char *zl) {$/;"	f
ziplistResize	src/vr_ziplist.c	/^static unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {$/;"	f	file:
ziplistTest	src/vr_ziplist.c	/^int ziplistTest(int argc, char **argv) {$/;"	f
zipmapBlobLen	src/vr_zipmap.c	/^size_t zipmapBlobLen(unsigned char *zm) {$/;"	f
zipmapDecodeLength	src/vr_zipmap.c	/^static unsigned int zipmapDecodeLength(unsigned char *p) {$/;"	f	file:
zipmapDel	src/vr_zipmap.c	/^unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {$/;"	f
zipmapEncodeLength	src/vr_zipmap.c	/^static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	file:
zipmapExists	src/vr_zipmap.c	/^int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {$/;"	f
zipmapGet	src/vr_zipmap.c	/^int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {$/;"	f
zipmapLen	src/vr_zipmap.c	/^unsigned int zipmapLen(unsigned char *zm) {$/;"	f
zipmapLookupRaw	src/vr_zipmap.c	/^static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {$/;"	f	file:
zipmapNew	src/vr_zipmap.c	/^unsigned char *zipmapNew(void) {$/;"	f
zipmapNext	src/vr_zipmap.c	/^unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {$/;"	f
zipmapRawEntryLength	src/vr_zipmap.c	/^static unsigned int zipmapRawEntryLength(unsigned char *p) {$/;"	f	file:
zipmapRawKeyLength	src/vr_zipmap.c	/^static unsigned int zipmapRawKeyLength(unsigned char *p) {$/;"	f	file:
zipmapRawValueLength	src/vr_zipmap.c	/^static unsigned int zipmapRawValueLength(unsigned char *p) {$/;"	f	file:
zipmapRequiredLength	src/vr_zipmap.c	/^static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {$/;"	f	file:
zipmapResize	src/vr_zipmap.c	/^static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {$/;"	f	file:
zipmapRewind	src/vr_zipmap.c	/^unsigned char *zipmapRewind(unsigned char *zm) {$/;"	f
zipmapSet	src/vr_zipmap.c	/^unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {$/;"	f
zl	src/vr_quicklist.h	/^    unsigned char *zl;$/;"	m	struct:quicklistNode
zl	src/vr_t_zset.h	/^                unsigned char *zl;$/;"	m	struct:__anon8::__anon9::_iterzset::__anon12
zl	src/vr_t_zset.h	/^            } zl;$/;"	m	union:__anon8::__anon9::_iterzset	typeref:struct:__anon8::__anon9::_iterzset::__anon12
zlentry	src/vr_ziplist.c	/^typedef struct zlentry {$/;"	s	file:
zlentry	src/vr_ziplist.c	/^} zlentry;$/;"	t	typeref:struct:zlentry	file:
zlexcountCommand	src/vr_t_zset.c	/^void zlexcountCommand(client *c) {$/;"	f
zlexrangespec	src/vr_t_zset.h	/^} zlexrangespec;$/;"	t	typeref:struct:__anon7
zrangeCommand	src/vr_t_zset.c	/^void zrangeCommand(client *c) {$/;"	f
zrangeGenericCommand	src/vr_t_zset.c	/^void zrangeGenericCommand(client *c, int reverse) {$/;"	f
zrange_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zrange_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zrangebylexCommand	src/vr_t_zset.c	/^void zrangebylexCommand(client *c) {$/;"	f
zrangebyscoreCommand	src/vr_t_zset.c	/^void zrangebyscoreCommand(client *c) {$/;"	f
zrangebyscore_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zrangebyscore_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zrangespec	src/vr_t_zset.h	/^} zrangespec;$/;"	t	typeref:struct:__anon6
zrankCommand	src/vr_t_zset.c	/^void zrankCommand(client *c) {$/;"	f
zrankGenericCommand	src/vr_t_zset.c	/^void zrankGenericCommand(client *c, int reverse) {$/;"	f
zrank_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zrank_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zremCommand	src/vr_t_zset.c	/^void zremCommand(client *c) {$/;"	f
zrem_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zrem_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zremrangeGenericCommand	src/vr_t_zset.c	/^void zremrangeGenericCommand(client *c, int rangetype) {$/;"	f
zremrangebylexCommand	src/vr_t_zset.c	/^void zremrangebylexCommand(client *c) {$/;"	f
zremrangebylex_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zremrangebylex_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zremrangebyrankCommand	src/vr_t_zset.c	/^void zremrangebyrankCommand(client *c) {$/;"	f
zremrangebyrank_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zremrangebyrank_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zremrangebyscoreCommand	src/vr_t_zset.c	/^void zremrangebyscoreCommand(client *c) {$/;"	f
zremrangebyscore_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zremrangebyscore_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zrevrangeCommand	src/vr_t_zset.c	/^void zrevrangeCommand(client *c) {$/;"	f
zrevrange_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zrevrange_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zrevrangebylexCommand	src/vr_t_zset.c	/^void zrevrangebylexCommand(client *c) {$/;"	f
zrevrangebyscoreCommand	src/vr_t_zset.c	/^void zrevrangebyscoreCommand(client *c) {$/;"	f
zrevrangebyscore_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zrevrangebyscore_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zrevrankCommand	src/vr_t_zset.c	/^void zrevrankCommand(client *c) {$/;"	f
zrevrank_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zrevrank_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zs	src/vr_t_zset.h	/^                zset *zs;$/;"	m	struct:__anon8::__anon9::_iterzset::__anon13
zscanCommand	src/vr_t_zset.c	/^void zscanCommand(client *c) {$/;"	f
zscoreCommand	src/vr_t_zset.c	/^void zscoreCommand(client *c) {$/;"	f
zscore_cmd_producer	tests/vrt_produce_data.c	/^static data_unit *zscore_cmd_producer(data_producer *dp, produce_scheme *ps)$/;"	f	file:
zset	src/vr_server.h	/^typedef struct zset {$/;"	s
zset	src/vr_server.h	/^} zset;$/;"	t	typeref:struct:zset
zset	src/vr_t_zset.h	/^        } zset;$/;"	m	union:__anon8::__anon9	typeref:union:__anon8::__anon9::_iterzset
zsetConvert	src/vr_t_zset.c	/^void zsetConvert(robj *zobj, int encoding) {$/;"	f
zsetConvertToZiplistIfNeeded	src/vr_t_zset.c	/^void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {$/;"	f
zsetDictType	src/vr_server.c	/^dictType zsetDictType = {$/;"	v
zsetLength	src/vr_t_zset.c	/^unsigned int zsetLength(robj *zobj) {$/;"	f
zsetScore	src/vr_t_zset.c	/^int zsetScore(robj *zobj, robj *member, double *score) {$/;"	f
zset_max_ziplist_entries	src/vr_server.h	/^    size_t zset_max_ziplist_entries;$/;"	m	struct:vr_server
zset_max_ziplist_value	src/vr_server.h	/^    size_t zset_max_ziplist_value;$/;"	m	struct:vr_server
zsetopsrc	src/vr_t_zset.h	/^} zsetopsrc;$/;"	t	typeref:struct:__anon8
zsetopval	src/vr_t_zset.h	/^} zsetopval;$/;"	t	typeref:struct:__anon14
zskiplist	src/vr_server.h	/^typedef struct zskiplist {$/;"	s
zskiplist	src/vr_server.h	/^} zskiplist;$/;"	t	typeref:struct:zskiplist
zskiplistLevel	src/vr_server.h	/^    struct zskiplistLevel {$/;"	s	struct:zskiplistNode
zskiplistNode	src/vr_server.h	/^typedef struct zskiplistNode {$/;"	s
zskiplistNode	src/vr_server.h	/^} zskiplistNode;$/;"	t	typeref:struct:zskiplistNode
zsl	src/vr_server.h	/^    zskiplist *zsl;$/;"	m	struct:zset
zslCreate	src/vr_t_zset.c	/^zskiplist *zslCreate(void) {$/;"	f
zslCreateNode	src/vr_t_zset.c	/^zskiplistNode *zslCreateNode(int level, double score, robj *obj) {$/;"	f
zslDelete	src/vr_t_zset.c	/^int zslDelete(zskiplist *zsl, double score, robj *obj) {$/;"	f
zslDeleteNode	src/vr_t_zset.c	/^void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {$/;"	f
zslDeleteRangeByLex	src/vr_t_zset.c	/^unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {$/;"	f
zslDeleteRangeByRank	src/vr_t_zset.c	/^unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {$/;"	f
zslDeleteRangeByScore	src/vr_t_zset.c	/^unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {$/;"	f
zslFirstInLexRange	src/vr_t_zset.c	/^zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f
zslFirstInRange	src/vr_t_zset.c	/^zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {$/;"	f
zslFree	src/vr_t_zset.c	/^void zslFree(zskiplist *zsl) {$/;"	f
zslFreeLexRange	src/vr_t_zset.c	/^void zslFreeLexRange(zlexrangespec *spec) {$/;"	f
zslFreeNode	src/vr_t_zset.c	/^void zslFreeNode(zskiplistNode *node) {$/;"	f
zslGetElementByRank	src/vr_t_zset.c	/^zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {$/;"	f
zslGetRank	src/vr_t_zset.c	/^unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) {$/;"	f
zslInsert	src/vr_t_zset.c	/^zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) {$/;"	f
zslIsInLexRange	src/vr_t_zset.c	/^int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f
zslIsInRange	src/vr_t_zset.c	/^int zslIsInRange(zskiplist *zsl, zrangespec *range) {$/;"	f
zslLastInLexRange	src/vr_t_zset.c	/^zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f
zslLastInRange	src/vr_t_zset.c	/^zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {$/;"	f
zslLexValueGteMin	src/vr_t_zset.c	/^static int zslLexValueGteMin(robj *value, zlexrangespec *spec) {$/;"	f	file:
zslLexValueLteMax	src/vr_t_zset.c	/^static int zslLexValueLteMax(robj *value, zlexrangespec *spec) {$/;"	f	file:
zslParseLexRange	src/vr_t_zset.c	/^static int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {$/;"	f	file:
zslParseLexRangeItem	src/vr_t_zset.c	/^int zslParseLexRangeItem(robj *item, robj **dest, int *ex) {$/;"	f
zslParseRange	src/vr_t_zset.c	/^static int zslParseRange(robj *min, robj *max, zrangespec *spec) {$/;"	f	file:
zslRandomLevel	src/vr_t_zset.c	/^int zslRandomLevel(void) {$/;"	f
zslValueGteMin	src/vr_t_zset.c	/^static int zslValueGteMin(double value, zrangespec *spec) {$/;"	f	file:
zslValueLteMax	src/vr_t_zset.c	/^int zslValueLteMax(double value, zrangespec *spec) {$/;"	f
zuiBufferFromValue	src/vr_t_zset.c	/^int zuiBufferFromValue(zsetopval *val) {$/;"	f
zuiClearIterator	src/vr_t_zset.c	/^void zuiClearIterator(zsetopsrc *op) {$/;"	f
zuiCompareByCardinality	src/vr_t_zset.c	/^int zuiCompareByCardinality(const void *s1, const void *s2) {$/;"	f
zuiFind	src/vr_t_zset.c	/^int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {$/;"	f
zuiInitIterator	src/vr_t_zset.c	/^void zuiInitIterator(zsetopsrc *op) {$/;"	f
zuiLength	src/vr_t_zset.c	/^int zuiLength(zsetopsrc *op) {$/;"	f
zuiLongLongFromValue	src/vr_t_zset.c	/^int zuiLongLongFromValue(zsetopval *val) {$/;"	f
zuiNext	src/vr_t_zset.c	/^int zuiNext(zsetopsrc *op, zsetopval *val) {$/;"	f
zuiObjectFromValue	src/vr_t_zset.c	/^robj *zuiObjectFromValue(zsetopval *val) {$/;"	f
zunionInterAggregate	src/vr_t_zset.c	/^inline static void zunionInterAggregate(double *target, double val, int aggregate) {$/;"	f	file:
zunionInterDictValue	src/vr_t_zset.c	1862;"	d	file:
zunionInterGenericCommand	src/vr_t_zset.c	/^void zunionInterGenericCommand(client *c, robj *dstkey, int op) {$/;"	f
zunionInterGetKeys	src/vr_db.c	/^int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f
zunionstoreCommand	src/vr_t_zset.c	/^void zunionstoreCommand(client *c) {$/;"	f
zzlCompareElements	src/vr_t_zset.c	/^int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {$/;"	f
zzlDelete	src/vr_t_zset.c	/^unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {$/;"	f
zzlDeleteRangeByLex	src/vr_t_zset.c	/^unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {$/;"	f
zzlDeleteRangeByRank	src/vr_t_zset.c	/^unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {$/;"	f
zzlDeleteRangeByScore	src/vr_t_zset.c	/^unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {$/;"	f
zzlFind	src/vr_t_zset.c	/^unsigned char *zzlFind(unsigned char *zl, robj *ele, double *score) {$/;"	f
zzlFirstInLexRange	src/vr_t_zset.c	/^unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f
zzlFirstInRange	src/vr_t_zset.c	/^unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {$/;"	f
zzlGetScore	src/vr_t_zset.c	/^double zzlGetScore(unsigned char *sptr) {$/;"	f
zzlInsert	src/vr_t_zset.c	/^unsigned char *zzlInsert(unsigned char *zl, robj *ele, double score) {$/;"	f
zzlInsertAt	src/vr_t_zset.c	/^unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, robj *ele, double score) {$/;"	f
zzlIsInLexRange	src/vr_t_zset.c	/^int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f
zzlIsInRange	src/vr_t_zset.c	/^int zzlIsInRange(unsigned char *zl, zrangespec *range) {$/;"	f
zzlLastInLexRange	src/vr_t_zset.c	/^unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f
zzlLastInRange	src/vr_t_zset.c	/^unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {$/;"	f
zzlLength	src/vr_t_zset.c	/^unsigned int zzlLength(unsigned char *zl) {$/;"	f
zzlLexValueGteMin	src/vr_t_zset.c	/^static int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {$/;"	f	file:
zzlLexValueLteMax	src/vr_t_zset.c	/^static int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {$/;"	f	file:
zzlNext	src/vr_t_zset.c	/^void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f
zzlPrev	src/vr_t_zset.c	/^void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f
